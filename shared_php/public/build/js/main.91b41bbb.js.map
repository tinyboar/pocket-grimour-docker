{"version":3,"file":"js/main.91b41bbb.js","mappings":"yxBAAA,IAKqBA,EAAK,WAuDtB,O,EAhCA,SAAAA,EAAYC,I,4FAAMC,CAAA,KAAAF,GAMdG,KAAKF,KAAOE,KAAKC,YAAYH,GAE7BE,KAAKE,QAEL,IAAMC,EAAcH,KAAKG,YAEzB,OAAO,IAAIC,MAAMJ,KAAM,CAEnBK,IAAG,SAACC,EAAQC,GAUR,QARMA,KAAYD,IAAWC,EAASC,WAAW,SAE7CF,EAAOC,GAAY,kBAAMD,EAAOG,QAC5BN,EAAYO,gBAAgBH,GAC/B,GAIED,EAAOC,EAElB,GAIR,E,EA0EC,EAAAI,IAAA,kBAAAC,MApHD,SAAuBL,GAEnB,IAAMM,EAAUN,EAASO,QAAQ,OAAQ,IAEzC,OAAOD,EAAQE,OAAO,GAAGC,cAAgBH,EAAQI,MAAM,EAE3D,K,EAsCA,EAAAN,IAAA,QAAAC,MAIA,WAEA,GAEA,CAAAD,IAAA,cAAAC,MASA,SAAYd,GACR,OAAOA,CACX,GAEA,CAAAa,IAAA,QAAAC,MAMA,WACI,OAAO,IAAIZ,KAAKG,YAAYH,KAAKF,KACrC,GAEA,CAAAa,IAAA,UAAAC,MAQA,SAAQD,GACJ,OAAOO,OAAOC,UAAUC,eAAeC,KAAKrB,KAAKF,KAAMa,EAC3D,GAEA,CAAAA,IAAA,UAAAC,MAUA,SAAQD,GAEJ,IAAKX,KAAKsB,QAAQX,GACd,MAAM,IAAIY,eAAe,0BAADC,OAA2Bb,EAAG,MAG1D,OAAOX,KAAKF,KAAKa,EAErB,GAEA,CAAAA,IAAA,aAAAC,MAOA,WACI,OAAOa,KAAKC,MAAMD,KAAKE,UAAU3B,KAAKF,MAC1C,M,yFA9GC,CAjBqB,G,gtDCA1B,I,MAGqB8B,EAAQ,WA+CzB,O,EAVA,SAAAA,EAAYC,I,4FAAU9B,CAAA,KAAA6B,GAMlB5B,KAAK6B,SAAWA,CAEpB,E,EA4BC,EAAAlB,IAAA,SAAAC,MAvDD,SAAciB,GAEV,IACIC,EACA9B,KADA8B,MAEEnB,GAAMoB,EAAAA,EAAAA,IAASF,GAMrB,OAJKC,EAAMnB,KACPmB,EAAMnB,GAAO,IAAIX,KAAK6B,IAGnBC,EAAMnB,EAEjB,K,EAgBA,EAAAA,IAAA,OAAAC,MAgBA,SAAKoB,GAED,IAAMC,EAAQjC,KAAK6B,SAASK,QAAQC,WAAU,GAM9C,OAJAjB,OAAOkB,QAAQJ,GAAWK,QAAQ,SAAAC,GAA0B,IAAAC,EAAAC,EAAAF,EAAA,GAAxBG,EAAQF,EAAA,GAAEG,EAAQH,EAAA,IAClDI,EAAAA,EAAAA,IAAOF,EAAUR,GAAOI,QAAQ,SAACO,GAAO,OAAKF,EAASE,EAAQ,EAClE,GAEOX,CAEX,M,yFA1CC,CA/BwB,G,wsBAARL,E,EAAQ,Q,EAMVV,OAAO2B,OAAO,O,kGCdjC,IAGqBC,EAAQ,WA2CzB,O,0GAAAC,CAVA,SAAAD,K,4FAAc/C,CAAA,KAAA+C,GAMV9C,KAAKgD,MAAQC,SAASC,cAAc,MAExC,EAEA,EAAAvC,IAAA,KAAAC,MAQA,SAAGuC,EAAWC,GACVpD,KAAKgD,MAAMK,iBAAiBF,EAAWC,EAC3C,GAEA,CAAAzC,IAAA,MAAAC,MAQA,SAAIuC,EAAWC,GACXpD,KAAKgD,MAAMM,oBAAoBH,EAAWC,EAC9C,GAEA,CAAAzC,IAAA,SAAAC,MAUA,SAAOuC,EAAWI,GAEd,OAAO,IAAIC,YAAYL,EAAW,CAC9BM,SAAS,EACTC,YAAY,EACZH,OAAAA,GAGR,GAEA,CAAA5C,IAAA,UAAAC,MAWA,SAAQuC,EAAWI,GAEf,IAAMI,EACmB,iBAAdR,EACLnD,KAAK6C,OAAOM,EAAWI,GACvBJ,EAKN,OAFAnD,KAAKgD,MAAMY,cAAcD,GAElBA,CAEX,IAAC,EAAAhD,IAAA,SAAAC,MA9FD,SAAciD,GAEV,IACIC,EACA9D,KADA8D,UAOJ,OAJKA,EAAUD,KACXC,EAAUD,GAAQ,IAAI7D,MAGnB8D,EAAUD,EAErB,IAAC,CA5BwB,G,0zBAEzBE,CAFiBjB,EAAQ,YAMN5B,OAAO2B,OAAO,OCNrC,IAkCqBmB,EAAI,WAqCrB,O,0GAAAjB,CA3BA,SAAAiB,EAAYC,EAAOC,I,4FAAQnE,CAAA,KAAAiE,GAMvBhE,KAAKiE,MAAQA,EAMbjE,KAAKkE,OAASA,EAMdlE,KAAKmE,MAAQ,CACTC,OAAO,EACPH,OAAO,EACP3D,QAAQ,EACR+D,QAAQ,EAGhB,EAEA,EAAA1D,IAAA,YAAAC,MAOA,SAAUN,GACNN,KAAKM,OAASA,CAClB,GAEA,CAAAK,IAAA,cAAAC,MAMA,SAAY0D,GACRtE,KAAKsE,SAAWA,CACpB,GAEA,CAAA3D,IAAA,cAAAC,MAgBA,SAAYiD,EAAMU,GAEd,IAYgCC,EAX5BL,EACAnE,KADAmE,MAGJ,IAAKjD,OAAOC,UAAUC,eAAeC,KAAK8C,EAAON,GAC7C,MAAM,IAAItC,eAAe,uBAADC,OAAwBqC,EAAI,YAGrCY,IAAfF,IACAA,GAAcJ,EAAMN,IAGpBU,IAAeJ,EAAMN,MAErBM,EAAMN,GAAQU,EAGD,QAAbC,EAAAxE,KAAKsE,gBAAQ,IAAAE,GAAbA,EAAeE,QAAQ,eAADlD,OAAgBqC,GAAQ,CAC1Cc,KAAM3E,KACNmE,MAAOI,KAKf,OAAOA,CAEX,GAEA,CAAA5D,IAAA,cAAAC,MAQA,SAAY2D,IAEsC,IAA1CvE,KAAK4E,YAAY,QAASL,IAC1BvE,KAAK4E,YAAY,UAAU,EAGnC,GAEA,CAAAjE,IAAA,UAAAC,MAMA,WACI,OAAOZ,KAAKmE,MAAMC,KACtB,GAEA,CAAAzD,IAAA,WAAAC,MAIA,WAEIZ,KAAK6E,aAAY,GACjB7E,KAAK4E,YAAY,UAAU,EAE/B,GAEA,CAAAjE,IAAA,cAAAC,MAWA,SAAY2D,GAGJvE,KAAK4E,YAAY,QAASL,IACvBvE,KAAKmE,MAAM7D,OAEdN,KAAK8E,WAEL9E,KAAK4E,YAAY,UAAU,EAGnC,GAEA,CAAAjE,IAAA,eAAAC,MAWA,SAAa2D,GAGLvE,KAAK4E,YAAY,SAAUL,IACxBvE,KAAKmE,MAAMF,MAEdjE,KAAK8E,WAEL9E,KAAK4E,YAAY,UAAU,EAGnC,GAEA,CAAAjE,IAAA,WAAAC,MAMA,WACI,OAAOmE,QAAQ/E,KAAKiE,QAAUjE,KAAKmE,MAAMC,OAASpE,KAAKmE,MAAME,MAEjE,GAEA,CAAA1D,IAAA,UAAAC,MAQA,SAAQoE,GACJ,OAAOD,QAAQ/E,KAAKiE,QAAUjE,KAAKiE,MAAMgB,QAAQD,EACrD,GAEA,CAAArE,IAAA,YAAAC,MAMA,WACI,OAAOZ,KAAKM,MAChB,GAEA,CAAAK,IAAA,WAAAC,MAOA,WACI,OAAOZ,KAAKiE,KAChB,GAEA,CAAAtD,IAAA,YAAAC,MAMA,WACI,OAAOZ,KAAKkE,MAChB,GAEA,CAAAvD,IAAA,gBAAAC,MAMA,WACI,OAAOmE,QAAQ/E,KAAKkF,WACxB,GAEA,CAAAvE,IAAA,gBAAAC,MAMA,SAAcsE,GAMVlF,KAAKkF,WAAaA,CAEtB,GAEA,CAAAvE,IAAA,cAAAC,MAMA,SAAYiB,GAMR7B,KAAK6B,SAAWA,CAEpB,GAEA,CAAAlB,IAAA,QAAAC,MA0BA,WAAQ,IAAAuE,EACJ,MAAO,SAAP3D,OAAgBxB,KAAKM,OAAO8E,QAAO,KAAA5D,QAAc,QAAV2D,EAAAnF,KAAKiE,aAAK,IAAAkB,OAAA,EAAVA,EAAYC,UAAW,YAClE,GAEA,CAAAzE,IAAA,OAAAC,MAMA,WAAO,IAAAyE,EAAA,KAGC/E,EAOAN,KAPAM,OACA2D,EAMAjE,KANAiE,MACAC,EAKAlE,KALAkE,OACArC,EAIA7B,KAJA6B,SAEIyD,EAEJtF,KAHAG,YACImF,QAQR,OAAOzD,EAAS0D,KAAK,CACjB,wBAAyB,SAAC3C,GACtBA,EAAQ4C,GAAKH,EAAKD,OACtB,EACA,0BAAyB,SAACxC,GACtB0C,EAAQ1C,EAAStC,EACrB,EACA,+BAA8B,SAACsC,GAC3BA,EAAQ6C,YAAcnF,EAAOoF,SACjC,EACA,yBAAwB,SAAC9C,GACrB0C,EAAQ1C,EAASqB,EACrB,EACA,8BAA6B,SAACrB,GAC1BA,EAAQ6C,aAAcxB,aAAK,EAALA,EAAOyB,YAAa,EAC9C,EACA,0BAAyB,SAAC9C,GACtBA,EAAQ6C,YAAcvB,CAC1B,GAGR,IAAC,EAAAvD,IAAA,UAAAC,MAjED,SAAegC,EAASoC,GAEfA,IAILpC,EAAQ+C,IAAMX,EAAUY,WACxBhD,EAAQiD,IAAMb,EAAUU,UACxB9C,EAAQkD,MAAQd,EAAUU,UAE9B,IAAC,CA/SoB,G,uzDClCzB,IAIqBK,EAAa,SAAAC,GAAA,SAAAD,IAAA,O,4FAAAhG,CAAA,KAAAgG,GAAAE,EAAA,KAAAF,EAAAG,UAAA,Q,qRAAAC,CAAAJ,EAAAC,G,0GAAAjD,CAAAgD,EAAA,EAAApF,IAAA,cAAAC,MAgD9B,SAAYd,GAKR,O,2VAAAsG,CAAA,CACIZ,GAAI,GACJa,KAAM,GACNC,MAAO,GACPC,YAAa,GACbC,cAAe,GACfC,UAAU,GACP3G,EAGX,GAEA,CAAAa,IAAA,YAAAC,MAMA,WAEI,IAAA8F,EAII1G,KAAKF,KAHLwG,EAAKI,EAALJ,MACAD,EAAIK,EAAJL,KACAG,EAAaE,EAAbF,cAGJ,OAAOxG,KAAKG,YAAYwG,UAAUC,MAAMrB,KAAK,CACzC,sBAAqB,SAAC3C,GAClBA,EAAQ6C,YAAce,CAC1B,EACA,sBAAqB,SAAC5D,GAClBA,EAAQ6C,YAAcY,CAC1B,EACA,uBAAsB,SAACzD,GACnBA,EAAQ+C,IAAMW,CAClB,GAGR,GAEA,CAAA3F,IAAA,WAAAC,MAMA,WAAW,IAAAyE,EAAA,KAEPwB,EAGI7G,KAAKF,KAFL0F,EAAEqB,EAAFrB,GACAiB,EAAQI,EAARJ,SAGJ,OAAOzG,KAAKG,YAAYwG,UAAUG,KAAKvB,KAAK,CACxC,sDAAqD,SAAC3C,GAClDA,EAAQmE,QAAQC,WAAaxB,CACjC,EACA,2BAA0B,SAAC5C,GACvBA,EAAQqE,UAAUC,OAAO,YAAaT,EAC1C,EACA,6BAA8B,SAAC7D,GAC3BA,EAAQuE,OAAO9B,EAAK+B,YACxB,EACA,+BAA8B,SAACxE,GAC3BA,EAAQhC,MAAQ4E,CACpB,GAGR,IAAC,EAAA7E,IAAA,eAAAC,MAjHD,SAAoB+F,GAMhB3G,KAAK2G,UAAYA,CAErB,GAEA,CAAAhG,IAAA,YAAAC,MAaA,SAAiByG,GACbrH,KAAKsH,OAAOC,KAAKF,EACrB,GAEA,CAAA1G,IAAA,YAAAC,MAMA,WACI,OAAOZ,KAAKsH,MAChB,IAAC,CA3C6B,CAASzH,G,onEAAKkE,EAA3BgC,EAAa,SAuBd,ICtBpB,IAAMyB,EAAgBC,OAAO,SACvBC,EAAiBD,OAAO,UAKTE,EAAc,SAAA3B,GAAA,SAAA2B,IAAA,O,4FAAA5H,CAAA,KAAA4H,GAAA1B,EAAA,KAAA0B,EAAAzB,UAAA,Q,qRAAAC,CAAAwB,EAAA3B,G,0GAAAjD,CAAA4E,EAAA,EAAAhH,IAAA,cAAAC,MAuC/B,SAAYd,GAKR,O,2VAAAsG,CAAA,CACIZ,GAAI,GACJ3B,KAAM,GACN+D,QAAS,GACTC,KAAM,GACNC,WAAY,EACZC,mBAAoB,GACpBC,WAAY,EACZC,mBAAoB,GACpBC,UAAW,GACXhI,OAAO,EACPiI,QAAS,GACT7B,MAAO,GACP8B,QAAS,MACNtI,EAGX,GAEA,CAAAa,IAAA,QAAAC,MAGA,WAMIZ,KAAKqI,QAAS,EAQdrI,KAAKsI,cAAe,EAMpBtI,KAAKuI,cAAe,EAMpBvI,KAAKwI,OAAS,GAMdxI,KAAKkI,UAAY,EAErB,GAEA,CAAAvH,IAAA,QAAAC,MAGA,WAEI,IAAMqB,E,wHAAKwG,CAAAd,EAAA,eAAAc,CAAA,IAUX,OARAzI,KAAK0I,eAAerG,QAAQ,SAACgF,GACzBpF,EAAM0G,YAAYtB,EAASpF,QAC/B,GAEAjC,KAAK4I,YAAYvG,QAAQ,SAACsC,GACtB1C,EAAM4G,QAAQlE,EAClB,GAEO1C,CAEX,GAEA,CAAAtB,IAAA,cAAAC,MAMA,SAAYyG,GACRrH,KAAKkI,UAAUX,KAAKF,EACxB,GAEA,CAAA1G,IAAA,eAAAC,MAOA,WACI,OAAOZ,KAAKkI,SAChB,GAEA,CAAAvH,IAAA,aAAAC,MASA,SAAWuD,GAYP,YAVcM,IAAVN,IACAA,GAASnE,KAAKqI,QAGlBrI,KAAKqI,OAASlE,EAEVA,GACAnE,KAAK8I,iBAAgB,GAGlB9I,KAAK+I,WAEhB,GAEA,CAAApI,IAAA,YAAAC,MAMA,WACI,OAAOmE,QAAQ/E,KAAKqI,OACxB,GAEA,CAAA1H,IAAA,SAAAC,MASA,SAAOuD,GAQH,YANcM,IAAVN,IACAA,GAASnE,KAAKsI,cAGlBtI,KAAKsI,aAAenE,EAEbnE,KAAKgJ,iBAEhB,GAEA,CAAArI,IAAA,kBAAAC,MAMA,WACI,OAAOmE,QAAQ/E,KAAKsI,aACxB,GAEA,CAAA3H,IAAA,kBAAAC,MASA,SAAgBuD,GAQZ,YANcM,IAAVN,IACAA,GAASnE,KAAKuI,cAGlBvI,KAAKuI,aAAepE,EAEbnE,KAAKiJ,iBAEhB,GAEA,CAAAtI,IAAA,kBAAAC,MAMA,WACI,OAAOmE,QAAQ/E,KAAKuI,aACxB,GAEA,CAAA5H,IAAA,UAAAC,MASA,SAAQoE,GACJ,OAAOA,IAAchF,MAAQgF,EAAUI,UAAYpF,KAAKoF,OAC5D,GAEA,CAAAzE,IAAA,UAAAC,MAMA,SAAQ+D,GAEJA,EAAKuE,UAAUlJ,MAEfA,KAAKwI,OAAOjB,KAAK5C,EAErB,GAEA,CAAAhE,IAAA,iBAAAC,MAMA,SAAeuI,GAAY,IAAA9D,EAAA,KAEvB8D,EAAW9G,QAAQ,SAAC2C,GAChBK,EAAK+D,gBAAgBpE,GAAW,EACpC,EAEJ,GAEA,CAAArE,IAAA,mBAAAC,MAGA,WACIZ,KAAKwI,OAAOnG,QAAQ,SAACsC,GAAI,OAAKA,EAAKE,aAAY,EAAM,EACzD,GAEA,CAAAlE,IAAA,kBAAAC,MAQA,SAAgBoE,EAAWb,GAEvBnE,KAAKwI,OAAOnG,QAAQ,SAACsC,GAEbA,EAAKM,QAAQD,IACbL,EAAKE,YAAYV,EAGzB,EAEJ,GAEA,CAAAxD,IAAA,kBAAAC,MAQA,SAAgBqD,EAAOE,GAEnBnE,KAAKwI,OAAOnG,QAAQ,SAACsC,GAEbA,EAAKM,QAAQhB,IACbU,EAAK0E,YAAYlF,EAGzB,EAEJ,GAEA,CAAAxD,IAAA,mBAAAC,MAQA,SAAiBuD,GACbnE,KAAKwI,OAAOnG,QAAQ,SAACsC,GAAI,OAAKA,EAAK2E,aAAanF,EAAM,EAC1D,GAEA,CAAAxD,IAAA,YAAAC,MAMA,WACI,OAAOZ,KAAKwI,MAChB,GAEA,CAAA7H,IAAA,iBAAAC,MAMA,WACI,OAAOZ,KAAKwI,OAAOe,OAAO,SAAC5E,GAAI,OAAKA,EAAK6E,SAAS,EACtD,GAEA,CAAA7I,IAAA,kBAAAC,MAMA,WACI,OAAOZ,KAAKwI,OAAOe,OAAO,SAAC5E,GAAI,OAAKA,EAAK8E,UAAU,EACvD,GAEA,CAAA9I,IAAA,UAAAC,MAMA,WACI,OAAOmE,QAAQ/E,KAAKF,KAAK0H,GAC7B,GAEA,CAAA7G,IAAA,WAAAC,MAMA,WACI,OAAOmE,QAAQ/E,KAAKF,KAAK4H,GAC7B,GAEA,CAAA/G,IAAA,iBAAAC,MAWA,SAAe8I,EAAM7F,GAEjB,IACIuE,EACApI,KAAKF,KADLsI,QAEEuB,EAAUC,MAAMD,QAAQvB,GAE9B,GAAKA,KAAYuB,GAAYvB,EAAQyB,QAIrC,OAAOzB,EAAQ0B,KAAK,SAAChK,GACjB,OAAOA,EAAK4J,OAASA,GAAQ5J,EAAK+D,OAASA,CAC/C,EAEJ,GAEA,CAAAlD,IAAA,iBAAAC,MAWA,SAAe8I,EAAM7F,GACjB,OAAOkB,QAAQ/E,KAAK+J,eAAeL,EAAM7F,GAC7C,GAEA,CAAAlD,IAAA,YAAAC,MAMA,WAEI,IAAA8F,EAQI1G,KAAKF,KAPL+D,EAAI6C,EAAJ7C,KACAyC,EAAKI,EAALJ,MAAK0D,EAAAtD,EACLwB,UAAAA,OAAS,IAAA8B,EAAG,GAAEA,EAAAC,EAAAvD,EACdwD,gBAAAA,OAAe,IAAAD,EAAG,GAAEA,EACpBnC,EAAUpB,EAAVoB,WACAE,EAAUtB,EAAVsB,WACA9H,EAAKwG,EAALxG,MAGJ,OAAOF,KAAKG,YAAYwG,UAAUC,MAAMrB,KAAK,CACzC,yBAAwB,SAAC3C,GAErBA,EAAQqE,UAAUC,OAAO,mBAAoBhH,GAC7C0C,EAAQqE,UAAUC,OAAO,oBAAqBY,GAC9ClF,EAAQqE,UAAUC,OAAO,qBAAsBc,GAC/C,IAAMmC,EAAMjC,EAAU2B,OAASK,EAAgBL,OAC/CjH,EAAQqE,UAAUC,OAAO,kBAAD1F,OAAmB2I,GAAOA,EAEtD,EACA,wBAAuB,SAACvH,GACpBA,EAAQ+C,IAAMW,CAClB,EACA,uBAAsB,SAAC1D,GACnBA,EAAQ6C,YAAc5B,CAC1B,GAGR,GAEA,CAAAlD,IAAA,WAAAC,MAMA,WAAW,IAAAwJ,EAAA,KAGH5E,EACAxF,KAAKF,KADL0F,GAGJ,OAAOxF,KAAKG,YAAYwG,UAAUG,KAAKvB,KAAK,CACxC,8BAA6B,SAAC3C,GAC1BA,EAAQmE,QAAQsD,QAAU7E,CAC9B,EACA,6BAA8B,SAAC5C,GAC3BA,EAAQuE,OAAOiD,EAAKhD,YACxB,GAGR,GAEA,CAAAzG,IAAA,aAAAC,MAOA,WAEI,IAAAiG,EAMI7G,KAAKF,KALL0F,EAAEqB,EAAFrB,GACA3B,EAAIgD,EAAJhD,KACAyC,EAAKO,EAALP,MACA6B,EAAOtB,EAAPsB,QACAjI,EAAK2G,EAAL3G,MAGJ,OAAOF,KAAKG,YAAYwG,UAAU2D,OAAO/E,KAAK,CAC1C,+BAA8B,SAAC3C,GAC3BA,EAAQ+C,IAAMW,CAClB,EACA,8BAA6B,SAAC1D,GAE1BA,EAAQ6C,YAAc5B,EACtBjB,EAAQqE,UAAUC,OAAO,WAAYhH,EAEzC,EACA,iCAAgC,SAAC0C,GAC7BA,EAAQ6C,YAAc0C,CAC1B,EACA,+BAA8B,SAACvF,GAE3BA,EAAQhC,MAAQ4E,EAChB5C,EAAQ2H,QAAQ,SAASC,SAAUzI,EAAAA,EAAAA,IAASa,EAEhD,EACA,+BAA8B,SAACA,GAE3BA,EAAQiB,MAAQ2B,EAChB5C,EAAQmE,QAAO,IAAOvB,CAE1B,GAGR,GAEA,CAAA7E,IAAA,iBAAAC,MASA,WAA+B,IAAhB6J,IAAOvE,UAAA2D,OAAA,QAAApF,IAAAyB,UAAA,KAAAA,UAAA,GAElBwE,EAQI1K,KAAKF,KAPL0F,EAAEkF,EAAFlF,GACA3B,EAAI6G,EAAJ7G,KACAyC,EAAKoE,EAALpE,MACAwB,EAAU4C,EAAV5C,WACAC,EAAkB2C,EAAlB3C,mBACAC,EAAU0C,EAAV1C,WACAC,EAAkByC,EAAlBzC,mBAGJ,OAAOjI,KAAKG,YAAYwG,UAAUgE,WAAWpF,KAAK,CAC9C,2BAA0B,SAAC3C,GAEvBA,EAAQmE,QAAQvB,GAAKA,EACrB5C,EAAQmE,QAAQ6D,MACZH,EACE3C,EACAE,CAGV,EACA,wBAAuB,SAACpF,GACpBA,EAAQ+C,IAAMW,CAClB,EACA,wBAAuB,SAAC1D,GACpBA,EAAQ6C,YAAc5B,CAC1B,EACA,2BAA0B,SAACjB,GAEvBA,EAAQ6C,YACJgF,EACE1C,EACAE,CAGV,GAGR,IAAC,EAAAtH,IAAA,QAAAN,IArkBD,WACI,OAAOmH,CACX,GAEA,CAAA7G,IAAA,SAAAN,IAKA,WACI,OAAOqH,CACX,GAEA,CAAA/G,IAAA,eAAAC,MAMA,SAAoB+F,GAMhB3G,KAAK2G,UAAYA,CAErB,IAAC,CAlC8B,CAAS9G,GCiErC,SAASgL,EAAUC,GACtB,OAAOC,OAAOD,GAAQhK,QAAQ,gBAAiB,GACnD,CAUO,SAASkK,EAAcF,GAC1B,OAAOA,EAAOhK,QAAQ,mBAAoB,sBAC9C,CAYO,SAASmK,EAASpJ,EAAUqJ,GAE/B,OAAOrJ,EAASf,QAAQ,gBAAiB,SAACqK,EAAOC,GAAK,OAClDlK,OAAOC,UAAUC,eAAeC,KAAK6J,EAAcE,GACjDF,EAAaE,GACbD,CAAK,EAGf,C,miCCxGA,IAGqBE,GAAS,WAyH1B,O,4GAAAtI,CAVA,SAAAsI,EAAYvL,I,4FAAMC,CAAA,KAAAsL,GAMdrL,KAAKF,KAAOE,KAAKG,YAAYmL,UAAUxL,EAE3C,EAEA,EAAAa,IAAA,OAAAC,MAGA,WAEIZ,KAAKuL,cACLvL,KAAKwL,YAET,GAEA,CAAA7K,IAAA,cAAAC,MAGA,WAEI,IAAA8F,EAKI1G,KAAKF,KAJLuG,EAAIK,EAAJL,KACAb,EAAEkB,EAAFlB,GACAiG,EAAM/E,EAAN+E,OACAC,EAAMhF,EAANgF,OAEJC,EAGI3L,KAAKG,YAFLyL,EAAOD,EAAPC,QACAjF,EAASgF,EAAThF,UAEEkF,EAASD,EACXF,EACE,SACA,UAGAhH,EAAUiC,EAAUmF,OAAOvG,KAAK,CAClC,0BAAyB,SAAC3C,GAEtBA,EAAQ6C,YAAcY,EACtBzD,EAAQmJ,MAAMC,YAAY,cAAeP,GACzC7I,EAAQmE,QAAQkF,OAAS,IAAHzK,OAAOgE,EAEjC,IAGJqG,EAAO1E,OAAOzC,GAOd1E,KAAK0E,QAAUmH,EAAOK,gBAE1B,GAEA,CAAAvL,IAAA,aAAAC,MAGA,WAEI,IAAAiG,EAKI7G,KAAKF,KAJLqM,EAAMtF,EAANsF,OACA3G,EAAEqB,EAAFrB,GACAiG,EAAM5E,EAAN4E,OACAC,EAAM7E,EAAN6E,OAEJU,EAGIpM,KAAKG,YAFLyL,EAAOQ,EAAPR,QACAjF,EAASyF,EAATzF,UAEEkF,EAASD,EAAQK,OAEjBA,EAAStF,EAAUsF,OAAO1G,KAAK,CACjC,0BAAyB,SAAC3C,GAEtBA,EAAQ4C,GAAKA,EACb5C,EAAQmJ,MAAMC,YAAY,WAAYP,EAE1C,EACA,+BAA8B,SAAC7I,GAC3BA,EAAQyJ,UAAYF,CACxB,EACA,2BAA0B,SAACvJ,GACvBA,EAAQ0J,QAAUZ,CACtB,IAGJG,EAAO1E,OAAO8E,GAMdjM,KAAKiM,OAASJ,EAAOK,gBAEzB,GAEA,CAAAvL,IAAA,UAAAC,MAMA,WAEI,O,2VAAAwF,CAAA,GACOpG,KAAKF,KAGhB,GAEA,CAAAa,IAAA,SAAAC,MAMA,WACI,OAAOZ,KAAKF,KAAKyM,GACrB,GAEA,CAAA5L,IAAA,aAAAC,MAMA,WACI,OAAOZ,KAAK0E,OAChB,GAEA,CAAA/D,IAAA,YAAAC,MAMA,WACI,OAAOZ,KAAKiM,MAChB,GAEA,CAAAtL,IAAA,YAAAC,MAMA,SAAU2L,GAEN,IACIzM,EAGAE,KAHAF,KACAmM,EAEAjM,KAFAiM,OACAvH,EACA1E,KADA0E,QAGEyH,EAASnB,EAAcuB,GACvBlG,EAAOwE,EAAUsB,GAEvBrM,EAAKyM,IAAMA,EACXzM,EAAKuG,KAAOA,GACZmG,EAAAA,EAAAA,IAAU,0BAA2B9H,GAASe,YAAcY,EAC5DvG,EAAKqM,OAASA,GACdK,EAAAA,EAAAA,IAAU,+BAAgCP,GAAQI,UAAYF,CAElE,GAEA,CAAAxL,IAAA,SAAAC,MAGA,WAEIZ,KAAKiM,OAAOQ,SACZzM,KAAK0E,QAAQ+H,QAEjB,IAAC,EAAA9L,IAAA,YAAAN,IA9RD,WACI,MAAO,aACX,GAEA,CAAAM,IAAA,eAAAC,MAMA,SAAoB+F,GAMhB3G,KAAK2G,UAAYA,CAErB,GAEA,CAAAhG,IAAA,aAAAC,MAMA,SAAkBgL,GAMd5L,KAAK4L,QAAUA,CAEnB,GAEA,CAAAjL,IAAA,SAAAC,MAQA,SAAcyF,GAEV,IAAMqG,EAAQrG,EAAKvF,QAAQ,MAAO,IAAIE,cAEtC,OAAOe,EAAAA,EAAAA,IAAS,CAAC,EAAG,GAAFP,OAAKxB,KAAK2M,WAASnL,OAAGkL,EAAK,KAEjD,GAEA,CAAA/L,IAAA,YAAAC,MAoBA,SAAgB0B,GAAsC,IAAnCiK,EAAGjK,EAAHiK,IAAKJ,EAAM7J,EAAN6J,OAAQ3G,EAAElD,EAAFkD,GAAIiG,EAAMnJ,EAANmJ,OAAQC,EAAMpJ,EAANoJ,OAEpCa,IAAQJ,IACRA,EAASnB,EAAcuB,IAG3B,IAAMlG,EAAOwE,EAAUsB,GAElB3G,IACDA,EAAKxF,KAAK4M,OAAOvG,IAGrB,IAAMwG,EAAS7M,KAAK2M,UAMpB,OAJKnH,EAAGhF,WAAWqM,KACfrH,EAAK,GAAHhE,OAAMqL,GAAMrL,OAAGgE,IAGd,CACH+G,IAAAA,EACAlG,KAAAA,EACA8F,OAAAA,EACA3G,GAAAA,EACAiG,OAAQ,SAAFjK,OAAWiK,GAAU,OAAM,KACjCC,OAAQ3G,QAAQ2G,GAGxB,IAAC,CAzGyB,G,yOCJvB,SAASoB,GAAUC,GACtB,OAAOtL,KAAKC,MAAMD,KAAKE,UAAUoL,GACrC,CAUO,SAASC,GAAWD,GAMvB,OAJIA,GAA4B,WAAlBE,GAAOF,IACjB7L,OAAOgM,OAAOH,GAAQ1K,QAAQ,SAAC8K,GAAI,OAAKH,GAAWG,EAAK,GAGrDjM,OAAOkM,OAAOL,EAEzB,CAQO,SAASM,GAAMN,GAClB7L,OAAOoM,KAAKP,GAAQ1K,QAAQ,SAAC1B,GAAG,cAAYoM,EAAOpM,EAAI,EAC3D,C,g5EC1BA,IAGqB4M,GAAK,WAyFrB,O,4GAAAxK,CAhCD,SAAAwK,EAAY5M,I,4FAAKZ,CAAA,KAAAwN,GAMbvN,KAAKW,IAAMA,EAMXX,KAAKF,KAAOE,KAAKwN,OAMjBxN,KAAKyN,OAAS,GAMdzN,KAAK0N,WAAa,GAMlB1N,KAAKsE,SAAW,IAAIxB,CAExB,EAAC,EAAAnC,IAAA,cAAAC,MAED,SAAY+M,GACR3N,KAAKsE,SAASsJ,GAAG,UAAWD,EAChC,GAEA,CAAAhN,IAAA,QAAAC,MAGA,WACIiN,OAAOC,aAAaC,QAAQ/N,KAAKW,IAAKc,KAAKE,UAAU3B,KAAKF,OAC1DE,KAAKsE,SAASI,QAAQ,UAAW1E,KAAKK,MAC1C,GAEA,CAAAM,IAAA,OAAAC,MAMA,WAEI,OAAAwF,GAAAA,GAAA,GACO0G,GAAU9M,KAAKG,YAAY6N,WAC1BvM,KAAKC,MAAMmM,OAAOC,aAAaG,QAAQjO,KAAKW,OAAS,CAAC,EAGlE,GAEA,CAAAA,IAAA,SAAAC,MAOA,SAAOD,GAEH,IACIqN,EACAhO,KAAKG,YADL6N,SAGC9M,OAAOC,UAAUC,eAAeC,KAAK2M,EAAUrN,KAIpDX,KAAKF,KAAKa,GAAOmM,GAAUkB,EAASrN,IAExB,WAARA,IAEAX,KAAKyN,OAAO5D,OAAS,EACrB7J,KAAKF,KAAKoO,OAASpB,GAAUkB,EAASE,SAI9B,gBAARvN,IACAX,KAAK0N,WAAW7D,OAAS,GAG7B7J,KAAKmO,QAET,GAEA,CAAAxN,IAAA,YAAAC,MAGA,WAAY,IAAAyE,EAAA,KAERnE,OACKoM,KAAKtN,KAAKG,YAAY6N,UACtB3L,QAAQ,SAAC1B,GAAG,OAAK0E,EAAI,OAAQ1E,EAAI,EAE1C,GAEA,CAAAA,IAAA,MAAAC,MAMA,WACI,OAAOoM,GAAWF,GAAU9M,KAAKF,MACrC,GAEA,CAAAa,IAAA,YAAAC,MAQA,SAAUwN,GACN,OAAOpO,KAAKF,KAAK6C,OAAOyL,EAC5B,GAEA,CAAAzN,IAAA,YAAAC,MAQA,SAAUwN,EAAKC,GAEXrO,KAAKF,KAAK6C,OAAOyL,GAAOC,EACxBrO,KAAKmO,OAET,GAEA,CAAAxN,IAAA,gBAAAC,MAWA,SAAciD,EAAMsF,EAAYmF,GAE5B,IAAMxO,EAAO,CACTqJ,WAAAA,GAGAtF,IACA/D,EAAK+D,KAAOA,GAGZyK,IACAxO,EAAKwO,KAAOA,GAGhBtO,KAAKF,KAAKqJ,WAAarJ,EACvBE,KAAKmO,OAET,GAEA,CAAAxN,IAAA,WAAAC,MAMA,SAASgG,GAEL,IACI9G,EAEAE,KAFAF,KACA2N,EACAzN,KADAyN,OAEErC,EAAQqC,EAAO5D,OAQrB,OANA4D,EAAOlG,KAAKX,GACZ9G,EAAK2N,OAAOrC,GAAS,CACjB5F,GAAIoB,EAAMxB,SAEdpF,KAAKmO,QAEE/C,CAEX,GAEA,CAAAzK,IAAA,cAAAC,MAMA,SAAYgG,GAER,IACI9G,EAEAE,KAFAF,KACA2N,EACAzN,KADAyN,OAEErC,EAAQqC,EAAOc,QAAQ3H,GAEzBwE,EAAQ,IAIZtL,EAAK2N,OAAOe,OAAOpD,EAAO,GAC1BqC,EAAOe,OAAOpD,EAAO,GACrBpL,KAAKmO,QAET,GAEA,CAAAxN,IAAA,YAAAC,MAYA,SAAUgG,EAAO6H,EAAMtE,EAAKuE,GAExB,IACI5O,EAEAE,KAFAF,KAGAsL,EADApL,KADAyN,OAEec,QAAQ3H,GAEvBwE,EAAQ,IACRA,EAAQpL,KAAK2O,SAAS/H,IAG1B1F,OAAO0N,OAAO9O,EAAK2N,OAAOrC,GAAQ,CAC9BqD,KAAAA,EACAtE,IAAAA,EACAuE,OAAAA,IAEJ1O,KAAKmO,OAET,GAEA,CAAAxN,IAAA,aAAAC,MAQA,SAAWgG,EAAO8H,GAEd,IACI5O,EAEAE,KAFAF,KAGAsL,EADApL,KADAyN,OAEec,QAAQ3H,GAEvBwE,EAAQ,IACRA,EAAQpL,KAAK2O,SAAS/H,IAG1B9G,EAAK2N,OAAOrC,GAAOsD,OAASA,EAC5B1O,KAAKmO,OAET,GAEA,CAAAxN,IAAA,aAAAC,MAQA,SAAWgG,EAAOyB,GAEd,IACIvI,EAEAE,KAFAF,KAGAsL,EADApL,KADAyN,OAEec,QAAQ3H,GAEvBwE,EAAQ,IAIZtL,EAAK2N,OAAOrC,GAAO/C,OAASA,EAExBA,EACArI,KAAK6O,aAAajI,GAAO,GAEzB5G,KAAKmO,QAGb,GAEA,CAAAxN,IAAA,SAAAC,MAQA,SAAOgG,EAAO0B,GAEV,IACIxI,EAEAE,KAFAF,KAGAsL,EADApL,KADAyN,OAEec,QAAQ3H,GAEvBwE,EAAQ,IAIZtL,EAAK2N,OAAOrC,GAAO9C,aAAeA,EAClCtI,KAAKmO,QAET,GAEA,CAAAxN,IAAA,gBAAAC,MAQA,SAAcgG,EAAO/C,GAEjB,IACI/D,EAEAE,KAFAF,KAGEsL,EADFpL,KADAyN,OAEiBc,QAAQ3H,GAEzBwE,EAAQ,IAIZtL,EAAK2N,OAAOrC,GAAO0D,WAAajL,EAE3B/D,EAAKiP,MAAMC,SAASnL,IACrB/D,EAAKiP,MAAMxH,KAAK1D,GAGpB7D,KAAKmO,QAET,GAEA,CAAAxN,IAAA,eAAAC,MAQA,SAAagG,EAAO2B,GAEhB,IACIzI,EAEAE,KAFAF,KAGEsL,EADFpL,KADAyN,OAEiBc,QAAQ3H,GAEzBwE,EAAQ,IAIZtL,EAAK2N,OAAOrC,GAAO6D,UAAY1G,EAC/BvI,KAAKmO,QAET,GAEA,CAAAxN,IAAA,YAAAC,MAMA,SAAUsO,GAEN,IAAA5M,EAOK4M,GAAS,CAAC,EANXrL,EAAIvB,EAAJuB,KACAsL,EAAI7M,EAAJ6M,KACAzF,EAAIpH,EAAJoH,KACA9I,EAAK0B,EAAL1B,MACAwO,EAAO9M,EAAP8M,QACAC,EAAQ/M,EAAR+M,SAGJ,GAAKxL,GAAiB,SAAT6F,EAAb,CAIA,IAAIjH,EAAW,GAAHjB,OAAM6N,EAASrO,cAAa,WAAAQ,OAAUqC,EAAI,MAChDyL,EAAsB,aAAT5F,EAEf4F,GAAcJ,EAAMK,aAAa,WACjC9M,GAAY,WAAJjB,OAAeZ,EAAK,OAGhC,IAAM4O,EAASL,aAAI,EAAJA,EAAM3J,GACjBgK,IACA/M,EAAW,IAAHjB,OAAOgO,EAAM,KAAAhO,OAAIiB,IAG7BzC,KAAKF,KAAK2P,OAAOhN,GACb6M,EACEF,EACAxO,EAENZ,KAAKmO,OAnBL,CAqBJ,GAEA,CAAAxN,IAAA,oBAAAC,MAKA,WAEI,IACId,EACAE,KADAF,KAGJA,EAAK2P,OAASvO,OAAOwO,YACjBxO,OACKkB,QAAQtC,EAAK2P,QACblG,OAAO,SAAAhH,GAAA,IAAEE,EAAFD,GAAAD,EAAA,GAAU,UAAMI,EAAAA,EAAAA,IAAOF,GAAUoH,MAAM,IAEvD7J,KAAKmO,OAET,GAEA,CAAAxN,IAAA,cAAAC,MAOA,SAAY+O,GAER,IAAAC,EAGID,GAAW,CAAC,EAFZnK,EAAEoK,EAAFpK,GACAqK,EAAID,EAAJC,KAGCrK,IAILxF,KAAKF,KAAK6P,QAAQ,IAADnO,OAAKgE,IAAQqK,EAC9B7P,KAAKmO,QAET,GAEA,CAAAxN,IAAA,gBAAAC,MAMA,SAAckP,EAAW1E,GAErB,IACIsC,EAEA1N,KAFA0N,WACA5N,EACAE,KADAF,KAGA4N,EAAWsB,SAASc,KAIH,iBAAV1E,EACPsC,EAAWtC,GAAS0E,GAEpBpC,EAAWnG,KAAKuI,GAChBhQ,EAAK4N,WAAWnG,KAAKuI,EAAUC,WAGnC/P,KAAKmO,QAET,GAEA,CAAAxN,IAAA,kBAAAC,MAOA,SAAgBkP,GAEZ,IAAM1E,EAAQpL,KAAK0N,WAAWa,QAAQuB,GAElC1E,GAAS,IAETpL,KAAKF,KAAK4N,WAAWtC,GAAS0E,EAAUC,SACxC/P,KAAKmO,QAIb,GAEA,CAAAxN,IAAA,kBAAAC,MAOA,SAAgBkP,GAEZ,IACIpC,EAEA1N,KAFA0N,WACA5N,EACAE,KADAF,KAEEsL,EAAQsC,EAAWa,QAAQuB,GAE7B1E,GAAS,IAETsC,EAAWc,OAAOpD,EAAO,GACzBtL,EAAK4N,WAAWc,OAAOpD,EAAO,GAC9BpL,KAAKmO,QAIb,GAEA,CAAAxN,IAAA,YAAAC,MAMA,SAAUoP,GAENhQ,KAAKF,KAAKkQ,OAASA,EACnBhQ,KAAKmO,OAET,GAEA,CAAAxN,IAAA,YAAAC,MAOA,SAAUsN,GAENlO,KAAKF,KAAKoO,OAASA,EACnBlO,KAAKmO,OAET,GAEA,CAAAxN,IAAA,aAAAC,MAMA,SAAWqP,GAEPjQ,KAAKF,KAAKmQ,QAAUA,EACpBjQ,KAAKmO,OAET,GAEA,CAAAxN,IAAA,aAAAC,MAMA,WACI,OAAOZ,KAAKF,KAAKmQ,OACrB,GAEA,CAAAtP,IAAA,UAAAC,MAOA,SAAQsP,GAEJlQ,KAAKF,KAAKoQ,KAAOA,EACjBlQ,KAAKmO,OAET,GAEA,CAAAxN,IAAA,UAAAC,MAMA,WACI,OAAOZ,KAAKF,KAAKoQ,IACrB,IAAC,EAAAvP,IAAA,SAAAC,MAhoBD,SAAcD,GAEV,IACImB,EACA9B,KADA8B,MAOJ,OAJKA,EAAMnB,KACPmB,EAAMnB,GAAO,IAAIX,KAAKW,IAGnBmB,EAAMnB,EAEjB,IAAC,CAhDqB,G,2iCAEtBoD,GAFiBwJ,GAAK,WAMJ,CACd5K,OAAQ,CAAC,EACTwG,WAAY,CAAC,EACb+E,OAAQ,CAAC,EACTT,OAAQ,GACRgC,OAAQ,CAAC,EACTE,QAAS,CAAC,EACVjC,WAAY,GACZqB,MAAO,GACPiB,OAAQ,GACRC,QAAS,GACTC,KAAM,KAGVnM,GApBiBwJ,GAAK,QAwBPrM,OAAO2B,OAAO,OChCjC,ICCQsN,GACAC,GAEEC,GDAWC,GAAU,WAiK3B,O,4GAAAvN,CAzDA,SAAAuN,EAAAhO,GAIG,IAAA+C,EAAA,KAHC8D,EAAU7G,EAAV6G,WACAjB,EAAS5F,EAAT4F,UACAM,EAAMlG,EAANkG,Q,4FAAMzI,CAAA,KAAAuQ,GAONtQ,KAAKmJ,WAAajI,OAAO2B,OAAO,MAMhC7C,KAAKkI,UAAYhH,OAAO2B,OAAO,MAE/BsG,EAAW9G,QAAQ,SAAC2C,GAAS,OAAKK,EAAKkL,gBAAgBvL,EAAU,GACjEkD,SAAAA,EAAW7F,QAAQ,SAACgF,EAAU+D,GAC1BrF,EAAcyK,UAAUnL,EAAKoL,eAAepJ,EAAU+D,GAC1D,GAMApL,KAAKwI,OAAS,GAGdA,EAAOnG,QAAQ,SAAAE,GAAkB,IAAfiD,EAAEjD,EAAFiD,GAAIb,EAAIpC,EAAJoC,KAEZK,EAAYK,EAAKqL,aAAalL,GAE/BR,GAILL,EAAKtC,QAAQ,SAAC4B,GAEV,IAAM0M,EAAiBtL,EAAKqL,aAAazM,EAAMuB,IAE/C,GAAKmL,EAAL,CAIA,IAAMC,EAAU,IAAI5M,EAAK2M,EAAgB1M,EAAMC,QAE/Cc,EAAU6D,QAAQ+H,GAClBvL,EAAKmD,OAAOjB,KAAKqJ,EALjB,CAOJ,EAEJ,EAEJ,EAEA,EAAAjQ,IAAA,kBAAAC,MASA,SAAgBd,GAAM,IAAAsK,EAAA,KAGdvG,EAIA/D,EAJA+D,KACAyC,EAGAxG,EAHAwG,MAAKuK,EAGL/Q,EAFAoI,UAAAA,OAAS,IAAA2I,EAAG,GAAEA,EAAAC,EAEdhR,EADAoK,gBAAAA,OAAe,IAAA4G,EAAG,GAAEA,EAElBtL,EAAKxF,KAAKG,YAAY4Q,YAAYjR,EAAK0F,IACvCR,EAAY,IAAI2C,EAAe7H,GAoBrC,OAlBAoI,EACK1G,OAAO0I,GACP7H,QAAQ,SAACgE,EAAM+E,GAEZpG,EAAU2D,YACNyB,EAAKqG,eAAe,CAChBjL,GAAAA,EACA3B,KAAAA,EACAyC,MAAAA,EACAD,KAAAA,EACAI,SAAUyD,EAAgB8E,SAAS3I,IACpC+E,GAGX,GAEJpL,KAAKmJ,WAAW3D,GAAMR,EAEfA,CAEX,GAEA,CAAArE,IAAA,wBAAAC,MAUA,SAAsBd,GAElB,OAAOE,KAAKuQ,gB,8VAAenK,CAAArC,GAAC,CAAC,EACxB4D,EAAe+D,QAAS,GACtB5L,GAGX,GAEA,CAAAa,IAAA,iBAAAC,MAYA,SAAed,EAAMsL,GAEjB,IACIvH,EAIA/D,EAJA+D,KACAwC,EAGAvG,EAHAuG,KACAC,EAEAxG,EAFAwG,MACAG,EACA3G,EADA2G,SAEEjB,EAAKxF,KAAKG,YAAY4Q,YAAYjR,EAAK0F,IACvCwB,EAAa,GAAAxF,OAAGgE,EAAE,KAAAhE,OAAI4J,GAAQpK,cAAcF,QAAQ,OAAQ,KAC5DuG,EAAW,IAAItB,EAAc,CAC/BM,KAAAA,EACAC,MAAAA,EACAG,SAAAA,EACAjB,GAAIwB,EACJT,YAAaf,EACbgB,cAAe3C,IAKnB,OAFA7D,KAAKkI,UAAUlB,GAAcK,EAEtBA,CAEX,GAEA,CAAA1G,IAAA,eAAAC,MAQA,SAAa4E,GACT,OAAOxF,KAAKmJ,WAAWnJ,KAAKG,YAAY4Q,YAAYvL,GACxD,GAEA,CAAA7E,IAAA,uBAAAC,MAUA,SAAqB4E,GAEjB,IAAMR,EAAYhF,KAAK0Q,aAAalL,GAEpC,GAAIR,UAAAA,EAAWgM,WAIf,OAAOhM,CAEX,GAEA,CAAArE,IAAA,oBAAAC,MAUA,SAAkB4E,GAEd,IAAMR,EAAYhF,KAAK0Q,aAAalL,GAEpC,IAAKR,EACD,MAAM,IAAIzD,eAAe,mBAADC,OAAoBgE,EAAE,gBAGlD,OAAOR,EAAU/C,OAErB,GAEA,CAAAtB,IAAA,mBAAAC,MAMA,WACI,OAAOM,OAAOgM,OAAOlN,KAAKmJ,WAC9B,GAEA,CAAAxI,IAAA,oBAAAC,MAMA,WACI,OAAOZ,KAAKiR,kBAAkBjR,KAAKG,YAAY+Q,MACnD,GAEA,CAAAvQ,IAAA,cAAAC,MAQA,SAAY4E,GACR,OAAOxF,KAAKkI,UAAU1C,EAC1B,GAEA,CAAA7E,IAAA,mBAAAC,MAUA,SAAiB4E,GAEb,IAAM6B,EAAWrH,KAAKmR,YAAY3L,GAElC,IAAK6B,EACD,MAAM,IAAI9F,eAAe,uBAADC,OAAwBgE,EAAE,eAGtD,OAAO6B,EAASpF,OAEpB,GAEA,CAAAtB,IAAA,kBAAAC,MAMA,WACI,OAAOM,OAAOgM,OAAOlN,KAAKkI,UAC9B,GAEA,CAAAvH,IAAA,eAAAC,MAMA,WACI,OAAOZ,KAAKwI,MAChB,GAEA,CAAA7H,IAAA,UAAAC,MAMA,SAAQ+D,GACJ3E,KAAKwI,OAAOjB,KAAK5C,EACrB,GAEA,CAAAhE,IAAA,uBAAAC,MAMA,WACI,OAAOZ,KAAKwI,OAAOe,OAAO,SAAC5E,GAAI,OAAKA,EAAKyM,eAAe,EAC5D,GAEA,CAAAzQ,IAAA,0BAAAC,MAGA,WACIZ,KAAKwI,OAASxI,KAAKwI,OAAOe,OAAO,SAAC5E,GAAI,OAAMA,EAAKyM,eAAe,EACpE,IAAC,EAAAzQ,IAAA,QAAAN,IAxZD,WACI,MAAO,EACX,GAEA,CAAAM,IAAA,SAAAC,MAeA,SAAcd,GACV,OAAOE,KAAKqQ,QAAQgB,QAAQ,IAAIrR,KAAKF,GACzC,GAEA,CAAAa,IAAA,MAAAC,MAMA,WACI,OAAOZ,KAAKqQ,OAChB,GAEA,CAAA1P,IAAA,gBAAAC,MASA,SAAqB4E,GACjB,OAAQxF,KAAKsR,aAAa9L,EAC9B,GAEA,CAAA7E,IAAA,eAAAC,MASA,SAAoB4E,GAChB,MAAQ,QAAS+L,KAAK/L,EAC1B,GAEA,CAAA7E,IAAA,cAAAC,MAWA,SAAmB4E,GACf,OAAOA,EAAG1E,QAAQ,QAAS,IAAIE,aACnC,GAEA,CAAAL,IAAA,QAAAC,MAUA,SAAawC,GACT,OAAOpD,KAAKK,MAAMmR,KAAKpO,EAC3B,IAAC,CA5F0B,GA4F1BW,GA5FgBuM,GAAU,WCHvBH,GAAM,WAAO,EACbC,GAAM,WAAO,GAEXC,GAAU,IAAIoB,QAAQ,SAACJ,EAASK,GAClCvB,GAAMkB,EACNjB,GAAMsB,CACV,IAEQL,QAAU,SAACzQ,GAEf,OADAuP,GAAIvP,GACGyP,EACX,EAEAA,GAAQqB,OAAS,SAACxN,GAEd,OADAkM,GAAIlM,GACGmM,EACX,EAEOA,K,eCrBEsB,GAAW1O,SAAS2O,gBAAgBC,MAAQ,Q,k7CCAzD,IAGqBC,GAAK,WAyCtB,O,4GAAA/O,CAXA,SAAA+O,K,4FAAc/R,CAAA,KAAA+R,GAOV9R,KAAK+O,MAAQ,EAEjB,EAEA,EAAApO,IAAA,cAAAC,MAOA,SAAYiB,GAQR,OAFA7B,KAAK6B,SAAWA,EAET7B,IAEX,GAEA,CAAAW,IAAA,cAAAC,MAOA,SAAY0D,GAQR,OAFAtE,KAAKsE,SAAWA,EAETtE,IAEX,GAEA,CAAAW,IAAA,MAAAC,MAOA,SAAIiD,GAEA,IACIkL,EAEA/O,KAFA+O,MACAzK,EACAtE,KADAsE,SAIAyK,EADAlF,OAGAhG,IAASkL,EAAMC,SAASnL,KAExBkL,EAAMxH,KAAK1D,GACX7D,KAAK+R,cACLzN,EAASI,QAAQ,cAAe,CAAEb,KAAAA,EAAMkL,MAAKiD,GAAMjD,KAI3D,GAEA,CAAApO,IAAA,cAAAC,MAIA,WACIZ,KAAK+O,MAAMkD,KAAK,SAACC,EAAGC,GAAC,OAAKD,EAAEE,cAAcD,EAAGR,GAAS,EAC1D,GAEA,CAAAhR,IAAA,QAAAC,MAGA,WAEIZ,KAAK+O,MAAMlF,OAAS,EACpBvF,SAASI,QAAQ,gBAErB,GAgBA,CAAA/D,IAAA,WAAAC,MAQA,WAMQZ,KAHAG,YADJ,IAEI4O,EAEA/O,KAFA+O,MACAlN,EACA7B,KADA6B,SAGJ,IAAKA,EACD,MAAM,IAAIwQ,MAAM,sDAGpB,OAAOtD,EAAMuD,IAAI,SAACzO,GAAI,OAAKhC,EAAS0D,KAAK,CACrC,2BAA0B,SAAC3C,GACvBA,EAAQhC,MAAQiD,CACpB,GACF,EAEN,GAEA,CAAAlD,IAAA,KAAAC,MAQA,SAAGuC,EAAWC,GACVpD,KAAKsE,SAASsJ,GAAGzK,EAAWC,EAChC,IAAC,EAAAzC,IAAA,SAAAC,MAtKD,WAaI,OAXKZ,KAAKuS,WAONvS,KAAKuS,SAAW,IAAIvS,MAIjBA,KAAKuS,QAEhB,IAAC,CAzBqB,GCOnB,SAASC,GAAe7R,EAAKyN,EAAKqE,GAErC,IAAMpE,EAAUoE,EAAMC,UAAU/R,GAEhC,YAAgB8D,IAAZ4J,EACOoD,QAAQJ,QAAQhD,GAGpBsE,MAAMvE,GACRoD,KAAK,SAACoB,GAAQ,OAAKA,EAASC,MAAM,GAClCrB,KAAK,SAACqB,GAGH,OADAJ,EAAMK,UAAUnS,EAAKkS,GACdA,CAEX,EAER,C,qhECZA,IAAMJ,GAAQlF,GAAM1K,OAAO,mBACrBkQ,GAAejQ,EAASD,OAAO,QAgHrC,SAASmQ,GAAc9D,GAEnB,IACI+D,EAGA/D,EAHA+D,IACAC,EAEAhE,EAFAgE,IACAtS,EACAsO,EADAtO,MAGJsO,EAAMnD,MAAMC,YACR,SACiB,KAAfpL,EAAQqS,IAAeC,EAAMD,GAGvC,CA3HAT,GAAe,cAADhR,OAAemQ,IAAYwB,KAAKhK,WAAYsJ,IAAOjB,KAAK,SAACrI,GACnE4J,GAAarO,QAAQ,oBAAqB,CAAEyE,WAAAA,GAChD,GAEAqJ,GAAe,UAADhR,OAAWmQ,IAAYwB,KAAK3K,OAAQiK,IAAOjB,KAAK,SAAChJ,GAC3DuK,GAAarO,QAAQ,gBAAiB,CAAE8D,OAAAA,GAC5C,GAEAgK,GAAe,OAAQW,KAAK7E,KAAMmE,IAAOjB,KAAK,SAAC4B,GAC3CL,GAAarO,QAAQ,wBAAyB,CAAE0O,UAAAA,GACpD,GAEAzL,EAAe0L,aAAa,CACxBzM,MAAOhF,EAASiB,QAAO2J,EAAAA,EAAAA,IAAU,wBACjC1F,KAAMlF,EAASiB,QAAO2J,EAAAA,EAAAA,IAAU,6BAChClC,OAAQ1I,EAASiB,QAAO2J,EAAAA,EAAAA,IAAU,+BAClC7B,WAAY/I,EAASiB,QAAO2J,EAAAA,EAAAA,IAAU,2BAE1CzG,EAAcsN,aAAa,CACvBzM,MAAOhF,EAASiB,QAAO2J,EAAAA,EAAAA,IAAU,uBACjC1F,KAAMlF,EAASiB,QAAO2J,EAAAA,EAAAA,IAAU,8BAEpCsF,GAAMjP,SACDyQ,YAAY1R,EAASiB,QAAO2J,EAAAA,EAAAA,IAAU,2BACtC+G,YAAY,IAAIzQ,GAErB2O,QAAQ+B,IAAI,CACR,IAAI/B,QAAQ,SAACJ,GACT0B,GAAanF,GAAG,oBAAqB,SAAAtL,GAAgB,IAAbiB,EAAMjB,EAANiB,OACpC8N,EAAQ9N,EAAO4F,WACnB,EACJ,GACA,IAAIsI,QAAQ,SAACJ,GACT0B,GAAanF,GAAG,gBAAiB,SAAArL,GAAgB,IAAbgB,EAAMhB,EAANgB,OAChC8N,EAAQ9N,EAAOiF,OACnB,EACJ,KACDgJ,KAAK,SAAAiC,GAA4B,IAAA7D,EAAApN,GAAAiR,EAAA,GAAzBtK,EAAUyG,EAAA,GAAEpH,EAAMoH,EAAA,GAEzBU,GAAWzN,OAAO,CACdsG,WAAY,CACRpF,GAAA,CAEIyB,GAAI8K,GAAWY,MACf5K,MAAO,iFACP6B,QAASuL,KAAKC,uBACbhM,EAAe0F,OAAQ,IAAI7L,OAAAwQ,GAE7B7I,IAEPjB,UAAW,CACP,CACI1C,GAAI8K,GAAWY,MACfrN,KAAM,GACNwC,KAAMqN,KAAKE,SACXtN,MAAO,kCACPG,UAAU,GAEd,CACIjB,GAAI8K,GAAWY,MACfrN,KAAM,GACNwC,KAAMqN,KAAKG,SACXvN,MAAO,8BACPG,UAAU,IAGlB+B,OAAAA,GAGR,GAKAvF,SAAS6Q,KAAKzQ,iBAAiB,QAAS,SAAA0Q,GAAgB,IAAbzT,EAAMyT,EAANzT,OAEnCA,EAAOiP,aAAa,iBAAmBjP,EAAO2L,SAE9C3L,EAAO2L,OAAS+H,GAAAA,EAAOC,kBAAkB3T,GACzCA,EAAO2L,OAAOiI,OAItB,IAEAvR,EAAAA,EAAAA,IAAO,2BAA2BN,QAAQ,SAAC6M,GAEvCA,EAAM7L,iBAAiB,SAAU,SAAA8Q,GAAgB,IAAb7T,EAAM6T,EAAN7T,OAE1BwG,GAAOsN,EAAAA,EAAAA,IAAgB9T,EAAOyG,QAAQsN,YAEvCvN,GAILA,EAAKG,UAAUC,OAAO,cAAe5G,EAAO8O,QAEhD,EAEJ,IAEA5C,EAAAA,EAAAA,IAAU,gBAAgBnJ,iBAAiB,SAAU,SAACiR,GAClDA,EAAEC,iBACF1G,OAAO2G,SAASC,MAAOL,EAAAA,EAAAA,IAAgB,kBAAkBxT,KAC7D,IAEAwT,EAAAA,EAAAA,IAAgB,kBAAkB/Q,iBAAiB,SAAU,SAAAqR,GAASA,EAANpU,OACrD6O,KAAKwF,eAChB,GAiBA,IAAMC,GAAgB,IAAIC,iBAAiB,SAACzS,GAExCA,EAAQC,QAAQ,SAAAyS,GAAsB,IAAnBpL,EAAIoL,EAAJpL,KAAMpJ,EAAMwU,EAANxU,OAET,cAARoJ,GACAsJ,GAAc1S,EAGtB,EAEJ,G,6uCCzFA,SAASyU,GAAelR,EAAMsF,GAAyB,IAAbmF,EAAIpI,UAAA2D,OAAA,QAAApF,IAAAyB,UAAA,GAAAA,UAAA,GAAG,KAE7CpD,EAASD,OAAO,QAAQ6B,QAAQ,sBAAuB,CACnDb,KAAAA,EACAsF,WAAAA,EACAmF,KAAAA,IAEJ0F,GAAAA,EAAOnR,QAAOuR,EAAAA,EAAAA,IAAgB,kBAAkBY,MAEpD,CAUA,SAASC,GAAe/F,EAAOgG,GAE3BhG,EAAMiG,kBAAkBD,GACxBhG,EAAMC,KAAKiG,gBAEf,EDmEAzS,EAAAA,EAAAA,IAAO,oCAAsCN,QAAQ,SAAC6M,GAElD,IAAMmG,GAAS7I,EAAAA,EAAAA,IAAU0C,EAAMnI,QAAQsO,QAEvCnG,EAAM7L,iBAAiB,QAAS,WAE5B2P,GAAc9D,GAEVmG,IACAA,EAAOzU,MAAQsO,EAAMtO,MAG7B,GAEAoS,GAAc9D,GACd0F,GAAcU,QAAQpG,EAAO,CACzBqG,YAAY,EACZC,gBAAiB,CAAC,MAAO,MAAO,UAGxC,GCpFA,IAAMC,GAAY,CACd5N,KAAM,CAEF,SAAY,cAmDpB,SAAS6N,GAAiB7C,GAEtB,IAAIhP,EAAO,GACL8R,EAAY9C,EAAK+C,UAAU,SAAAC,GAAK,MAAc,UAAdA,EAAFrQ,EAAuB,GAS3D,OAPImQ,GAAa,IAEb9R,EAAOgP,EAAK8C,GAAW9R,KACvBgP,EAAKrE,OAAOmH,EAAW,IAIpB9R,CAEX,CAWA,SAASiS,GAAoB3G,EAAMhL,GAE/B,GACIgL,EAAKpI,QAAQgP,YAAc5R,GACxB4G,OAAOoE,EAAKpI,QAAQgP,aAAehL,OAAO5G,GAFjD,CAOAgL,EAAKpI,QAAQgP,UAAY5R,EAEzB,IAAM6R,GAAS5B,EAAAA,EAAAA,IAAgB,kBAAqBjF,GACpD6G,EAAO/O,UAAUC,OAAO,aAAc/C,GAEtC,IAAM8R,GAAW7B,EAAAA,EAAAA,IAAgB,uBAA0B4B,GAC3DC,EAASC,aAAa,YAAa/R,GACnC8R,EAASC,aACL,gBAEI/R,EACE,IACA8R,EAASE,aAAa,iBAdhC,CAkBJ,CAUA,SAASC,GAAmBjJ,GAExB,IAAI3H,EAAK,GAQT,MANoB,iBAAT2H,EACP3H,EAAK2H,EACEA,GAAwB,WAAhBF,GAAOE,KACtB3H,EAAK2H,EAAK3H,IAAM,IAGb8K,GAAWS,YAAYvL,EAElC,CAkBA,SAAS6Q,GAAWtC,GAKjB,IFxMkB3F,EAAKtO,EEoMtBqP,EAAI4E,EAAJ5E,KACA0D,EAAIkB,EAAJlB,KACA3D,EAAK6E,EAAL7E,MACAuD,EAAKsB,EAALtB,MAGA,IA9NJ,SAAsBI,GAElB,OACIjJ,MAAMD,QAAQkJ,IACXA,EAAKhJ,QACLgJ,EAAKyD,MAAM,SAACnJ,GAAI,MAEK,WAAhBF,GAAOE,IACgB,iBAAbA,aAAI,EAAJA,EAAM3H,KAED,iBAAT2H,CAAiB,EAIvC,CAgNSoJ,CAAa1D,GAGd,OADAoC,GAAe/F,EAAOwE,KAAK8C,eACpB/E,QAAQJ,UAInB,GA5MJ,SAA0BwB,GAEtB,OAAOA,EACFtJ,OAAO,SAAAjH,GAAK,MAAc,UAAdA,EAAFkD,EAAuB,GACjCiR,KAAK,SAAAlU,GAAU,MAA0B,iBAA1BA,EAAP4F,OAAyC,EAE1D,CAsMQuO,CAAiB7D,GAAO,CAExB,IAAM8D,EAjJd,SAA2B9D,GAEvB,OAAOA,EAAKP,IAAI,SAACsE,GAoBb,MAhBqB,iBAAVA,IACPA,EAAQ,CAAEpR,GAAIoR,IAGlB1V,OAAOkB,QAAQqT,IAAWpT,QAAQ,SAAAoR,GAAgB,IAAA7D,EAAApN,GAAAiR,EAAA,GAAd9S,EAAGiP,EAAA,GAAE0C,EAAG1C,EAAA,GACxCgH,EAAMjW,GAAO2R,EAAIsE,EAAMjW,KAASiW,EAAMjW,EAC1C,GAEIiJ,MAAMD,QAAQiN,EAAMtQ,SACpBsQ,EAAMtQ,MAAQsQ,EAAMtQ,MAAM,IAG1BsQ,EAAM/O,OAAS+O,EAAMtQ,QACrBsQ,EAAMtQ,MAAQ,oBAAH9E,OAAuBoV,EAAM/O,KAAI,SAGzC+O,CAEX,EAEJ,CAuH2BC,CAAkBhE,GAIrC,OAFAiD,GAAoB3G,GAAM,IFrNbf,EEuND+E,KAAK2D,SFvNChX,EEuNS6W,EFrNxBhE,MAAMvE,EAAK,CACd2I,OAAQ,OACRC,KAAM,OACNlV,MAAO,WACPmV,YAAa,cACbC,QAAS,CACL,OAAU,mBACV,eAAgB,oBAEpBC,SAAU,SACVC,eAAgB,cAChBtD,KAAMrS,KAAKE,UAAU7B,KACtB0R,KAAK,SAACoB,GAAQ,OAAKA,EAASC,MAAM,IE0M5BrB,KAAK,SAAA2C,GAAyC,IAAtCkD,EAAOlD,EAAPkD,QAAS/I,EAAI6F,EAAJ7F,KAAMgJ,EAAOnD,EAAPmD,QAASC,EAAOpD,EAAPoD,QAE7BzB,GAAoB3G,GAAM,GAEtBkI,GAEAtC,GACIW,GAAiBiB,GACjBA,EAAWrE,IAAI,SAACnF,GAAI,OAChBsF,EAAM+E,qBAAqBpB,GAAmBjJ,KAC3CsF,EAAMgF,sBAAsBtK,EAAK,GAExCmB,GAEJ0F,GAAAA,EAAOnR,QAAOuR,EAAAA,EAAAA,IAAgB,kBAAkBY,SAI5CuC,GAAWA,EAAQ1N,SACnByN,GAAW,OAASC,EAAQG,KAAK,OAGrCzC,GAAe/F,EAAOoI,GAIlC,EAEJ,CAEA,IAAMzT,EAAO6R,GAAiB7C,GACxB1J,EAAa0J,EACdP,IAAI,SAACnF,GAAI,OAAKsF,EAAM/B,aAAa0F,GAAmBjJ,GAAM,GAC1D5D,OAAOxE,SAEZ,OAAKoE,EAAWU,QAOhBkL,GAAelR,EAAMsF,GACdsI,QAAQJ,YANX4D,GAAe/F,EAAOwE,KAAKiE,cACpBlG,QAAQJ,UAOvB,CAWA,SAASuG,GAAkBC,EAAQC,GAE/B,GAAIA,EAAW,CAEX,IAAMC,EAAWF,EAAO/N,KAAK,SAACkO,GAAK,OAAKA,EAAMpX,KAAK,GACnDiX,EAAOxV,QAAQ,SAAC2V,GACZA,EAAMC,UAAYF,GAAYC,IAAUD,CAC5C,EAEJ,MAEIF,EAAOxV,QAAQ,SAAC2V,GAEZA,EAAM7C,kBAAkB,IACxB6C,EAAMC,UAAW,CAErB,EAIR,CAEA,IAAM9I,IAAO3C,EAAAA,EAAAA,IAAU,wBACjB0L,IAAY1L,EAAAA,EAAAA,IAAU,yBACtB2L,GAAkBD,GAAUE,mBAC5BC,IAAW7L,EAAAA,EAAAA,IAAU,sBACrB8L,IAAa9L,EAAAA,EAAAA,IAAU,wBACvB+L,IAAW/L,EAAAA,EAAAA,IAAU,kBACrBgM,IAAS7V,EAAAA,EAAAA,IAAO,mBAAsBwM,IACtCsJ,GAAe,CAACP,GAAWG,GAAUC,IChVpC,SAASI,GAAQC,GAEpB,IAAMC,EAAU/K,OAAOgL,OAAOC,gBAC1B,IAAIC,YAAYJ,EAAM9O,SAG1B,OAAOD,MAAMoP,KAAKL,EAAO,SAAC/X,EAAOqY,GAAC,MAAM,CAChCrY,MAAAA,EACAqR,KAAM2G,EAAQK,GACjB,GACAhH,KAAK,SAACC,EAAGC,GAAC,OAAKD,EAAED,KAAOE,EAAEF,IAAI,GAC9BK,IAAI,SAAAhQ,GAAQ,OAAAA,EAAL1B,KAAiB,EAEjC,CCVO,SAASsY,GAAMjG,EAAKrS,EAAOsS,GAC9B,OAAOiG,KAAKjG,IAAID,EAAKkG,KAAKlG,IAAIrS,EAAOsS,GACzC,CAUO,SAASkG,GAAaC,GACzB,OAAOnY,OAAO0N,OAAO,CAAC,EAAG,EAAG,GAAIyK,EAAOC,MAAM,KAAKhH,IAAIiH,QAC1D,CA8DO,SAASC,GAAMC,EAAQrW,EAASsW,GAKnC,IAHA,IAAMxG,EArBH,SAAkBuG,GACrB,OAAON,KAAKQ,MAAMR,KAAKS,IAAIH,GAC/B,CAmBgBI,CAASJ,IAAW,EAC5BrO,EAAQ,EAELA,EAAQ8H,GAEX9P,EAAQ/B,KAAKqY,EAAStO,EAAO8H,GAC7B9H,GAAS,EAIb,OAAO8H,CAEX,C,ogCFqPAsF,GAAOnW,QAAQ,SAACyX,GAEZA,EAAMzW,iBAAiB,QAAS,SAAAqR,GAAgB,IAEtC1D,EAA4B,WAFG0D,EAANpU,OAEPM,MAExB2X,GAASjM,QAAU0E,EACnB4G,GAAkBa,GAAczH,EAEpC,EAEJ,GAEAyH,GAAapW,QAAQ,SAAC6M,GAElBA,EAAM7L,iBAAiB,QAAS,WAE5B6L,EAAMiG,kBAAkB,IACxByC,GAAkBa,IAAc,EAEpC,EAEJ,GAEAtJ,GAAK9L,iBAAiB,SAAU,SAACiR,GAI7B,GAFAA,EAAEC,iBAE6B,SAA3BpF,GAAKpI,QAAQgP,UAAjB,CAIA,IAAM+D,EAAQtB,GAAO1O,KAAK,SAAAgL,GAAU,OAAAA,EAAP1F,OAAqB,GAC5CxH,EAAUkS,aAAK,EAALA,EAAOlZ,MAElBgH,GAIL0I,GAAWlM,MAAM,SAAC2V,GAEd,GAAgB,WAAZnS,GAEA,GAAIyQ,GAASzX,MAAO,CAEhBkV,GAAoB3G,IAAM,GAE1B,IAAM6K,EAAQ/O,EAAS4C,OAAOoM,mBAAmB9G,KAAK/E,KAAM,CACxDA,IAAKP,OAAOqM,mBAAmB7B,GAASzX,SAG5C+R,MAAMqH,GAAM,MACD,SAAC9E,GACJD,GAAeoD,GAAUnD,EAAMoC,SAC/BxB,GAAoB3G,IAAM,EAC9B,GACCqC,KAAK,SAACoB,GAAQ,OAAKA,EAASC,MAAM,GAAC,MAC7B,WAGH,OAFAoC,GAAeoD,GAAU3E,KAAK8C,eAC9BV,GAAoB3G,IAAM,GACnB,IACX,GACCqC,KAAK,SAACqB,GAEH,GAAa,OAATA,EAIJ,OAAKA,EAAKwE,aAMVhB,GAAY,CACRlH,KAAAA,GACA0D,KAAMA,EAAK/S,KACXoP,MAAOmJ,GACP5F,MAAOsH,IACRvI,KAAK,kBAAMsE,GAAoB3G,IAAM,EAAM,IAV1C8F,GAAeoD,GAAUxF,EAAKyE,cAC9BxB,GAAoB3G,IAAM,GAWlC,EAER,MAAO,GAAI+I,GAAUiC,MAAMtQ,OAAQ,CAE/B,IAAMuQ,EAAS,IAAIC,WAEnBD,EAAO/W,iBAAiB,OAAQ,SAAAiX,GAAgB,IAAbha,EAAMga,EAANha,OAE3BuS,EAAO,GAEX,IACIA,EAAOpR,KAAKC,MAAMpB,EAAOia,OAC7B,CAAE,MAAOrF,GACL,OAAOD,GAAeiD,GAAWxE,KAAK8C,cAC1C,CAEAH,GAAY,CACRlH,KAAAA,GACA0D,KAAAA,EACA3D,MAAOgJ,GACPzF,MAAOsH,GAGf,GAEAK,EAAOI,WAAWtC,GAAUiC,MAAM,GAEtC,MAAO,GAAI7B,GAAW1X,MAAO,CAEzB,IAAIiS,EAAO,GAEX,IACIA,EAAOpR,KAAKC,MAAM4W,GAAW1X,MACjC,CAAE,MAAOsU,GACL,OAAOD,GAAeqD,GAAY5E,KAAK8C,cAC3C,CAEAH,GAAY,CACRlH,KAAAA,GACA0D,KAAAA,EACA3D,MAAOoJ,GACP7F,MAAOsH,GAGf,OAIAhF,IACI0F,EAAAA,EAAAA,IAAaX,GACbC,EACKW,mBACAnR,OAAO,SAACvE,GAAS,OAAKA,EAAU2V,eAAiB/S,CAAO,GAKzE,EA5GA,CA8GJ,GAEAsQ,GAAU7U,iBAAiB,QAAS,WAEhC,IACIzC,EACAsX,GADAtX,MAGJsX,GAAU/C,kBAAkB,IAC5BgD,GAAgBpR,QAAQnG,MACpBA,EACEA,EAAMK,MAAML,EAAMga,YAAY,MAAQ,GACtCzC,GAAgBpR,QAAQ8T,YAG1Bja,GAASyX,GAASzX,QAElByX,GAASzX,MAAQ,IACjBka,EAAAA,EAAAA,IAAczC,IAItB,GAEAA,GAAShV,iBAAiB,QAAS,WAE/BgV,GAASlD,kBAAkB,IAEvBkD,GAASzX,OAASsX,GAAUtX,QAE5BsX,GAAUtX,MAAQ,IAClBka,EAAAA,EAAAA,IAAc5C,IAItB,GAEAlE,GAAAA,EAAOnR,QAAO2J,EAAAA,EAAAA,IAAU,kBAAkBoB,GAAGoG,GAAAA,EAAO+G,KAAM,WAEtD7C,GAAUtX,MAAQ,IAClBka,EAAAA,EAAAA,IAAc5C,IACdG,GAASzX,MAAQ,IACjBka,EAAAA,EAAAA,IAAczC,GAElB,GG5fA,IAAMtF,GAAejQ,EAASD,OAAO,QAC/BmY,GAAgBlY,EAASD,OAAO,SAQtC,SAASoY,GAAU7H,GAEflS,OAAOkB,QAAQgR,GAAW/Q,QAAQ,SAAAC,GAAmB,IAAAC,EAAAC,GAAAF,EAAA,GAAjBuF,EAAItF,EAAA,GAAE2Y,EAAK3Y,EAAA,IAE3C4Y,EAAAA,EAAAA,IAAa,eAAD3Z,OAAgBqG,EAAI,oCAC3BxF,QAAQ,SAACO,GACNA,EAAQ6C,YAAcyV,CAC1B,EAER,EAEJ,CAUA,SAASE,GAAsBvT,EAAMqT,GAGjC,IAAMzL,GAAS9M,EAAAA,EAAAA,IAAO,eAADnB,OAAgBqG,EAAI,0BAEzC,GAAK4H,EAAO5F,OAAZ,CAIA,IAAMwR,EAAS3C,GAAQjJ,GAAQxO,MAAM,EAAGia,GAExCzL,EAAOpN,QAAQ,SAAC6M,GAEZ,IAAMoM,EAAYpM,EAAME,QACxBF,EAAME,QAAUiM,EAAOrM,SAASE,GAE5BoM,KACA9O,EAAAA,EAAAA,IAAU,qBAADhL,OAAsB0N,EAAMtO,MAAK,OAAMA,MAAQ,GAGxDsO,EAAME,UAAYkM,IAClBR,EAAAA,EAAAA,IAAc5L,EAGtB,EAjBA,CAmBJ,CAEA6D,GAAanF,GAAG,wBAAyB,SAAA6F,GAAgB,IAAblQ,EAAMkQ,EAANlQ,OAElCgY,GAAcnH,EAAAA,EAAAA,IAAgB,iBAUpC,SAASoH,IAEL,IACIpI,EACA7P,EADA6P,UAGJ,OAAOA,EAAU8F,GAAM,EAAGqC,EAAY3a,MAAQ,EAAGwS,EAAUvJ,OAAS,GAExE,CAhBA0R,EAAYlY,iBAAiB,QAAS,WAElC0P,GAAarO,QAAQ,eAAgB,CACjCwW,MAAO3B,OAAOgC,EAAY3a,QAGlC,GAYA2a,EAAYlY,iBAAiB,QAAS,kBAAM4X,GAAUO,IAAe,GACrEP,GAAUO,MAEVhP,EAAAA,EAAAA,IAAU,yBAAyBnJ,iBAAiB,QAAS,WAEzD,IAAIoY,EAAQ,EAEZva,OAAOkB,QAAQoZ,KAAgBnZ,QAAQ,SAAAuN,GAAmB,IAAAiG,EAAArT,GAAAoN,EAAA,GAAjB/H,EAAIgO,EAAA,GAAEqF,EAAKrF,EAAA,GAEhDuF,GAAsBvT,EAAMqT,GAC5BO,GAASP,CAEb,GAEAE,GAAsB,YAAaG,EAAY3a,MAAQ6a,EAE3D,EAEJ,GAEA1I,GAAanF,GAAG,sBAAuB,SAAAmG,GAAgB,IFvFxB2H,EE0FvBvS,EAHwC4K,EAANxQ,OAGlC4F,WAEEwS,GF5FqBD,EE4FO,SAAC1W,GAAS,OAAKA,EAAU4W,SAAS,EAA9CzS,EF1FT0S,OAAO,SAACC,EAAS3O,EAAM8L,GAEhC,IAAM8C,EAAQL,EAASvO,EAAM8L,GAQ7B,OANK6C,EAAQC,KACTD,EAAQC,GAAS,IAGrBD,EAAQC,GAAOxU,KAAK4F,GAEb2O,CAEX,EAAG5a,OAAO2B,OAAO,SEgFjBsY,EAAAA,EAAAA,IAAa,eAAe9Y,QAAQ,SAAC2Z,GAGjC,IAAMnU,EAAOmU,EAAQjV,QAAQc,KACvBoU,EAAkBrS,MAAMD,QAAQgS,EAAM9T,IAC5CmU,EAAQ1P,QAAU2P,GAElBC,EAAAA,EAAAA,KACI9H,EAAAA,EAAAA,IAAgB,8BAA+B4H,IAC9CL,EAAM9T,IAAS,IAAIyK,IAAI,SAACtN,GAAS,OAAKA,EAAUmX,YAAY,KAIjExZ,EAAAA,EAAAA,IAAO,+BAAgCqZ,GAAS3Z,QAAQ,SAAC6M,GACrDA,EAAME,SAAU,CACpB,IAEAgF,EAAAA,EAAAA,IAAgB,+BAAgC4H,GAASvW,YAAc,EAMvEuW,EAAQI,aAAczZ,EAAAA,EAAAA,IAAO,uBAA0BqZ,EAE3D,GAGA,IAAIK,EAAa,GACjBA,GAAclD,KAAKlG,KAAK0I,EAAMW,WAAa,IAAIzS,OAAQ,GACvDwS,EAAalD,KAAKlG,IAAIoJ,EAAYlT,EAAWU,QAC7C,IAAM0R,GAAcnH,EAAAA,EAAAA,IAAgB,iBAEpCmH,EAAYrI,IAAMmJ,EAEdd,EAAY3a,OAASyb,IAErBd,EAAY3a,MAAQyb,GACpBvB,EAAAA,EAAAA,IAAcS,KAKlBnH,EAAAA,EAAAA,IAAgB,sBAAsBmI,UAAW,CAErD,IAEA/P,EAAAA,EAAAA,IAAU,qBAAqBnJ,iBAAiB,QAAS,SAAA8Q,GAAgB,IAAb7T,EAAM6T,EAAN7T,QAExD6a,EAAAA,EAAAA,IAAa,eAAe9Y,QAAQ,SAAC2Z,GACjCA,EAAQ/U,UAAUC,OAAO,qBAAsB5G,EAAO8O,QAC1D,EAEJ,IAEA5C,EAAAA,EAAAA,IAAU,sBAAsBnJ,iBAAiB,QAAS,SAAAqR,GAAgB,IAGlEtF,EAH2DsF,EAANpU,OAGrD8O,SAGJ+L,EAAAA,EAAAA,IAAa,eAAe9Y,QAAQ,SAAC2Z,GAEjCA,EAAQ/U,UAAUC,OAAO,qBAAsBkI,GAE1CA,IAEDzM,EAAAA,EAAAA,IAAO,mBAAsBqZ,GAAS3Z,QAAQ,SAAC6M,GAIvCA,EADAtO,MAGQ,IAERsO,EAAMtO,MAAQ,GACdka,EAAAA,EAAAA,IAAc5L,GAItB,EAIR,EAEJ,IAEAiM,EAAAA,EAAAA,IAAa,eAAe9Y,QAAQ,SAAC2Z,GAEjCA,EAAQ3Y,iBAAiB,SAAU,SAAAyR,GAAgB,IAAbxU,EAAMwU,EAANxU,OAE7BA,EAAO2E,QAAQ,4BAIpB8N,GAAarO,QAAQ,mBAAoB,CACrC9B,QAAStC,EACTkF,GAAIlF,EAAOM,MACXyD,OAAQ/D,EAAO8O,SAGvB,GAEA4M,EAAQ3Y,iBAAiB,QAAS,SAAAiX,GAAgB,IAAbha,EAAMga,EAANha,OAE5BA,EAAO2E,QAAQ,yBAIpB8N,GAAarO,QAAQ,yBAA0B,CAC3C9B,QAAStC,EACTkF,GAAIlF,EAAOyG,QAAO,IAClBmU,MAAO3B,OAAOjZ,EAAOM,QAG7B,GAEAob,EAAQ3Y,iBAAiB,QAAS,SAAAmZ,GAAgB,IAExC1Q,EAFiC0Q,EAANlc,OAEXiK,QAAQ,0BAE9B,GAAKuB,EAAL,CAIA,IAAMoD,EAAQpD,EAAOoD,QAAS1C,EAAAA,EAAAA,IAC1B,+BACAV,EAAOvB,QAAQ,6CAEnBuB,EAAOoD,MAAQA,EAEf,IAEMuN,GAFQlD,OAAOrK,EAAMtO,QAAU,IACvB2Y,OAAOzN,EAAO/E,QAAQ2V,iBAAmB,GAKvD,GAFAxN,EAAMtO,MAAQ6b,EAEVA,GACA3B,EAAAA,EAAAA,IAAc5L,OACX,CAEH,IAAMyN,GAAWnQ,EAAAA,EAAAA,IACb,+BACAV,EAAOvB,QAAQ,0BAEnBoS,EAASvN,SAAU,GACnB0L,EAAAA,EAAAA,IAAc6B,EAElB,CAzBA,CA2BJ,EAEJ,GAEA5J,GAAanF,GAAG,mBAAoB,SAAAgP,GAAgB,IAAbrZ,EAAMqZ,EAANrZ,OAG/BiC,EAGAjC,EAHAiC,GACAnB,EAEAd,EAFAc,OACAzB,EACAW,EADAX,QAGEsM,GAAQ1C,EAAAA,EAAAA,IAAU,qBAADhL,OAAsBgE,EAAE,OACzC5E,EAAQ2Y,OAAOrK,EAAMtO,OAE3BgC,EACK2H,QAAQ,yBACRtD,UACAC,OAAO,cAAe7C,GAEvBA,EAEIzD,EAAQ,IACRsO,EAAMtO,MAAQ,GAIlBsO,EAAMtO,MAAQ,GAGlBka,EAAAA,EAAAA,IAAc5L,EAElB,GAEA,IAAM2N,IAAkBrQ,EAAAA,EAAAA,IAAU,6BAElCuG,GAAanF,GAAG,yBAA0B,SAAAkP,GAAgB,IAKhDd,EALyCc,EAANvZ,OAGrCX,QAEoB2H,QAAQ,gBACX6J,EAAAA,EAAAA,IACjB,+BACA4H,GAGSvW,YAAcuW,EAAQI,YAAYP,OAAO,SAACJ,EAAOvM,GAC1D,OAAOuM,EAAQlC,OAAOrK,EAAMtO,MAChC,EAAG,GAEHic,GAAgB1H,kBAAkB,GAEtC,IAEA3I,EAAAA,EAAAA,IAAU,kBAAkBnJ,iBAAiB,SAAU,SAACiR,GAEpDA,EAAEC,iBAEF,IAAMwI,GAAMpa,EAAAA,EAAAA,IAAO,uCAAwC2R,EAAEhU,QACxDgS,IAAI,SAAA0K,GAAQ,OAAAA,EAALpc,KAAiB,GAE7B0P,GAAWlM,MAAM,SAAC2V,GAEd,IAAMkD,EAAWlD,EACZW,mBACAnR,OAAO,SAACvE,GAAS,OAAK+X,EAAI/N,SAAShK,EAAUI,QAAQ,GACrDkN,IAAI,SAACtN,GAKF,IAAMkY,EAAa,GAOnB,OALA1D,IACIhN,EAAAA,EAAAA,IAAU,qBAADhL,OAAsBwD,EAAUI,QAAO,OAAMxE,MACtD,kBAAMsc,EAAW3V,KAAKvC,EAAU,GAG7BkY,CAEX,GACCC,OAECC,EAAcH,EAAS1T,OAAO,SAACvE,GACjC,OAAOA,EAAUqY,eAAe,YAAa,eACjD,GAEA,GAAID,EAAYvT,OAEZgT,GAAgB1H,kBAAkBlK,EAC9B4C,OAAO6F,KAAK0J,YACZ,CAACA,EAAY9K,IAAI,SAACtN,GAAS,OAAKA,EAAUU,SAAS,GAAEgS,KAAK,SAE9DmF,GAAgB1N,KAAKiG,qBAElB,KAAAkI,EAEHT,GAAgB1H,kBAAkB,IAElC,IAAMoI,EAAYxY,QAA4B,uBAAT,QAAXuY,EAAAhJ,EAAEkJ,iBAAS,IAAAF,OAAA,EAAXA,EAAa9X,KAEvCuN,GAAarO,QAAQ,iBAAkB,CACnC6Y,UAAAA,EACApU,WACIoU,EACE7E,GAAQuE,GACRA,IAIVjJ,GAAAA,EAAOnR,QAAOuR,EAAAA,EAAAA,IAAgB,sBAAsBY,MAExD,CAEJ,EAEJ,GAEAgG,GAAcpN,GAAG,qBAAsB,SAAA6P,GAAgB,IAAAC,EAUxCC,EAV2Bpa,EAAMka,EAANla,OAGlCoB,EAEApB,EAFAoB,KACAR,EACAZ,EADAY,MAEE+K,GAAQ1C,EAAAA,EAAAA,IAAU,uCAADhL,OACoC,QADpCkc,EACoB/Y,EAAKiZ,mBAAW,IAAAF,OAAA,EAAhBA,EAAkBtY,QAAO,OAGhE8J,IAG4C,QAD5CyO,EAAAzO,EACK3E,QAAQ,uCAA+B,IAAAoT,GACM,QADNA,EAD5CA,EAEME,cAAc,sCAA8B,IAAAF,GAFlDA,EAGM1W,UAAUC,OAAO,UAAW/C,GAI1C,GAEA,IAAM2Z,IAAiBtR,EAAAA,EAAAA,IAAU,oBAEjC,SAASuR,GAAmBtE,GAEpBA,EAAS,KACTA,EAAS,IAGbA,EAAS1O,OAAO0O,GAEhB,IAAMrO,GAAQ+P,EAAAA,EAAAA,IAAa,eAAgB2C,IACtClI,UAAU,SAACoI,GAAI,OAAKA,EAAKjX,QAAQmU,QAAUzB,CAAM,IAEtD9W,EAAAA,EAAAA,IAAO,YAAamb,IACfzb,QAAQ,SAAC2b,GAAI,OAAKA,EAAK/W,UAAUwF,OAAO,WAAW,IAExD0O,EAAAA,EAAAA,IAAa,WAAY2C,IAAgBzb,QAAQ,SAAC4b,GAAQ,IAAAC,EACN,QAAhDA,GAAA/C,EAAAA,EAAAA,IAAa,uBAAwB8C,GAAK7S,UAAM,IAAA8S,GAAhDA,EAAkDjX,UAAUkX,IAAI,WACpE,EAEJ,EAEA/J,EAAAA,EAAAA,IAAgB,iBAAiB/Q,iBAAiB,QAAS,SAAA+a,GACvDL,GADgEK,EAAN9d,OAChCM,MAC9B,GACAmd,IAAmB3J,EAAAA,EAAAA,IAAgB,iBAAiBxT,OCjbpD,IAAMmS,GAAejQ,EAASD,OAAO,QAC/Bwb,GAA0BrK,GAAAA,EAAOnR,QAAO2J,EAAAA,EAAAA,IAAU,wBAClDsC,IAAatC,EAAAA,EAAAA,IAAU,gBAE7BuG,GAAanF,GAAG,iBAAkB,SAAAtL,GAAgB,IAAbiB,EAAMjB,EAANiB,OAEjC,IAAIA,EAAOga,UAAX,CAIA,IAAM1b,EAAWD,EAASiB,QACtBuR,EAAAA,EAAAA,IAAgB,gCAGpB8H,EAAAA,EAAAA,KACI9H,EAAAA,EAAAA,IAAgB,6BAChBsE,GAAQnV,EAAO4F,YACVmJ,IAAI,SAACtN,EAAWiU,GAAC,OAAKpX,EAAS0D,KAAK,CACjC,YAAW,SAAC3C,GACRA,EAAQmE,QAAQvB,GAAKR,EAAUI,OACnC,EACA,gCAA+B,SAACxC,GAC5BA,EAAQ6C,YAAcwT,EAAI,CAC9B,GACF,IAGVjF,GAAAA,EAAOnR,QAAOuR,EAAAA,EAAAA,IAAgB,sBAAsBF,MAnBpD,CAqBJ,GAEAnB,GAAanF,GAAG,iBAAkB,SAAArL,GAAgB,IAAbgB,EAAMhB,EAANgB,OAE5BA,EAAOga,aAIZnJ,EAAAA,EAAAA,IAAgB,aAAavE,MAAO,EAEpCS,GAAWlM,MAAM,SAAC2V,GAEdxW,EAAO4F,WAAW9G,QAAQ,SAAC2C,GAEvB+N,GAAarO,QAAQ,kBAAmB,CACpCM,UAAWA,EAAU/C,QACrBqc,WAAW,GAGnB,EAEJ,GAEJ,IAEAlK,EAAAA,EAAAA,IAAgB,qBAAqB/Q,iBAAiB,QAAS,SAAAoQ,GAAgB,IAErE7Q,EAF8D6Q,EAANnT,OAEvCiK,QAAQ,aAE1B3H,IAAWA,EAAQ2Z,UAIxBjM,GAAWlM,MAAM,SAAC2V,GAKdhH,GAAarO,QAAQ,kBAAmB,CACpC9B,QAAAA,EACAoC,UAAW+U,EAAWrJ,aAAa9N,EAAQmE,QAAQvB,IAAIvD,SAG/D,EAEJ,GAEA8Q,GAAanF,GAAG,kBAAmB,SAAAgC,GAAgB,IAG3ChN,EAHoCgN,EAANrM,OAG9BX,QAGAA,IACAA,EAAQ2Z,UAAW,EAG3B,GAEAxJ,GAAanF,GAAG,kBAAmB,SAAAiI,GAAgB,IAAbtS,EAAMsS,EAANtS,OAG9B+a,EAEA/a,EAFA+a,UACAtZ,EACAzB,EADAyB,UAGAsZ,KAIJjR,EAAAA,EAAAA,KAAM+G,EAAAA,EAAAA,IAAgB,gCAAgCjN,OAClDnC,EAAUoC,cAEdgN,EAAAA,EAAAA,IAAgB,+BAA+B3O,YAC3CT,EAAUuZ,aAEdF,GAAwBnK,OAE5B,GAMA,IAAIlP,GAAY,KAEhB+N,GAAanF,GAAG,kBAAmB,SAAAmG,GAAgB,IAAbxQ,EAAMwQ,EAANxQ,OAClCyB,GAAYzB,EAAOyB,SACvB,GAEAqZ,GAAwBzQ,GAAGoG,GAAAA,EAAOwK,KAAM,WACpC1P,GAAWlO,MAAQkO,GAAW2P,YAClC,GAEAJ,GAAwBzQ,GAAGoG,GAAAA,EAAO+G,KAAM,WAEpC,IACI2D,GACAtK,EAAAA,EAAAA,IAAgB,YADhBsK,IAKEC,GADF7P,GADAlO,OAEsB,IAAIge,OAE1BF,GAAOC,GAAW3Z,IAClB0Z,EAAIG,cAAc7Z,GAAW2Z,GAGjC3Z,GAAY,IAEhB,IAEAwH,EAAAA,EAAAA,IAAU,4BAA4BnJ,iBAAiB,SAAU,SAACiR,GAC9DA,EAAEC,iBACF8J,GAAwBrJ,MAC5B,G,eCvJMjC,GAAejQ,EAASD,OAAO,QAC/Bic,GAAiB5d,OAAO2B,OAAO,MAKrC,SAASkc,KAEL,IAAMC,GAAoB5K,EAAAA,EAAAA,IAAgB,uBAAuBhF,QAC3D6P,GAAgB7K,EAAAA,EAAAA,IAAgB,mBAAmBhF,QACnD8P,GAAS9K,EAAAA,EAAAA,IAAgB,YACzB+K,GAAS/K,EAAAA,EAAAA,IAAgB,iBACzBhG,EAAM,IAAIgR,IAAID,EAAO1K,MAE3B4K,EAGIH,EAAOnY,QAFPlD,EAAIwb,EAAJxb,KACAyK,EAAI+Q,EAAJ/Q,KASJ,GANIzK,EACAuK,EAAIkR,aAAaC,IAAI,OAAQ1b,GAE7BuK,EAAIkR,aAAY,OAAQ,QAGxBhR,EAEAF,EAAIkR,aAAaC,IAAI,OAAQjR,GAC7BF,EAAIkR,aAAaC,IAAI,YAAahG,OAAOyF,IACzC5Q,EAAIkR,aAAaC,IAAI,SAAUhG,OAAO0F,IACtC7Q,EAAIkR,aAAY,OAAQ,kBAErB,CAEH,IAAM3D,EAAQ,CACV,YACA,WACA,SACA,SAGAqD,GACArD,EAAMpU,KAAK,aAGX0X,GACAtD,EAAMpU,KAAK,UAGf,IAAMwV,EAAM+B,GAAeI,EAAOnY,QAAQoC,YACrCI,OAAO,SAACvE,GAAS,OAAK2W,EAAM3M,SAAShK,EAAU4W,UAAU,GACzDtJ,IAAI,SAACtN,GAAS,OAAKA,EAAUI,OAAO,GACzCgJ,EAAIkR,aAAaC,IAAI,aAAcxC,GACnC3O,EAAIkR,aAAY,OAAQ,QACxBlR,EAAIkR,aAAY,OAAQ,aACxBlR,EAAIkR,aAAY,OAAQ,SAE5B,EAEAjS,EAAAA,EAAAA,IAAM6R,GAAQ/X,QAAOqY,EAAAA,GAAAA,GAAO,CACxBC,IAAKrR,EAAIsR,WACTC,IAAK,QAETvL,EAAAA,EAAAA,IAAgB,mBAAmBmI,UAAW,EAC9C4C,EAAO1K,KAAOrG,EAAIsR,YAClBtL,EAAAA,EAAAA,IAAgB,iBAAiBmI,UAAW,CAEhD,CAEAxJ,GAAanF,GAAG,sBAAuB,SAAAtL,GAAgB,IAAbiB,EAAMjB,EAANiB,OAGlCM,EAGAN,EAHAM,KACAsF,EAEA5F,EAFA4F,WACAmF,EACA/K,EADA+K,KAGE4Q,GAAS9K,EAAAA,EAAAA,IAAgB,YAE/B,GAAI9F,EAEA4Q,EAAOnY,QAAQuH,KAAOA,SACf4Q,EAAOnY,QAAQoC,eAEnB,CAEH,IAAM4T,EAAMtb,KAAKE,UACbwH,EAAWmJ,IAAI,SAACtN,GAAS,OAAKA,EAAUI,OAAO,IAGnD0Z,GAAe/B,GAAO5T,EACtB+V,EAAOnY,QAAQoC,WAAa4T,SACrBmC,EAAOnY,QAAQuH,IAE1B,CAEIzK,EACAqb,EAAOnY,QAAQlD,KAAOA,SAEfqb,EAAOnY,QAAQlD,KAG1Bkb,IAEJ,IAEA3K,EAAAA,EAAAA,IAAgB,uBAAuB/Q,iBAAiB,SAAU,WAC9D0b,IACJ,IAEA3K,EAAAA,EAAAA,IAAgB,mBAAmB/Q,iBAAiB,SAAU,WAC1D0b,IACJ,GC9GA,IAAMtM,GAAQlF,GAAM1K,OAAO,mBACrB+c,IAASzE,EAAAA,EAAAA,IAAa,uBCPrB,SAAS0E,KAEhB,C,gtBDOArT,EAAAA,EAAAA,IAAU,cAAcnJ,iBAAiB,SAAU,SAAAf,GAAgB,IAAbhC,EAAMgC,EAANhC,QAElD8T,EAAAA,EAAAA,IAAgB,qBAAqB9H,OAAShM,EAAO8O,QAEjD9O,EAAO8O,SAEPwQ,GAAOvd,QAAQ,SAAC6M,GAEZA,EAAME,SAAU,GAChB0L,EAAAA,EAAAA,IAAc5L,EAElB,EAIR,IAEA1C,EAAAA,EAAAA,IAAU,iBAAiBnJ,iBAAiB,SAAU,SAAAd,GAAgB,IAAbjC,EAAMiC,EAANjC,QACrD8T,EAAAA,EAAAA,IAAgB,kBAAkB9H,QAAUhM,EAAO8O,OACvD,IAEA5C,EAAAA,EAAAA,IAAU,qBAAqBnJ,iBAAiB,SAAU,SAAAoQ,GAAgB,IAAbnT,EAAMmT,EAANnT,QACzD8T,EAAAA,EAAAA,IAAgB,uBAAuB9H,QAAUhM,EAAO8O,OAC5D,IAEA5C,EAAAA,EAAAA,IAAU,eAAenJ,iBAAiB,SAAU,SAACiR,GAEjDA,EAAEC,iBAEFqL,GAAOvd,QAAQ,SAAAuN,GAAwB,IAArBhP,EAAKgP,EAALhP,MAAcgP,EAAPR,SAGjBqD,GAAK,OAAQ7R,EAGrB,IAEIwT,EAAAA,EAAAA,IAAgB,kBAAkBhF,SAClCvB,OAAO2G,SAASsL,SAGpB9L,GAAAA,EAAOnR,QAAOuR,EAAAA,EAAAA,IAAgB,iBAAiBY,MAEnD,GE9CA,I,GAGqB+K,GAAM,WA4BvB,O,4GAAAhd,CApBA,SAAAgd,EAAYrB,EAAKpa,I,4FAAUvE,CAAA,KAAAggB,GAMvB/f,KAAK0e,IAAMA,EAMX1e,KAAKsE,SAAWA,EAEhBtE,KAAKggB,QACLhgB,KAAKigB,sBACLjgB,KAAKkgB,cAET,EAEA,EAAAvf,IAAA,QAAAC,MAGA,WAQIZ,KAAK0O,OAAS,EAMd1O,KAAKmgB,YAAcN,GAOnB7f,KAAKogB,YAAa,EAMlBpgB,KAAKqgB,QAAU,EAMfrgB,KAAKsgB,QAAU,CAEnB,GAEA,CAAA3f,IAAA,sBAAAC,MAGA,WAEI,IAAM2f,EAAOvgB,KAAK0e,IAAI8B,wBAMtBxgB,KAAKygB,QAAUF,EAAK9R,KAMpBzO,KAAK0gB,OAASH,EAAKpW,IAMnBnK,KAAK2gB,SAAWJ,EAAKK,MAMrB5gB,KAAK6gB,UAAYN,EAAKvQ,MAE1B,GAEA,CAAArP,IAAA,eAAAC,MAGA,WAAe,IAAAyE,EAAA,KAEXpC,SAASI,iBAAiB,YAAarD,MACvCiD,SAASI,iBAAiB,aAAcrD,MACxCiD,SAASI,iBAAiB,UAAWrD,MACrCiD,SAASI,iBAAiB,WAAYrD,MACtCiD,SAASI,iBAAiB,QAASrD,MACnCiD,SAASI,iBAAiB,cAAerD,MACzC6N,OAAOxK,iBAAiB,SAAUrD,MAClC6N,OAAOxK,iBAAiB,SAAUrD,MAEZ,IAAI6U,iBAAiB,WACvCxP,EAAK4a,qBACT,GAEc3K,QAAQtV,KAAK0e,IAAK,CAC5BnJ,YAAY,EACZC,gBAAiB,CAAC,UAG1B,GAEA,CAAA7U,IAAA,YAAAC,MAMA,SAAU8N,GACN1O,KAAK0O,OAASA,CAClB,GAEA,CAAA/N,IAAA,YAAAC,MAMA,WACI,OAAOZ,KAAK0O,MAChB,GAEA,CAAA/N,IAAA,gBAAAC,MAMA,WAII,OAFAZ,KAAK0O,QAAU,EAER1O,KAAK0O,MAEhB,GAEA,CAAA/N,IAAA,cAAAC,MAMA,SAAY0T,GAAG,IAAAlK,EAAA,KAEL9J,EAASgU,EAAEhU,OACXsG,EACwB,mBAAnBtG,EAAOiK,QACZjK,EAAOiK,QAAQ,uBACf,KAEAuW,ED3KP,SAAqBC,GAExB,IAAIrH,EAAU1Z,KACVqE,GAAS,EAEb,OAAO,WAAmB,QAAA2c,EAAA9a,UAAA2D,OAANoX,EAAI,IAAArX,MAAAoX,GAAAE,EAAA,EAAAA,EAAAF,EAAAE,IAAJD,EAAIC,GAAAhb,UAAAgb,GAEf7c,IAILA,GAAS,EACTwJ,OAAOsT,sBAAsB,WAEzB9c,GAAS,EACT0c,EAAKK,MAAM1H,EAASuH,EAExB,GAEJ,CAEJ,CCsJ6BI,CAAY,SAAC/M,GAAC,OAAKlK,EAAKkX,SAAShN,EAAE,GAExD,OAAQA,EAAE5K,MAEV,IAAK,YACL,IAAK,aACD1J,KAAKuhB,YAAY3a,EAAO0N,GACxB,MAEJ,IAAK,UACL,IAAK,WACL,IAAK,cACDtU,KAAKwhB,UAAUlN,GACf,MAEJ,IAAK,QACDtU,KAAKyhB,QAAQ7a,EAAO0N,GACpB,MAEJ,IAAK,SACDtU,KAAK0hB,SAASpN,GACd,MAEJ,IAAK,SACDwM,EAAaxM,GAKrB,GAEA,CAAA3T,IAAA,cAAAC,MAQA,SAAYgG,EAAO0N,GAEf,GAAK1N,EAAL,CAIA5G,KAAK2hB,UAAU/a,EAAO0N,GAEtB,IAAM5F,EAAS1O,KAAK4hB,gBACpBhb,EAAMmF,MAAMC,YAAY,YAAa0C,GAErC1O,KAAKsE,SAASI,QAAQ,SAAU,CAC5BgK,OAAAA,EACA9L,QAASgE,GATb,CAYJ,GAEA,CAAAjG,IAAA,YAAAC,MAMA,SAAU0T,GACNtU,KAAK6hB,aACT,GAEA,CAAAlhB,IAAA,UAAAC,MAQA,SAAQgG,EAAO0N,GAEX,GAAK1N,IAAS5G,KAAKogB,WAAnB,CAIA,IAAM1W,EAAO9C,EAAM2D,QAAQ,gBACrBuX,EAAYpY,EAAK3C,QAAQH,MAG/B5G,KAAKsE,SAASI,QAAQ,GAADlD,OAAIsgB,EAAS,UAAU,CACxClf,QAAS8G,GAPb,CAUJ,GAEA,CAAA/I,IAAA,WAAAC,MAMA,SAAS0T,GACLtU,KAAKigB,qBACT,GAEA,CAAAtf,IAAA,WAAAC,MAMA,SAAS0T,GACLtU,KAAKigB,qBACT,GAEA,CAAAtf,IAAA,YAAAC,MAQA,SAAUgC,EAASe,GAAO,IAAAoe,EAAA,KAGlBrY,EAIA/F,EAJA+F,KACAsY,EAGAre,EAHAqe,QACAC,EAEAte,EAFAse,QACAC,EACAve,EADAue,cAEJC,EAGIvf,EAAQ4d,wBAFR/R,EAAI0T,EAAJ1T,KACAtE,EAAGgY,EAAHhY,IAGJnK,KAAK6hB,cACL7hB,KAAKmgB,YAAc,SAACxc,GAAK,OAAKoe,EAAKK,WAAWxf,EAASe,EAAM,EAEhD,cAAT+F,GAEA1J,KAAKqgB,QAAU2B,EAAUvT,EAAOzO,KAAKygB,QACrCzgB,KAAKsgB,QAAU2B,EAAU9X,EAAMnK,KAAK0gB,OACpC7S,OAAOxK,iBAAiB,YAAarD,KAAKmgB,cAE1B,eAATzW,GAAyBwY,EAAcrY,SAE9C7J,KAAKqgB,QAAU6B,EAAc,GAAGF,QAAUvT,EAAOzO,KAAKygB,QACtDzgB,KAAKsgB,QAAU4B,EAAc,GAAGD,QAAU9X,EAAMnK,KAAK0gB,OACrD7S,OAAOxK,iBAAiB,YAAarD,KAAKmgB,YAAa,CACnDkC,SAAS,IAKrB,GAEA,CAAA1hB,IAAA,aAAAC,MAQA,SAAWgC,EAASe,GAEhBA,EAAM4Q,iBAEN,IACI7K,EAIA/F,EAJA+F,KACAsY,EAGAre,EAHAqe,QACAC,EAEAte,EAFAse,QACAC,EACAve,EADAue,cAEJI,EAGI1f,EAAQ4d,wBAFRI,EAAK0B,EAAL1B,MACA5Q,EAAMsS,EAANtS,OAEAuS,EAAY,EACZC,EAAW,EAEF,cAAT9Y,GAEA6Y,EAAYP,EAAUhiB,KAAKqgB,QAC3BmC,EAAWP,EAAUjiB,KAAKsgB,QAC1BtgB,KAAKogB,YAAa,GAEF,cAAT1W,GAAwBwY,EAAcrY,SAE7C0Y,EAAYL,EAAc,GAAGF,QAAUhiB,KAAKqgB,QAC5CmC,EAAWN,EAAc,GAAGD,QAAUjiB,KAAKsgB,SAI/CtgB,KAAKyiB,OACD7f,EACAsW,GAAM,EAAGqJ,EAAWviB,KAAK2gB,SAAWC,GACpC1H,GAAM,EAAGsJ,EAAUxiB,KAAK6gB,UAAY7Q,GAG5C,GAEA,CAAArP,IAAA,SAAAC,MAaA,SAAOgC,EAAS6L,EAAMtE,EAAKuE,GAEvB9L,EAAQmJ,MAAMC,YAAY,SAAUyC,GACpC7L,EAAQmJ,MAAMC,YAAY,QAAS7B,IAEb,iBAAXuE,GAAuB6K,OAAOmJ,MAAMhU,MAC3CA,EAAS1O,KAAK0O,QAGlB9L,EAAQmJ,MAAMC,YAAY,YAAa0C,GAEvC1O,KAAKsE,SAASI,QAAQ,OAAQ,CAC1B9B,QAAAA,EACA6L,KAAAA,EACAtE,IAAAA,EACAuE,OAAAA,GAGR,GAEA,CAAA/N,IAAA,cAAAC,MAQA,SAAYgC,GAiBR,MANc,CACV+f,EAAGpJ,OAAO3W,EAAQmJ,MAAM6W,iBAAiB,YAAc,EACvDC,EAAGtJ,OAAO3W,EAAQmJ,MAAM6W,iBAAiB,WAAa,EACtDE,EAAGvJ,OAAO3W,EAAQmJ,MAAM6W,iBAAiB,eAAiB,EAKlE,GAEA,CAAAjiB,IAAA,cAAAC,MAGA,WAAc,IAAAmiB,EAAA,KAEN/iB,KAAKmgB,cAAgBN,KAErBhS,OAAOvK,oBAAoB,YAAatD,KAAKmgB,aAC7CtS,OAAOvK,oBAAoB,YAAatD,KAAKmgB,YAAa,CACtDkC,SAAS,IAEbriB,KAAKmgB,YAAcN,GAOnBhS,OAAOsT,sBAAsB,kBAAM4B,EAAK3C,YAAa,CAAK,GAIlE,IAAC,CAzcsB,G,mtDCVE,IAER4C,GAAU,WAoF3B,O,4GAAAjgB,CANA,SAAAigB,K,4FAAcjjB,CAAA,KAAAijB,GAEVhjB,KAAKijB,aAET,EAEA,EAAAtiB,IAAA,cAAAC,MAGA,WAEI,IAAMsiB,EAAU,CACZtC,MAAO,EACP5Q,OAAQ,GAGZhQ,KAAKmjB,iBAAiBD,GACtBljB,KAAKojB,aAAaF,GAClBljB,KAAKqjB,SAAS,EAElB,GAEA,CAAA1iB,IAAA,mBAAAC,MAUA,SAAgB0B,GAAoB,IAAjBse,EAAKte,EAALse,MAAO5Q,EAAM1N,EAAN0N,OAMtBhQ,KAAK4gB,MAAQrH,OAAOqH,IAAU,EAM9B5gB,KAAKgQ,OAASuJ,OAAOvJ,IAAW,CAEpC,GAEA,CAAArP,IAAA,eAAAC,MAUA,SAAY2B,GAAoB,IAAjBqe,EAAKre,EAALqe,MAAO5Q,EAAMzN,EAANyN,OAMlBhQ,KAAKsjB,WAAa/J,OAAOqH,IAAU,EAMnC5gB,KAAKujB,YAAchK,OAAOvJ,IAAW,CAEzC,GAEA,CAAArP,IAAA,WAAAC,MAMA,SAAS6a,GAMLzb,KAAKyb,MAAQlC,OAAOkC,IAAU,CAElC,GAEA,CAAA9a,IAAA,YAAAC,MAOA,SAAU4iB,GACNxjB,KAAKwjB,OAASA,CAClB,GAEA,CAAA7iB,IAAA,UAAAC,MAMA,WAEI,OAAOM,OAAOkM,OAAO,CACjBwT,MAAO5gB,KAAK4gB,MACZ5Q,OAAQhQ,KAAKgQ,OACbsT,WAAYtjB,KAAKsjB,WACjBC,YAAavjB,KAAKujB,YAClB9H,MAAOzb,KAAKyb,OAGpB,GAEA,CAAA9a,IAAA,iBAAAC,MASA,WAEI,IAEQ6iB,EAGJzjB,KAJAG,YACIsjB,QAEJD,EACAxjB,KADAwjB,OAEEzM,EAAS0M,EAAQD,GAEvB,IAAKzM,EACD,MAAM,IAAIxV,eAAe,6BAADC,OAA8BgiB,EAAM,MAGhE,OAAOzM,EAAO/W,KAAKS,UAEvB,IAAC,CA9N0B,G,mtDA8N1BijB,GA9NgBV,G,oHAEjBjf,CAFiBif,GAAU,UAMV,CAGbW,QAAO,SAAC7jB,GAEJ,IACI8gB,EAKA9gB,EALA8gB,MACA5Q,EAIAlQ,EAJAkQ,OACAsT,EAGAxjB,EAHAwjB,WACAC,EAEAzjB,EAFAyjB,YACA9H,EACA3b,EADA2b,MAEEmI,EAAc,GACdC,GAAWjD,EAAQ0C,GAAc,EACjCQ,GAAW9T,EAASuT,GAAe,EAEzC,SAASQ,EAAGC,GACR,OAAO7K,KAAK8K,KAAM9K,KAAA+K,IAACL,EAAU1K,KAAKgL,IAAIH,GAAa,GAAC7K,KAAA+K,IAAIJ,EAAU3K,KAAKiL,IAAIJ,GAAa,GAC5F,CAIA,IAHA,IACIK,GAAoB,GAAXlL,KAAKmL,GACdC,EAAO,EACFP,EAAU,EAAIK,EAAQL,EAAqB,EAAV7K,KAAKmL,GAASD,EAASL,GAHjD,KAIZO,GAAQR,EAAGC,GAEf,IAAIQ,EAAY,EACZC,EAAM,EACV,IAAST,EAAU,EAAIK,EAAQL,EAAqB,EAAV7K,KAAKmL,GAASD,EAASL,GARjD,KAQuE,CACnF,GAAKvI,EAAQgJ,EAAMF,GAASC,EAAW,CACnCA,IACA,IAAIE,EAASb,EAAW1K,KAAKiL,IAAIJ,GAAWH,EACxCc,EAASb,EAAW3K,KAAKgL,IAAIH,GAAWF,EAC5CF,EAAYrc,KAAK,CAACmd,EAAQC,GAC9B,CACAF,GAAOV,EAAGC,EACd,CAEA,OAAOJ,CAEX,EAEAgB,SAAQ,SAAC9kB,GAEL,IACI8gB,EAKA9gB,EALA8gB,MACA5Q,EAIAlQ,EAJAkQ,OACAsT,EAGAxjB,EAHAwjB,WACAC,EAEAzjB,EAFAyjB,YACA9H,EACA3b,EADA2b,MAEEmI,EAAc,GACdiB,GAAcjE,EAAQ0C,GAAc7H,EACpCqJ,GAAc9U,EAASuT,GAAe9H,EAM5C,OAJAjC,GAAMiC,EAAO,SAACrQ,GACVwY,EAAYxY,GAAS,CAACyZ,EAAazZ,EAAO0Z,EAAa1Z,EAC3D,GAEOwY,CAEX,EAEAmB,WAAU,SAACjlB,GACP,OAAOkjB,GAAWS,QAAQmB,SAAS9kB,GAAMwS,IAAI,SAAAmB,GAAA,IAAA7D,EAAApN,GAAAiR,EAAA,GAAEkP,EAAC/S,EAAA,GAAGA,EAAA,SAAM,CAAC+S,EAAG,EAAE,EACnE,EAEAqC,SAAQ,SAACllB,GACL,OAAOkjB,GAAWS,QAAQmB,SAAS9kB,GAAMwS,IAAI,SAAAuD,GAAA,IAAA9B,EAAAvR,GAAAqT,EAAA,GAAG9B,EAAA,GAAG,MAAM,CAAC,EAAPA,EAAA,GAAY,EACnE,IC/DR,IAGqBkR,GAAG,WA2FpB,O,4GAAAliB,CA7DA,SAAAkiB,EAAYriB,EAAS0B,I,4FAAUvE,CAAA,KAAAklB,GAM3BjlB,KAAK4C,QAAUA,EAMf5C,KAAKsE,SAAWA,EAMhBtE,KAAKyN,OAAS,IAAIsS,GAAOnd,EAAS0B,GAMlCtE,KAAK6B,SAAWD,EAASiB,QAAO2J,EAAAA,EAAAA,IAAU,oBAQ1CxM,KAAKmJ,WAAa,GAMlBnJ,KAAKkI,UAAY,GAMjBlI,KAAKklB,WAAa,KAMlBllB,KAAKmlB,OAAS,GAOdnlB,KAAK+Z,WAAa,IAEtB,EAEA,EAAApZ,IAAA,gBAAAC,MAUA,SAAcoE,GAEV,IACIpC,EAGA5C,KAHA4C,QACAuG,EAEAnJ,KAFAmJ,WACAtH,EACA7B,KADA6B,SAGJe,EAAQuE,OACJtF,EAAS0D,KAAK,CACV,sBAAqB,SAAC3C,GAElBA,EAAQuE,OAAOnC,EAAUoC,aACzBxE,EAAQmE,QAAQH,MAAQ,WAE5B,KAIR,IAAMA,EAAQhE,EAAQsJ,iBAChBkZ,EAAOlkB,OAAOkM,OAAO,CACvBpI,UAAAA,EACA4B,MAAAA,IAKJ,OAFAuC,EAAW5B,KAAK6d,GAETA,CAEX,GAEA,CAAAzkB,IAAA,eAAAC,MAQA,SAAaoE,GAET,IAAMogB,EAAOplB,KAAKqlB,cAAcrgB,GAGhC,OAFAhF,KAAKsE,SAASI,QAAQ,gBAAiB0gB,GAEhCA,CAEX,GAEA,CAAAzkB,IAAA,kBAAAC,MASA,SAAgBoE,GAEZ,IACIyI,EAMAzN,KANAyN,OACAtE,EAKAnJ,KALAmJ,WACAgc,EAIAnlB,KAJAmlB,OAEIG,EAEJtlB,KAHAG,YACImlB,OAIR,IAAKH,EACD,MAAM,IAAI9S,MAAM,wCAGpB,IAAM+S,EAAOplB,KAAKulB,aAAavgB,GAEzBoG,EAAQjC,EAAWU,OAAS,EAIqBtH,EAAAC,IAAlD2iB,aAAM,EAANA,EAAS/Z,KAAU,CAACka,EAASla,EAAOka,EAAQla,GAAM,GAFnDqD,EAAIlM,EAAA,GACJ4H,EAAG5H,EAAA,GAUP,OAPAkL,EAAOgV,OACH2C,EAAKxe,MACL6H,EACAtE,EACAsD,EAAOmU,iBAGJwD,CAEX,GAEA,CAAAzkB,IAAA,YAAAC,MAYA,SAAUgG,EAAO6H,EAAMtE,EAAKuE,GACxB1O,KAAKyN,OAAOgV,OAAO7b,EAAO6H,EAAMtE,EAAKuE,EACzC,GAEA,CAAA/N,IAAA,mBAAAC,MAQA,SAAiBgG,GACb,OAAO5G,KAAKyN,OAAO+X,YAAY5e,EACnC,GAEA,CAAAjG,IAAA,kBAAAC,MAQA,SAAgBoE,GAEZ,IACImE,EAEAnJ,KAFAmJ,WACAsc,EACAzlB,KADAylB,kBAEEra,EAAQjC,EACTyM,UAAU,SAACwP,GAAI,OAAKA,EAAKpgB,YAAcA,CAAS,GAErD,KAAIoG,EAAQ,GAAZ,CAIA,IACIxE,EACAuC,EAAWiC,GADXxE,MASJ,OANAA,EAAM6F,SAEDgZ,GACDtc,EAAWqF,OAAOpD,EAAO,GAGtBxE,CAZP,CAcJ,GAEA,CAAAjG,IAAA,kBAAAC,MAMA,SAAgBoE,GAEZ,IAAM4B,EAAQ5G,KAAK0lB,gBAAgB1gB,GAE/B4B,GAEA5G,KAAKsE,SAASI,QAAQ,mBAAoB,CACtCM,UAAAA,EACA4B,MAAAA,GAKZ,GAEA,CAAAjG,IAAA,sBAAAC,MASA,SAAoBgG,GAAO,IAAA+e,EACvB,OAA2D,QAA3DA,EAAO3lB,KAAKmJ,WAAWW,KAAK,SAACsb,GAAI,OAAKA,EAAKxe,QAAUA,CAAK,UAAC,IAAA+e,OAAA,EAApDA,EAAsD3gB,SACjE,GAEA,CAAArE,IAAA,yBAAAC,MAOA,SAAuBgG,GACnB5G,KAAK4lB,gBAAgB5lB,KAAK6lB,oBAAoBjf,GAClD,GAEA,CAAAjG,IAAA,qBAAAC,MAQA,SAAmBoE,GACf,OAAOhF,KAAKmJ,WAAWW,KAAK,SAACsb,GAAI,OAAKA,EAAKpgB,YAAcA,CAAS,EACtE,GAEA,CAAArE,IAAA,aAAAC,MAQA,SAAWoE,EAAW8gB,GAElB,IACIlf,GACA5G,KAAK+lB,mBAAmB/gB,IAAc,CAAC,GADvC4B,MAGJ,GAAKA,EAAL,CAIA,IAAMyB,EAASrD,EAAUghB,WAAWF,GACpC9lB,KAAKG,YACA8lB,SAASrf,GACTK,UACAC,OAAO,UAAWmB,GACvBrI,KAAKsE,SAASI,QAAQ,gBAAiB,CACnC2D,OAAAA,EACAzB,MAAAA,EACA5B,UAAAA,IAKCqD,GACDrI,KAAK6O,aAAa7J,GAAW,EAhBjC,CAmBJ,GAEA,CAAArE,IAAA,oBAAAC,MAUA,SAAkBgG,EAAOkf,GACrB9lB,KAAKgmB,WAAWhmB,KAAK6lB,oBAAoBjf,GAAQkf,EACrD,GAEA,CAAAnlB,IAAA,SAAAC,MAQA,SAAOoE,EAAWkhB,GAEd,IACItf,GACA5G,KAAK+lB,mBAAmB/gB,IAAc,CAAC,GADvC4B,MAGJ,GAAKA,EAAL,CAIA,IAAM0B,EAAetD,EAAUmhB,OAAOD,GACtClmB,KAAKG,YACA8lB,SAASrf,GACTK,UACAC,OAAO,iBAAkBoB,GAC9BtI,KAAKsE,SAASI,QAAQ,gBAAiB,CACnC4D,aAAAA,EACA1B,MAAAA,EACA5B,UAAAA,GAVJ,CAaJ,GAEA,CAAArE,IAAA,gBAAAC,MAUA,SAAcgG,EAAOsf,GACjBlmB,KAAKmmB,OAAOnmB,KAAK6lB,oBAAoBjf,GAAQsf,EACjD,GAEA,CAAAvlB,IAAA,gBAAAC,MASA,SAAcoE,GAEV,IAAMogB,EAAOplB,KAAKmJ,WAAWW,KAAK,SAACsb,GAAI,OAAKA,EAAKpgB,YAAcA,CAAS,GAExE,IAAKogB,EACD,MAAO,GAGX,IAAMgB,GAAUhS,EAAAA,EAAAA,IACZ,8BACApU,KAAKG,YAAY8lB,SAASb,EAAKxe,QAGnC,OAAOwf,aAAO,EAAPA,EAAS3gB,cAAe,EAEnC,GAEA,CAAA9E,IAAA,wBAAAC,MASA,SAAsBgG,GAClB,OAAO5G,KAAKqmB,cAAcrmB,KAAK6lB,oBAAoBjf,GACvD,GAEA,CAAAjG,IAAA,gBAAAC,MAQA,SAAcoE,EAAWnB,GAErB,IACI+C,GACA5G,KAAK+lB,mBAAmB/gB,IAAc,CAAC,GADvC4B,MAGJ,GAAKA,EAAL,CAIA,IAAMwf,GAAUhS,EAAAA,EAAAA,IACZ,8BACApU,KAAKG,YAAY8lB,SAASrf,IAGzBwf,IAILviB,GAAQA,GAAQ,IAAI+a,OACpBwH,EAAQ3gB,YAAc5B,EACtB7D,KAAKsE,SAASI,QAAQ,kBAAmB,CACrCb,KAAAA,EACA+C,MAAAA,EACA5B,UAAAA,IAhBJ,CAmBJ,GAEA,CAAArE,IAAA,wBAAAC,MASA,SAAsBgG,EAAO/C,GACzB7D,KAAK6e,cAAc7e,KAAK6lB,oBAAoBjf,GAAQ/C,EACxD,GAEA,CAAAlD,IAAA,eAAAC,MAQA,SAAaoE,EAAWshB,GAIpB,GAAKA,GAAmBthB,EAAU+D,YAAlC,CAIA,IACInC,GACA5G,KAAK+lB,mBAAmB/gB,IAAc,CAAC,GADvC4B,MAGJ,GAAKA,EAAL,CAIA,IAAM2B,EAAevD,EAAU8D,gBAAgBwd,GAC/CtmB,KAAKG,YACA8lB,SAASrf,GACTK,UACAC,OAAO,eAAgBqB,GAC5BvI,KAAKsE,SAASI,QAAQ,oBAAqB,CACvC6D,aAAAA,EACA3B,MAAAA,EACA5B,UAAAA,GAVJ,CARA,CAqBJ,GAEA,CAAArE,IAAA,uBAAAC,MAUA,SAAqBgG,EAAO0f,GACxBtmB,KAAK6O,aAAa7O,KAAK6lB,oBAAoBjf,GAAQ0f,EACvD,GAEA,CAAA3lB,IAAA,cAAAC,MAQA,SAAYyG,GAER,IACIzE,EAIA5C,KAJA4C,QACAsF,EAGAlI,KAHAkI,UACA5D,EAEAtE,KAFAsE,SACAzC,EACA7B,KADA6B,SAGJe,EAAQuE,OACJtF,EAAS0D,KAAK,CACV,sBAAqB,SAAC3C,GAElBA,EAAQuE,OAAOE,EAASD,aACxBxE,EAAQmE,QAAQH,MAAQ,WACxBhE,EAAQmE,QAAQM,SAAWA,EAASjC,OAExC,KAIR,IAAMwB,EAAQhE,EAAQsJ,iBAChBkZ,EAAOlkB,OAAOkM,OAAO,CACvB/F,SAAAA,EACAT,MAAAA,IAMJ,OAHAsB,EAAUX,KAAK6d,GACf9gB,EAASI,QAAQ,eAAgB0gB,GAE1BA,CAEX,GAEA,CAAAzkB,IAAA,iBAAAC,MAMA,SAAeyG,GAEX,IACIa,EAEAlI,KAFAkI,UACA5D,EACAtE,KADAsE,SAEE8G,EAAQlD,EAAU0N,UAAU,SAACwP,GAAI,OAAKA,EAAK/d,WAAaA,CAAQ,GAEtE,KAAI+D,EAAQ,GAAZ,CAIA,IACIxE,EACAsB,EAAUkD,GADVxE,MAGJA,EAAM6F,SAEDzM,KAAKylB,mBACNvd,EAAUsG,OAAOpD,EAAO,GAG5B9G,EAASI,QAAQ,kBAAmB,CAChC2C,SAAAA,EACAT,MAAAA,GAdJ,CAiBJ,GAEA,CAAAjG,IAAA,qBAAAC,MAUA,SAAmBgG,GAAO,IAAA2f,EACtB,OAA0D,QAA1DA,EAAOvmB,KAAKkI,UAAU4B,KAAK,SAACsb,GAAI,OAAKA,EAAKxe,QAAUA,CAAK,UAAC,IAAA2f,OAAA,EAAnDA,EAAqDlf,QAChE,GAEA,CAAA1G,IAAA,wBAAAC,MAOA,SAAsBgG,GAClB5G,KAAKwmB,eAAexmB,KAAKymB,mBAAmB7f,GAChD,GAEA,CAAAjG,IAAA,QAAAC,MAIA,WAAQ,IAAAyE,EAAA,KAGA8D,EAEAnJ,KAFAmJ,WACAjB,EACAlI,KADAkI,UAWJlI,KAAKylB,mBAAoB,EAEzBtc,EAAW9G,QAAQ,SAAA8R,GAAmB,IAAhBnP,EAASmP,EAATnP,UAClBK,EAAKugB,gBAAgB5gB,EACzB,GACAmE,EAAWU,OAAS,EAEpB3B,EAAU7F,QAAQ,SAAAqS,GAAkB,IAAfrN,EAAQqN,EAARrN,SACjBhC,EAAKmhB,eAAenf,EACxB,GACAa,EAAU2B,OAAS,EAEnB7J,KAAKylB,mBAAoB,EAEzBzlB,KAAKyN,OAAOuS,OAEhB,GAEA,CAAArf,IAAA,mBAAAC,MAIA,WACIZ,KAAKyN,OAAOwS,qBAChB,GAEA,CAAAtf,IAAA,YAAAC,MAOA,SAAU8N,GACN1O,KAAKyN,OAAOiZ,UAAUhY,EAC1B,GAEA,CAAA/N,IAAA,gBAAAC,MAMA,SAAcskB,GACVllB,KAAKklB,WAAaA,CACtB,GAEA,CAAAvkB,IAAA,iBAAAC,MAIA,WACIZ,KAAKmlB,OAASnlB,KAAKklB,WAAWyB,gBAClC,GAEA,CAAAhmB,IAAA,mBAAAC,MAMA,WAEI,IAAAgmB,EAGI5mB,KAAK4C,QAAQ4d,wBAEjB,MAAO,CACHI,MALKgG,EAALhG,MAMA5Q,OALM4W,EAAN5W,OAQR,GAEA,CAAArP,IAAA,gBAAAC,MAMA,SAAcmZ,GACV/Z,KAAK+Z,WAAaA,CACtB,GAEA,CAAApZ,IAAA,qBAAAC,MAMA,WAEI,IAAMimB,EAAa,CACfjG,MAAO,EACP5Q,OAAQ,GAGZ,IAAKhQ,KAAK+Z,WAGN,OADA+M,QAAQC,KAAK,wDACNF,EAIX,IAAMG,EAAchnB,KAAK+Z,WAAWkN,oBAEhCrgB,EACA5G,KAAKqlB,cAAc2B,GADnBpgB,MAEJsgB,EAGItgB,EAAM4Z,wBAFC8C,EAAU4D,EAAjBtG,MACQ2C,EAAW2D,EAAnBlX,OAKEmX,EAAQ5N,OACV1L,OAAOuZ,iBAAiBxgB,EAAO,MAAMgc,iBAAiB,iBACnD,GAEDyE,EAAiBzgB,EAAMiX,cAAc,kBACrCyJ,EAASzZ,OAAOuZ,iBAAiBC,EAAgB,MAEjDE,EAAeD,EAAO1E,iBAAiB,mBACzC4E,EAAeC,WAAWF,GAAgBJ,EAW9C,MATmD,OAA/CI,EAAa3I,OAAO9d,QAAQ,UAAW,MACvC0mB,GAAgBC,WAAWH,EAAO1E,iBAAiB,eAGvDiE,EAAWjG,MAAQ0C,EAAakE,EAChCX,EAAW7W,OAASuT,EAAciE,EAElCxnB,KAAK0lB,gBAAgBsB,GAEdH,CAEX,GAEA,CAAAlmB,IAAA,mBAAAC,MAmBA,SAAgBkU,GAAwD,IR9sBlDlU,EAEhB8mB,EQ4sBaC,EAAS7S,EAAT6S,UAAWla,EAAMqH,EAANrH,OAAQgO,EAAK3G,EAAL2G,MAAO+H,EAAM1O,EAAN0O,OAAMoE,EAAA9S,EAAE+S,SAAAA,OAAQ,IAAAD,GAAOA,EAG5D1C,EACAllB,KADAklB,WAGJ,IAAKA,EACD,MAAM,IAAI3jB,eAAe,mCAGzBomB,GACAzC,EAAW/B,iBAAiBnjB,KAAK8nB,oBAGjCra,GACAyX,EAAW9B,aAAapjB,KAAK+nB,sBAG7BvE,GACA0B,EAAW8C,UAAUxE,GAGrB/H,IRpuBc7a,EQouBK6a,ERluBrBiM,EAAS7Z,OAAO4Z,WAAW7mB,IAEzB2Y,OAAOmJ,MAAMgF,IAAWnO,OAAO0O,SAASP,KQiuBxCxC,EAAW7B,SAAS5H,GAGpBoM,GACA7nB,KAAK2mB,gBAGb,IAAC,EAAAhmB,IAAA,WAAAC,MA70BD,SAAgBkL,GAEZ,IAAMlF,GAAQwN,EAAAA,EAAAA,IAAgB,iBAAkBtI,GAEhD,IAAKlF,EACD,MAAM,IAAIrF,eAAe,kCAG7B,OAAOqF,CAEX,IAAC,CAtBmB,GCLlBmM,GAAejQ,EAASD,OAAO,QAC/BmY,GAAgBlY,EAASD,OAAO,SAEhCqlB,IAAa9T,EAAAA,EAAAA,IAAgB,YAC7BsK,GAAM,IAAIuG,GAAIiD,GAAYlN,IAChCkN,GAAWxJ,IAAMA,GAEK,IAAI7J,iBAAiB,SAACsT,GAExCpV,GAAarO,QAAQ,oBAAqB,CACtCsL,OAAQmY,EAAU,GAAG7nB,OAAOyL,MAAMiE,QAG1C,GAEcsF,QAAQ4S,GAAY,CAC9B3S,YAAY,EACZC,gBAAiB,CAAC,YAKtB7S,EAAAA,EAAAA,IAAO,WAAWN,QAAQ,SAACsN,GAEvBA,EAAQtM,iBAAiB,SAAU,WAC/Bqb,GAAI0J,kBACR,EAEJ,GAEArV,GAAanF,GAAG,sBAAuB,SAAAtL,GAAgB,IAE7C6G,EAFsC7G,EAANiB,OAEZ4F,WAAWI,OAAO,SAACvE,GACzC,IAAM6C,EAAO7C,EAAU4W,UACvB,MAAgB,WAAT/T,GAA8B,cAATA,CAChC,IAEAqU,EAAAA,EAAAA,KACI9H,EAAAA,EAAAA,IAAgB,yBAChBjL,EAAWmJ,IAAI,SAACtN,GAAS,OAAKA,EAAUqjB,UAAU,IAGtD,IAAMngB,EAAYiB,EAAW0S,OAAO,SAAC3T,EAAWlD,GAC5C,OAAOkD,EAAU1G,OAAOwD,EAAU0D,eACtC,EAAG3C,EAAcuiB,cAEjBpM,EAAAA,EAAAA,KACI9H,EAAAA,EAAAA,IAAgB,wBAChBlM,EAAUoK,IAAI,SAACjL,GAAQ,OAAKA,EAASghB,UAAU,KAGnDjU,EAAAA,EAAAA,IAAgB,cAAcmI,UAAW,GACzCnI,EAAAA,EAAAA,IAAgB,iBAAiBmI,UAAW,GAC5CnI,EAAAA,EAAAA,IAAgB,gBAAgBmI,UAAW,CAE/C,GAEAxJ,GAAanF,GAAG,kBAAmB,SAAArL,GAAgB,IAAbgB,EAAMhB,EAANgB,OAClCmb,GAAI6J,gBAAgBhlB,EAAOyB,UAC/B,IAEAwH,EAAAA,EAAAA,IAAU,qBAAqBnJ,iBAAiB,SAAU,SAAAoQ,GAAgB,IAAbnT,EAAMmT,EAANnT,OAEzD4nB,GAAWnc,MACPzL,EAAO8O,QACL,iBACA,eACJ,wBAAyB,OAE/B,GAEA2D,GAAanF,GAAG,QAAS,kBAAM8Q,GAAIsB,OAAO,GAI1C,IAAMwI,GAAOvlB,SAAS2O,iBAEtBpF,EAAAA,EAAAA,IAAU,eAAenJ,iBAAiB,QAAS,SAAAuM,GAAgB,IAAbtP,EAAMsP,EAANtP,OAClDkoB,GAAKzc,MAAMC,YAAY,eAAgB1L,EAAOM,MAClD,IAEA4L,EAAAA,EAAAA,IAAU,kBAAkBnJ,iBAAiB,QAAS,SAAAwS,GAAgB,IAAbvV,EAAMuV,EAANvV,OACrDkoB,GAAKzc,MAAMC,YAAY,kBAAmB1L,EAAOM,MACrD,GAIA8d,GAAI+J,cAAc,IAAIzF,IAEtB,IAAM0F,IAAclc,EAAAA,EAAAA,IAAU,iB,+sBAE9BkS,GAAIiK,iBAAiB,CACjBnF,OAAQkF,GAAY9nB,MAIpBinB,UAAU,IAGda,GAAYrlB,iBAAiB,SAAU,WACnCqb,GAAIiK,iBAAiB,CAAEnF,OAAQkF,GAAY9nB,OAC/C,GAEAmS,GAAanF,GAAG,eAAgB,SAAAmG,GAAgB,IAAbxQ,EAAMwQ,EAANxQ,OAC/Bmb,GAAIiK,iBAAiB,CAAElN,MAAOlY,EAAO2X,OACzC,GAEAnI,GAAanF,GAAG,oBAAqB,WACjC8Q,GAAIiK,iBAAiB,CAAEhB,WAAW,GACtC,GAEA3T,GAAAA,EAAOnR,QAAOuR,EAAAA,EAAAA,IAAgB,sBAAsBxG,GAAGoG,GAAAA,EAAOwK,KAAM,WAEhE,IAAMoK,GAAkBxU,EAAAA,EAAAA,IAAgB,aAClCyU,EAASD,EAAgB/Y,KAE1BgZ,IACDD,EAAgB/Y,MAAO,GAG3B6O,GAAIiK,iBAAiB,CACjBhB,WAAW,EACXla,QAAQ,EACRgO,OAAOrH,EAAAA,EAAAA,IAAgB,iBAAiBxT,QAGvCioB,IACDD,EAAgB/Y,MAAO,EAG/B,GAEAS,GAAWlM,MAAM,SAAC2V,GACd2E,GAAIoK,cAAc/O,EACtB,GCnJA,IAGqBgP,GAAW,WAY5B,O,4GAAAhmB,CAVA,SAAAgmB,K,4FAAchpB,CAAA,KAAAgpB,GAMV/oB,KAAK8G,KAAO,EAEhB,EAEA,EAAAnG,IAAA,MAAAC,MAMA,SAAIuM,GACAnN,KAAK8G,KAAKS,KAAK4F,EACnB,GAEA,CAAAxM,IAAA,MAAAC,MAQA,SAAIuM,GACA,OAAOnN,KAAK8G,KAAKkI,SAAS7B,EAC9B,GAEA,CAAAxM,IAAA,YAAAC,MAOA,SAAUuM,GAEDnN,KAAKgpB,IAAI7b,IACVnN,KAAKme,IAAIhR,EAGjB,GAEA,CAAAxM,IAAA,SAAAC,MAOA,SAAOuM,GAEH,IAAM/B,EAAQpL,KAAK8G,KAAKyH,QAAQpB,GAE5B/B,GAAS,GACTpL,KAAK8G,KAAK0H,OAAOpD,EAAO,EAGhC,GAEA,CAAAzK,IAAA,OAAAC,MAOA,WACI,OAAOZ,KAAK8G,KAAK9G,KAAK8G,KAAK+C,OAAS,EACxC,IAEA,EAAAlJ,IAAA,UAAAC,MAWA,SAAeqoB,EAASlS,GAEpB,GAAiC,mBAAtBkS,aAAO,EAAPA,EAAUlS,IAAwB,SAAAiK,EAAA9a,UAAA2D,OAFdoX,EAAI,IAAArX,MAAAoX,EAAA,EAAAA,EAAA,KAAAE,EAAA,EAAAA,EAAAF,EAAAE,IAAJD,EAAIC,EAAA,GAAAhb,UAAAgb,GAG/B+H,EAAQlS,GAAOqK,MAAf6H,EAAmBhI,EACvB,CAEJ,IAAC,CA9F2B,G,qzDCGhC,IAGqBiI,GAAY,SAAAC,GAK7B,SAAAD,EAAYjd,GAAQ,IAAA5G,EAQqB,O,4FARrBtF,CAAA,KAAAmpB,IAEhB7jB,EAAAY,GAAA,KAAAijB,EAAA,CAAMjd,KAMDmd,YAAc,IAAIL,GAAc1jB,CAEzC,CAEA,O,sRAAAc,CAAA+iB,EAAAC,G,4GAAApmB,CAAAmmB,EAAA,EAAAvoB,IAAA,aAAAC,MAOA,SAAWqoB,GACPjpB,KAAKopB,YAAYC,UAAUJ,EAC/B,GAEA,CAAAtoB,IAAA,gBAAAC,MAOA,SAAcqoB,GACVjpB,KAAKopB,YAAY3c,OAAOwc,EAC5B,GAEA,CAAAtoB,IAAA,eAAAC,MAGA,WAAe,IAAAwJ,EAAA,M,0HAEX3B,CAAAygB,EAAA,sBAAAzgB,CAAA,IAEAzI,KAAKiM,OAAO5I,iBAAiB,QAAS,SAAAf,GAAgB,IAE5CwJ,EAFqCxJ,EAANhC,OAEfiK,QAAQ,mBAEzBuB,GAILid,GAAYO,QACRlf,EAAKgf,YAAYG,OACjB,QACAzd,EAAO/E,QAAQsD,QAGvB,GAEArK,KAAK4N,GAAG5N,KAAKG,YAAY4a,KAAM,WAC3BgO,GAAYO,QAAQlf,EAAKgf,YAAYG,OAAQ,OACjD,EAEJ,IAEA,EAAA5oB,IAAA,MAAAC,MAOA,WACI,OAAOZ,KAAK6C,QAAOuR,EAAAA,EAAAA,IAAgB,mBACvC,IAAC,CA7E4B,CAASJ,GAAAA,G,+sBCT1C,IAGqBwV,GAAa,WA4D9B,O,4GAAAzmB,CAlDA,SAAAymB,EAAY1jB,EAAOoJ,GAoBf,G,4FApBsBnP,CAAA,KAAAypB,GAMtBxpB,KAAK8F,MAAQA,EAMb9F,KAAKkP,MAAQA,EAMblP,KAAK8G,KAAOoI,EAAMpI,MAEb9G,KAAK8F,QAAU9F,KAAKkP,QAAUlP,KAAK8G,KACpC,MAAM,IAAIuL,MAAM,0CAQpBrS,KAAKmP,KAAOD,EAAMC,KAOlBnP,KAAKypB,MAAQzpB,KAAK8G,KAAK+W,cAAc,8BACrC7d,KAAKypB,MAAM7oB,MAAQkF,EAAML,YAOzBzF,KAAK0pB,SAAW1pB,KAAK8G,KAAK+W,cAAc,iCAExC7d,KAAKkgB,cAET,EAEA,EAAAvf,IAAA,eAAAC,MAGA,WAAe,IAAAyE,EAAA,KAGPS,EAGA9F,KAHA8F,MACAoJ,EAEAlP,KAFAkP,MACAC,EACAnP,KADAmP,KAGJrJ,EAAMzC,iBAAiB,QAAS,WAE5BgC,EAAKskB,YACLza,EAAM0a,OAEV,GAEA1a,EAAM7L,iBAAiB,QAAS,WAC5B6L,EAAMtO,MAAQ,EAClB,GAEAsO,EAAM7L,iBAAiB,OAAQ,WAE3BgC,EAAKwkB,YACLxkB,EAAKykB,gBAET,GAEA5a,EAAM7L,iBAAiB,QAAS,WAE5BgC,EAAK0kB,SAAS7a,EAAMtO,OACpByE,EAAK2kB,gBAET,GAEA7a,SAAAA,EAAM9L,iBAAiB,SAAU,SAACiR,GAE9BA,EAAEC,iBACFD,EAAE2V,kBACF/a,EAAMgb,MAEV,EAEJ,GAEA,CAAAvpB,IAAA,iBAAAC,MAOA,WACI,OAAQZ,KAAKkP,MAAM5C,MACvB,GAEA,CAAA3L,IAAA,cAAAC,MAWA,SAAY2D,GAMR,QAJmBE,IAAfF,IACAA,GAAcvE,KAAKmqB,kBAGnB5lB,IAAevE,KAAKmqB,iBAAxB,CAIA,IACIrkB,EAEA9F,KAFA8F,MACAoJ,EACAlP,KADAkP,MAGJpJ,EAAMwG,OAAS/H,EACf2K,EAAM5C,QAAU/H,CARhB,CAUJ,GAEA,CAAA5D,IAAA,YAAAC,MAIA,WACIZ,KAAKoqB,aAAY,EACrB,GAEA,CAAAzpB,IAAA,YAAAC,MAIA,WACIZ,KAAKoqB,aAAY,EACrB,GAEA,CAAAzpB,IAAA,iBAAAC,MAIA,WAEI,IACIsO,EAEAlP,KAFAkP,MACAwa,EACA1pB,KADA0pB,SAGAA,GAAYxa,EAAMtO,QAClB8oB,EAAS9oB,MAAQsO,EAAMtO,MAG/B,GAEA,CAAAD,IAAA,WAAAC,MAQA,SAASkF,GACL9F,KAAK8F,MAAML,YAAcK,GAAS9F,KAAKqqB,cAC3C,GAEA,CAAA1pB,IAAA,WAAAC,MAMA,WACI,OAAOZ,KAAK8F,MAAML,WACtB,GAEA,CAAA9E,IAAA,UAAAC,MAMA,WACI,OAAOZ,KAAKmP,IAChB,GAEA,CAAAxO,IAAA,eAAAC,MAOA,SAAayF,GAET,IACIojB,EACAzpB,KADAypB,MAGAA,IACAA,EAAM7oB,MAAQyF,EAGtB,GAEA,CAAA1F,IAAA,eAAAC,MAOA,WAAe,IAAA0pB,EACX,OAAiB,QAAVA,EAAAtqB,KAAKypB,aAAK,IAAAa,OAAA,EAAVA,EAAY1pB,QAAS,EAChC,GAEA,CAAAD,IAAA,iBAAAC,MAIA,WAEA,IAAC,CAzP6B,G,k7CCHlC,IAGqB2pB,GAAS,WAmD1B,O,4GAAAxnB,CAjCA,SAAAwnB,EAAY5C,EAAW6C,I,4FAAUzqB,CAAA,KAAAwqB,GAO7BvqB,KAAK2nB,UAAYA,EAMjB3nB,KAAKwqB,SAAWtpB,OAAO0N,OAAO,CAAC,EAAG2b,EAAUvc,SAAUwc,GAAY,CAAC,GAOnExqB,KAAKyqB,SAAW,IAAIC,IAMpB1qB,KAAK2qB,QAAU,KAEf3qB,KAAK4qB,iBACL5qB,KAAK6qB,mBAET,EAEA,EAAAlqB,IAAA,iBAAAC,MAIA,WAAiB,IAAAyE,EAAA,KAEbylB,EAGI9qB,KAAKwqB,SAFLO,EAASD,EAATC,UACAC,EAAYF,EAAZE,aAYJhrB,KAAKirB,iBAAmB,SAACtnB,GAErB,IACIrD,EAEAqD,EAFArD,OACA4qB,EACAvnB,EADAunB,aAIEC,EAAQ7qB,EAAOiK,QAAQygB,GAE7BG,EAAMlkB,UAAUkX,IAAI4M,GAGhBG,IAEAA,EAAaE,cAAgB,OAC7BF,EAAaG,QAAQ,aAAc,OAIvChmB,EAAKslB,QAAUQ,CAEnB,EAWAnrB,KAAKsrB,eAAiB,SAAC3nB,GAAU,IAAA4nB,EACK,QAAlCA,EAAA5nB,EAAMrD,OAAOiK,QAAQygB,UAAa,IAAAO,GAAlCA,EAAoCtkB,UAAUwF,OAAOse,EACzD,CAEJ,GAEA,CAAApqB,IAAA,oBAAAC,MAcA,SAAkB6pB,EAAU9H,EAAGE,GAE3B,OAAO7Q,GAAIyY,GAAU5O,OAAO,SAACtR,EAAS4gB,GAElC,IAAMK,EAAML,EAAM3K,wBACZiL,EAAY9I,EAAI6I,EAAI/c,KAAO+c,EAAI5K,MAAQ,EACvC8K,EAAY7I,EAAI2I,EAAIrhB,IAAMqhB,EAAIxb,OAAS,EACvCqU,EAASlL,KAAK8K,KAAK9K,KAAA+K,IAAAuH,EAAW,GAACtS,KAAA+K,IAAGwH,EAAW,IAEnD,OAAIrH,EAAS9Z,EAAQ8Z,OAEV,CACHA,OAAAA,EACAzhB,QAASuoB,GAKV5gB,CAEX,EAAG,CAAE8Z,OAAQ9K,OAAOoS,oBAAqB/oB,OAE7C,GAEA,CAAAjC,IAAA,WAAAC,MAYA,SAASN,EAAQsrB,GAEb,GAAItrB,EAAOurB,aAAeD,EAAOC,WAE7B,IACI,IAAIC,EAAUxrB,EAAOyrB,gBACrBD,GAAWA,EAAQE,WAAaC,KAAKC,cACrCJ,EAAUA,EAAQC,gBAGlB,GAAID,IAAYF,EACZ,OAAO,EAOnB,OAAO,CAEX,GAEA,CAAAjrB,IAAA,OAAAC,MAQA,SAAK+C,GAED,IACIunB,EAEAvnB,EAFAunB,aACAhJ,EACAve,EADAue,cAEEiK,EACFjK,EACEA,EAAc,GACdve,EAGFgnB,EAGA3qB,KAHA2qB,QACAF,EAEAzqB,KAFAyqB,SACA9C,EACA3nB,KADA2nB,UAGJ,GAAKwE,GAAYxB,EAAjB,CAIAhnB,EAAM4Q,iBAGF2W,IACAA,EAAakB,WAAa,QAG9B,IAAM7hB,EAAUvK,KAAKqsB,kBACjB5B,EACA0B,EAAQnK,QACRmK,EAAQlK,SAGP1X,GAILod,EAAU2E,aACN3B,EAEI3qB,KAAKusB,SAAS5B,EAASpgB,GACrBA,EACAA,EAAQ6N,mBAxBlB,CA4BJ,GAEA,CAAAzX,IAAA,oBAAAC,MAGA,WAAoB,IAAAwJ,EAAA,KAGZud,EACA3nB,KADA2nB,UAGJA,EAAUtkB,iBAAiB,WAAY,SAACiR,GAAC,OAAKlK,EAAKoiB,KAAKlY,EAAE,GAC1DqT,EAAUtkB,iBAAiB,YAAa,SAACiR,GAAC,OAAKlK,EAAKoiB,KAAKlY,EAAE,GAC3DqT,EAAUtkB,iBAAiB,OAAQ,SAACiR,GAAC,OAAKA,EAAEC,gBAAgB,EAEhE,GAEA,CAAA5T,IAAA,WAAAC,MAMA,SAASuqB,GAELA,EAAMlkB,UAAUkX,IAAIne,KAAKwqB,SAASiC,YAClCtB,EAAMjV,aAAa,aAAa,GAChCiV,EAAM9nB,iBAAiB,YAAarD,KAAKirB,kBACzCE,EAAM9nB,iBAAiB,UAAWrD,KAAKsrB,gBACvCH,EAAM9nB,iBAAiB,aAAcrD,KAAKirB,kBAC1CE,EAAM9nB,iBAAiB,WAAYrD,KAAKsrB,gBACxCtrB,KAAKyqB,SAAStM,IAAIgN,EAEtB,GAEA,CAAAxqB,IAAA,cAAAC,MAMA,SAAYuqB,GAER,IACIV,EACAzqB,KADAyqB,SAGCA,EAASzB,IAAImC,KAIlBA,EAAMlkB,UAAUwF,OAAOzM,KAAKwqB,SAASiC,YACrCtB,EAAMuB,gBAAgB,aACtBvB,EAAM7nB,oBAAoB,YAAatD,KAAKirB,kBAC5CE,EAAM7nB,oBAAoB,UAAWtD,KAAKsrB,gBAC1CH,EAAM7nB,oBAAoB,aAActD,KAAKirB,kBAC7CE,EAAM7nB,oBAAoB,WAAYtD,KAAKsrB,gBAC3Cb,EAAQ,OAAQU,GAEpB,GAEA,CAAAxqB,IAAA,oBAAAC,MAIA,WAAoB,IAAAmhB,EAAA,KAChB/P,GAAIhS,KAAKyqB,UAAUpoB,QAAQ,SAAC8oB,GAAK,OAAKpJ,EAAK4K,YAAYxB,EAAM,EACjE,IAAC,CAhTyB,G,0wFAE1BpnB,CAFiBwmB,GAAS,WAMR,CACdkC,WAAY,eACZ1B,UAAW,cACXC,aAAc,gBCCtB,IAIqB4B,GAAW,SAAAzD,GAgB5B,SAAAyD,EAAY3gB,GAAQ,IAAA5G,EAcU,O,4FAdVtF,CAAA,KAAA6sB,IAEhBvnB,EAAAY,GAAA,KAAA2mB,EAAA,CAAM3gB,KAMD8N,WAAa,KAMlB1U,EAAKwnB,cAAgB,KAAKxnB,CAE9B,CAEA,O,sRAAAc,CAAAymB,EAAAzD,G,4GAAApmB,CAAA6pB,EAAA,EAAAjsB,IAAA,MAAAC,MAGA,WAEIZ,KAAK8sB,OAAO,IACZ9sB,KAAK+sB,mBACL/sB,KAAKgtB,wBACLhtB,KAAKitB,oBACLxkB,GAAAmkB,EAAA,aAAAnkB,CAAA,GAEJ,GAEA,CAAA9H,IAAA,eAAAC,MAGA,WAAe,IAAAwJ,EAAA,KAEX3B,GAAAmkB,EAAA,sBAAAnkB,CAAA,IAEA,IAAAkD,EAMI3L,KALAG,YACIqe,EAAI7S,EAAJ6S,KACAzD,EAAIpP,EAAJoP,KAEJ9O,EACAjM,KADAiM,OAGJjM,KAAK4N,GAAG4Q,EAAM,kBAAMpU,EAAK8iB,gBAAgB,GACzCltB,KAAK4N,GAAGmN,EAAM,kBAAM3Q,EAAK+iB,iBAAiB,GAAG,GAE7ClhB,EAAO5I,iBAAiB,QAAS,SAAAf,GAAgB,IAEvC8qB,EAFgC9qB,EAANhC,OAEJiK,QAAQ,sBAC9B8iB,EAAaD,aAAY,EAAZA,EAAc7iB,QAAQ,oBAErC8iB,IAEAjjB,EAAKkjB,iBAAgBC,EAAAA,EAAAA,IAASF,IAC9BjjB,EAAK8iB,iBAIb,EAEJ,GAEA,CAAAvsB,IAAA,mBAAAC,MAIA,WAEI,IACIqL,EACAjM,KADAiM,OAOJjM,KAAK6L,QAASW,EAAAA,EAAAA,IAAU,qBAAsBP,EAElD,GAEA,CAAAtL,IAAA,wBAAAC,MAIA,WAEI,IACIqL,EACAjM,KADAiM,OAMJjM,KAAKwtB,cAAgB,IAAIhE,GACrBvd,EAAO4R,cAAc,8BACrB5R,EAAO4R,cAAc,8BAG7B,GAEA,CAAAld,IAAA,oBAAAC,MAIA,WAMIZ,KAAKytB,UAAY,IAAIlD,GAAUvqB,KAAK6L,OAExC,GAEA,CAAAlL,IAAA,QAAAC,MAOA,SAAM4E,GACFxF,KAAK+c,IAAIxV,KAAK/B,EAClB,GAEA,CAAA7E,IAAA,WAAAC,MAMA,SAAS4E,GACLxF,KAAK+c,IAAM/c,KAAK+c,IAAIxT,OAAO,SAACmkB,GAAU,OAAKA,IAAeloB,CAAE,EAChE,GAEA,CAAA7E,IAAA,kBAAAC,MAOA,SAAgBwK,GAERA,EAAQ,GAIZpL,KAAK+c,IAAIvO,OAAOpD,EAAO,EAE3B,GAEA,CAAAzK,IAAA,SAAAC,MAMA,SAAOmc,GAOH/c,KAAK+c,IAAMA,CAEf,GAEA,CAAApc,IAAA,SAAAC,MAOA,WACI,OAAAoR,GAAWhS,KAAK+c,IACpB,GAEA,CAAApc,IAAA,gBAAAC,MAMA,SAAcmZ,GACV/Z,KAAK+Z,WAAaA,CACtB,GAEA,CAAApZ,IAAA,mBAAAC,MAMA,SAAiBisB,GACb7sB,KAAK6sB,cAAgBA,CACzB,GAEA,CAAAlsB,IAAA,gBAAAC,MAMA,WAEI,IACImZ,EACA/Z,KADA+Z,WAGJ,IAAKA,EACD,MAAM,IAAI1H,MAAM,+BAGpB,OAAOrS,KAAK+c,IAAIzK,IAAI,SAAC9M,GAAE,OAAKuU,EAAWrJ,aAAalL,EAAG,EAE3D,GAEA,CAAA7E,IAAA,mBAAAC,MAOA,WAAmB,IAAA+sB,EAEf,OACI3tB,KAAK4tB,gBAC0B,QADbD,EACf3tB,KAAKwtB,cAAcK,iBAAS,IAAAF,OAAA,EAA5BA,EAA8B5mB,QAAQ+mB,WACtC,EAGX,GAEA,CAAAntB,IAAA,mBAAAC,MAMA,SAAiBgtB,GAMb5tB,KAAK4tB,cAAgBA,CAEzB,GAEA,CAAAjtB,IAAA,iBAAAC,MAMA,WAAiB,IAAAmtB,EAGTliB,EAIA7L,KAJA6L,OACA2hB,EAGAxtB,KAHAwtB,cACAC,EAEAztB,KAFAytB,UACAZ,EACA7sB,KADA6sB,cAGJ,IAAKA,EACD,MAAM,IAAIxa,MAAM,kCAGpB,IAAMlJ,EAAanJ,KAAKguB,gBAClBC,EAAa9kB,EAAWU,OAAS,EAEvC4jB,EAAUS,qBAEVhS,EAAAA,EAAAA,IACIrQ,EACA1C,EAAWmJ,IAAI,SAACtN,GAAS,OAAK6nB,EAActnB,KAAK,CAC7C,mBAAkB,SAAC3C,GACfA,EAAQuE,OAAOnC,EAAUoC,YAC7B,EACA,sBAAqB,SAACxE,GAClBA,EAAQ6C,YAAcT,EAAUuZ,aAChC3b,EAAQ0J,OAAS2hB,CACrB,GACF,IAGN,IAAME,EACFF,EACEjuB,KAAKouB,oBACS,QAAbL,EAAA5kB,EAAW,UAAE,IAAA4kB,OAAA,EAAbA,EAAeroB,YAAa,GAEnC8nB,EAAca,aAAaF,GAC3BX,EAAczD,SAASoE,GACvBtiB,EAAO5E,UAAUC,OAAO,cAAe+mB,GAEnCA,GAEApiB,EAAOyiB,iBAAiB,oBAAoBjsB,QAAQ,SAAC8oB,GACjDsC,EAAUc,SAASpD,EACvB,EAIR,IAAC,EAAAxqB,IAAA,MAAAC,MA7TD,WACI,OAAOZ,KAAK6C,QAAOuR,EAAAA,EAAAA,IAAgB,UACvC,IAAC,CAX2B,CAASJ,GAAAA,GCDnCjB,GAAejQ,EAASD,OAAO,QAC/BmY,GAAgBlY,EAASD,OAAO,SAChC6b,IAAMtK,EAAAA,EAAAA,IAAgB,YAAYsK,IAClC8P,IAAkBpa,EAAAA,EAAAA,IAAgB,6BAClCqa,GAAsBza,GAAAA,EAAOnR,QAAOuR,EAAAA,EAAAA,IAAgB,oBACpDsa,GAAc9B,GAAYvsB,MA2ChC,SAAS4lB,GAAS3lB,GACd,OAAOkM,EAAAA,EAAAA,IAAUlM,EAAOiK,QAAQ,gBAAgBxD,QAAQH,MAC5D,CAEA,SAAS+nB,GAAWruB,GAChB0T,GAAAA,EAAOnR,OAAOvC,EAAOiK,QAAQ,YAAYyK,MAC7C,CAhDA0Z,GAAYE,iBAAiB,IAAIhtB,GAAS4K,EAAAA,EAAAA,IAAU,2BAGpDwO,GAAcpN,GAAG,kBAAmB,SAAAtL,GAAgB,IAG5CM,EAHqCN,EAANiB,OAG/BX,QAEEoC,EAAY0Z,GAAImH,oBAAoBjjB,GAE1C6rB,GAAoBI,aAAa9nB,QAAQH,MAAQ,IAAHpF,QAAOO,EAAAA,EAAAA,IAASa,KAC9DwR,EAAAA,EAAAA,IAAgB,wBAAwB3O,YAAcT,EAAUU,WAChE0O,EAAAA,EAAAA,IAAgB,2BAA2B3O,YAAcT,EAAUuZ,aACnEiQ,GAAgBznB,QAAQoe,OAAS1jB,KAAKE,UAAU+c,GAAIoQ,iBAAiBlsB,IAErE6rB,GAAoBva,MAExB,GAGA8G,GAAcpN,GAAG,eAAgB,SAAArL,GAAgB,IAGzC8E,EAHkC9E,EAANgB,OAG5B8D,SAEE7B,EAAK6B,EAASjC,QACd2pB,GAAQpsB,EAAAA,EAAAA,IAAO,2BAA4B6rB,IAE3CQ,EAAWD,EAAMjlB,KAAK,SAAA2J,GAAU,OAAAA,EAAP1M,QAAsBC,aAAexB,CAAE,GAElEwpB,GAAYA,IAAaD,EAAM,MAI/BA,EAAMllB,OAAS,GAAMmlB,GAAYA,IAAaD,EAAM,MACnDC,GAAYD,EAAMA,EAAMllB,OAAS,IAAI4C,SAG1C+hB,GAAgBS,QAAQ5nB,EAASghB,YAErC,GAUA/X,GAAWlM,MAAM,YAGboI,EAAAA,EAAAA,IAAU,yBAAyBnJ,iBAAiB,QAAS,SAAAuM,GAAgB,IAAbtP,EAAMsP,EAANtP,OAE5DouB,GAAY5B,OAAO,CACfpO,GAAImH,oBAAoBI,GAAS3lB,IAAS8E,UAE9CspB,GAAYxa,OAEZya,GAAWruB,EAEf,EAEJ,IAEAkM,EAAAA,EAAAA,IAAU,4BAA4BnJ,iBAAiB,QAAS,SAAAwS,GAAgB,IAAbvV,EAAMuV,EAANvV,OAE/Doe,GAAIwQ,kBAAkBjJ,GAAS3lB,IAC/BquB,GAAWruB,EAEf,IAEAkM,EAAAA,EAAAA,IAAU,qBAAqBnJ,iBAAiB,QAAS,SAAA0Q,GAAgB,IAAbzT,EAAMyT,EAANzT,OAExDoe,GAAIyQ,cAAclJ,GAAS3lB,IAC3BquB,GAAWruB,EAEf,IAEAkM,EAAAA,EAAAA,IAAU,uBAAuBnJ,iBAAiB,QAAS,SAAA8Q,GAAgB,IAAb7T,EAAM6T,EAAN7T,OAEpD+G,GAAW+M,EAAAA,EAAAA,IAAgB,kBAC3BxN,EAAQqf,GAAS3lB,GAEvB+G,EAASN,QAAQoe,OAAS1jB,KAAKE,UAAU+c,GAAIoQ,iBAAiBloB,IAC9DoN,GAAAA,EAAOnR,OAAOwE,GAAU6M,OACxBya,GAAWruB,EAEf,GAEA,IAAM8uB,GAAsBlG,GAAa7oB,MACzC+uB,GAAoBC,WAAW,CAI3BC,MAAK,SAACjlB,GAEFiG,GAAWlM,MAAM,SAAC2V,GACd2E,GAAI6G,aAAaxL,EAAW9I,kBAAkB5G,GAClD,GACA+kB,GAAoBpa,MAExB,IAKJ,IAAMua,GAAsB,CAExBzvB,KAAM,KAENwvB,MAAK,SAACjlB,GAAS,IAAAhF,EAAA,KAEXiL,GAAWlM,MAAM,SAAC2V,GAEd,IAAAyV,EAGI9Q,GAAI6G,aAAaxL,EAAW9I,kBAAkB5G,IAF9CrF,EAASwqB,EAATxqB,UACOyqB,EAAQD,EAAf5oB,MAGA9G,EACAuF,EADAvF,KAGJ,GAAIA,EAAM,CAEN,IACI8G,EAMA9G,EANA8G,MAAK8oB,EAML5vB,EALAqlB,OACIxC,EAAC+M,EAAD/M,EACAE,EAAC6M,EAAD7M,EACAC,EAAC4M,EAAD5M,EAIF6M,EAAejR,GAAImH,qBAAoBrZ,EAAAA,EAAAA,IAAU5F,IACvD8X,GAAIsH,WAAWhhB,EAAW2qB,EAAa5mB,aACvC2V,GAAIyH,OAAOnhB,EAAW2qB,EAAa3mB,mBACnC0V,GAAIG,cAAc7Z,EAAW0Z,GAAI2H,cAAcsJ,IAC/CjR,GAAIkH,gBAAgB+J,GACpBjR,GAAIkR,UAAUH,EAAU9M,EAAGE,EAAGC,EAElC,CAEJ,GAEAsM,GAAoBpa,MAExB,EAEAA,KAAI,WACAhV,KAAKF,KAAO,KACZsvB,GAAoBS,cAAcN,GACtC,IAIJ/iB,EAAAA,EAAAA,IAAU,sBAAsBnJ,iBAAiB,QAAS,SAAAqR,GAAgB,IAAbpU,EAAMoU,EAANpU,OAEnDsG,EAAQqf,GAAS3lB,GACvBivB,GAAoBzvB,KAAO,CACvBqlB,OAAQzG,GAAIoQ,iBAAiBloB,GAC7BA,MAAO,IAAFpF,QAAMO,EAAAA,EAAAA,IAAS6E,KAExBwoB,GAAoBC,WAAWE,IAC/BH,GAAoBlb,OACpBya,GAAWruB,EAEf,GAGA,IAAMwvB,GAAqB,CAEvBR,MAAK,SAACjlB,GACFqkB,GAAYqB,MAAM1lB,GAClBqkB,GAAYxa,OACZkb,GAAoBpa,MACxB,EAEAA,KAAI,WACAoa,GAAoBS,cAAcC,GACtC,IAIJtjB,EAAAA,EAAAA,IAAU,mBAAmBnJ,iBAAiB,QAAS,WACnD+rB,GAAoBC,WAAWS,IAC/BV,GAAoBlb,OACpBwa,GAAY1Z,MAChB,GAEA,IAAMgb,IAAqBxjB,EAAAA,EAAAA,IAAU,0BACrCA,EAAAA,EAAAA,IAAU,mBAAmBnJ,iBAAiB,QAAS,SAAAyR,GAAgB,IAAbxU,EAAMwU,EAANxU,OAKhDuD,GADFmsB,GADApvB,OAEmB,IAAIge,OAE3BF,GAAIuR,sBAAsBhK,GAAS3lB,GAASuD,GAC5C8qB,GAAWruB,EAEf,GAEA,IAAM4vB,IAAkB9b,EAAAA,EAAAA,IAAgB,yBAExC,SAAS+b,GAAoBnrB,GAEzBkrB,GAAgB3T,UAEXvX,EAAU+D,cAAgB/D,EAAUiE,iBAG7C,EAEAmL,EAAAA,EAAAA,IAAgB,mBAAmB/Q,iBAAiB2Q,GAAAA,EAAOwK,KAAM,SAAAlE,GAAgB,IAAbha,EAAMga,EAANha,OAE1DsG,GAAQ4F,EAAAA,EAAAA,IAAUlM,EAAOyG,QAAQH,OAGvCupB,GAFkBzR,GAAImH,oBAAoBjf,GAI9C,GAEAspB,GAAgB7sB,iBAAiB,QAAS,SAAAmZ,GAAgB,IAAblc,EAAMkc,EAANlc,OAEnCsG,EAAQqf,GAAS3lB,GACvBoe,GAAI0R,qBAAqBxpB,GAAO,GAGhCupB,GADkBzR,GAAImH,oBAAoBjf,IAG1C+nB,GAAWruB,EAEf,GAEAmuB,GAAoB7gB,GAAGoG,GAAAA,EAAOwK,KAAM,WAEhC,IAAM5X,EAAQqf,GAASwI,GAAoBI,cAC3CmB,GAAmBpvB,MAAQ8d,GAAI2R,sBAAsBzpB,IAErDwN,EAAAA,EAAAA,IAAgB,0BAA0B9H,QACrC1F,EAAMK,UAAUqpB,SAAS,YAGlC,GAEA7B,GAAoB7gB,GAAGoG,GAAAA,EAAO+G,KAAM,WAChCiV,GAAmBpvB,MAAQovB,GAAmBvR,YAClD,IAEAjS,EAAAA,EAAAA,IAAU,qBAAqBnJ,iBAAiB,QAAS,SAAAuZ,GAAgB,IAAbtc,EAAMsc,EAANtc,OAExDoe,GAAI6R,uBAAuBtK,GAAS3lB,IACpCquB,GAAWruB,EAEf,GAIA,IAAMqK,GAAa,CACf6lB,MAAOtvB,OAAO2B,OAAO,MACrB4tB,MAAOvvB,OAAO2B,OAAO,OAOzB,SAAS6tB,GAAa3jB,EAAQ4jB,GAE1B,IAAIzV,EAAQ,GANhB,SAAuBnO,GACnB,OAAO7L,OAAOoM,KAAKP,GAAQkF,KAAK,SAACC,EAAGC,GAAC,OAAKoH,OAAOrH,GAAKqH,OAAOpH,EAAE,EACnE,EAMIye,CAAc7jB,GAAQ1K,QAAQ,SAAC1B,GAE3B,IAAM8M,EAASV,EAAOpM,GAEtBua,GAAS,EAETzN,EAAOpL,QAAQ,SAAAya,GAAe,IAAZlW,EAAKkW,EAALlW,MACdqe,GAAIgB,SAASrf,GAAOG,QAAQ4pB,GAAWzV,CAC3C,EAEJ,EAEJ,CAEA,SAAS2V,KAELH,GAAa/lB,GAAW6lB,MAAO,cAC/BE,GAAa/lB,GAAW8lB,MAAO,aAEnC,CAEAzV,GAAcpN,GAAG,gBAAiB,SAAAoP,GAAgB,IAAbzZ,EAAMyZ,EAANzZ,OAG7ByB,EAEAzB,EAFAyB,UACA4B,EACArD,EADAqD,MAGA4pB,EAEA7lB,GAFA6lB,MACAC,EACA9lB,GADA8lB,MAGE3oB,EAAa9C,EAAU8rB,gBAEzBhpB,IAEK0oB,EAAM1oB,KACP0oB,EAAM1oB,GAAc,IAGxB0oB,EAAM1oB,GAAYP,KAAK,CACnBvC,UAAAA,EACA4B,MAAAA,KAKR,IAAMoB,EAAahD,EAAU+rB,gBAEzB/oB,IAEKyoB,EAAMzoB,KACPyoB,EAAMzoB,GAAc,IAGxByoB,EAAMzoB,GAAYT,KAAK,CACnBvC,UAAAA,EACA4B,MAAAA,KAKRiqB,IAEJ,GAEA7V,GAAcpN,GAAG,mBAAoB,SAAA6P,GAAgB,IAAbla,EAAMka,EAANla,OAGhCyB,EAEAzB,EAFAyB,UACA4B,EACArD,EADAqD,MAGA4pB,EAEA7lB,GAFA6lB,MACAC,EACA9lB,GADA8lB,MAGE3oB,EAAa9C,EAAU8rB,gBACvBE,EAAaR,EAAM1oB,GAEzB,GAAIkpB,EAAY,CAEZ,IAAM5lB,EAAQ4lB,EAAWpb,UAAU,SAACwP,GAAI,OAAKA,EAAKxe,QAAUA,CAAK,GAE7DwE,GAAS,GACT4lB,EAAWxiB,OAAOpD,EAAO,GAGxB4lB,EAAWnnB,eACL2mB,EAAM1oB,EAGrB,CAEA,IAAME,EAAahD,EAAU+rB,gBACvBE,EAAaR,EAAMzoB,GAEzB,GAAIipB,EAAY,CAEZ,IAAM7lB,EAAQ6lB,EAAWrb,UAAU,SAACwP,GAAI,OAAKA,EAAKxe,QAAUA,CAAK,GAE7DwE,GAAS,GACT6lB,EAAWziB,OAAOpD,EAAO,GAGxB6lB,EAAWpnB,eACL4mB,EAAMzoB,EAGrB,CAEA6oB,IAEJ,GAKA,IAAMK,GAAoBtvB,EAASiB,QAAO2J,EAAAA,EAAAA,IAAU,yBAC9C2kB,IAAY3kB,EAAAA,EAAAA,IAAU,qBAE5BuG,GAAanF,GAAG,sBAAuB,SAAAwQ,GAAgB,IAE7CjV,EAFsCiV,EAAN7a,OAEZ4F,WAAWI,OAAO,SAACvE,GAEzC,MAAgB,cADHA,EAAU4W,SAE3B,IAEAM,EAAAA,EAAAA,IACIiV,GACAhoB,EAAWmJ,IAAI,SAACtN,GAAS,OAAKksB,GAAkB3rB,KAAK,CACjD,0BAAyB,SAAC3C,GACtBA,EAAQmE,QAAQsD,QAAUrF,EAAUI,OACxC,EACA,yBAAwB,SAACxC,GACrBA,EAAQuE,OAAOnC,EAAUoC,YAC7B,GACF,GAGV,GAGA2L,GAAanF,GAAG,sBAAuB,SAAAwjB,GAAgB,IAAb7tB,EAAM6tB,EAAN7tB,OAEtC+M,GAAWlM,MAAM,SAACqO,GAEdiM,GAAIvV,WAAW9G,QAAQ,SAAAgvB,GAA0B,IAAvBrsB,EAASqsB,EAATrsB,UAAW4B,EAAKyqB,EAALzqB,MAEjC,IAAI,CAAC,YAAa,UAAUoI,SAAShK,EAAU4W,WAA/C,CAIA,IAAMxQ,EAAQ7H,EAAO4F,WAAWyM,UAAU,SAAC0b,GACvC,OAAOA,EAAKlsB,UAAYJ,EAAUI,OACtC,GAEAwB,EAAMK,UAAUC,OAAO,YAAakE,EAAQ,EAN5C,CAQJ,GAEAsT,GAAIxW,UAAU7F,QAAQ,SAAAkvB,GAAyB,IAAtBlqB,EAAQkqB,EAARlqB,SAAUT,EAAK2qB,EAAL3qB,MAEzB5B,EAAYyN,EAAM/B,aAAarJ,EAASmqB,kBAE9C,IAAI,CAAC,YAAa,UAAUxiB,SAAShK,EAAU4W,WAA/C,CAIA,IAAMxQ,EAAQ7H,EAAO4F,WAAWyM,UAAU,SAAC0b,GACvC,OAAOA,EAAKlsB,UAAYJ,EAAUI,OACtC,GAEAwB,EAAMK,UAAUC,OAAO,YAAakE,EAAQ,EAN5C,CAQJ,EAEJ,EAEJ,GAEAkF,GAAWlM,MAAM,SAAC2V,GAEd2U,GAAY5F,cAAc/O,GAC1B,IAAM0X,EAAkBzd,GAAAA,EAAOnR,QAAO2J,EAAAA,EAAAA,IAAU,gBAEhD2kB,GAAU9tB,iBAAiB,QAAS,SAAAquB,GAAgB,IAE1C5lB,EAFmC4lB,EAANpxB,OAEbiK,QAAQ,mBAEzBuB,IAIL4iB,GAAY5B,OAAO,CAAChhB,EAAO/E,QAAQsD,UACnCqkB,GAAYxa,OACZud,EAAgBzc,OAEpB,EAEJ,GAIA,IAAMjG,GAAQ+C,GAAMjP,SAEpBkM,GAAMnB,GAAG,cAAe,YAEpBsO,EAAAA,EAAAA,KACI9H,EAAAA,EAAAA,IAAgB,wBAChBrF,GAAMsZ,aAEVnM,EAAAA,EAAAA,KACI9H,EAAAA,EAAAA,IAAgB,iCAChBrF,GAAMsZ,WAGd,GAEAtZ,GAAMnB,GAAG,gBAAiB,WAEtBP,OAAM+G,EAAAA,EAAAA,IAAgB,yBACtB/G,OAAM+G,EAAAA,EAAAA,IAAgB,iCAE1B,GC5fA,IAAM4G,GAAgBlY,EAASD,OAAO,SAChC6b,IAAMtK,EAAAA,EAAAA,IAAgB,YAAYsK,IAClCiT,IAAevd,EAAAA,EAAAA,IAAgB,kBAC/Bwd,GAAqB5d,GAAAA,EAAOnR,OAAO8uB,IAEzC,SAASE,GAAUjvB,GACf,OAAOnB,KAAKC,MAAMkB,EAAQmE,QAAQoe,QAAU,OAChD,CAEA,SAAS2M,GAAiBxxB,EAAQyZ,EAAYoL,GAE1C,IAAMrZ,EAASxL,aAAM,EAANA,EAAQiK,QAAQ,sBAE/B,GAAKuB,EAAL,CAIA,IAAM7J,EAAQ8X,EAAWgY,iBAAiBjmB,EAAO/E,QAAQC,YAErDJ,EACA8X,GAAI/V,YAAY1G,GADhB2E,MAGAue,GACAzG,GAAIkR,UAAUhpB,EAAOue,EAAOxC,EAAGwC,EAAOtC,GAG1C+O,GAAmB5c,MAXnB,CAaJ,C,qzDAiBA1E,GAAWlM,MAAM,SAAC2V,GAEd,IAAIiY,GAAgB,GAGpB5d,EAAAA,EAAAA,IAAgB,wBAAwB/Q,iBAAiB,QAAS,SAAAf,GAAgB,IAAbhC,EAAMgC,EAANhC,OAE7D0xB,EAtBZ,SAAwB1xB,GAEpB,IAAMwL,EAASxL,EAAOiK,QAAQ,sBACxBoS,GAAWnQ,EAAAA,EAAAA,IAAU,uCAADhL,OACiBsK,aAAM,EAANA,EAAQ/E,QAAQC,WAAU,OAGhE8E,GAAW6Q,IAIhBA,EAASvN,SAAWuN,EAASvN,QAEjC,CAUY6iB,CAAe3xB,IAGfwxB,GAAiBxxB,EAAQyZ,EAAY8X,GAAUF,KAC/CC,GAAmB5c,OAI3B,GAEA,IAAMkd,GAAoB1lB,EAAAA,EAAAA,IAAU,uBAC9B2lB,GAAkB3lB,EAAAA,EAAAA,IAAU,gCAElC0lB,EAAkB7uB,iBAAiB,SAAU,WAEzC,IAAM+uB,EAAmBF,EAAkB9iB,QAE3C4iB,EAAgBI,EAChBD,EAAgB7lB,QAAU8lB,EAErBA,IAEDzvB,EAAAA,EAAAA,IAAO,gCAAgCN,QAAQ,SAACsa,GAC5CA,EAASvN,SAAU,CACvB,EAIR,GAEA+iB,EAAgB9uB,iBAAiB,QAAS,WAEtC,IAAM8hB,EAAS0M,GAAUF,KAAiB,CAAEhP,EAAG,EAAGE,EAAG,IAErDlgB,EAAAA,EAAAA,IAAO,wCAAwCN,QAAQ,SAACsa,GAGpDwI,EAAOxC,GAAK,GACZwC,EAAOtC,GAAK,GACZiP,IACItlB,EAAAA,EAAAA,IAAU,gDAADhL,OAAiDmb,EAAS/b,MAAK,OACxEmZ,EACAoL,GAEJxI,EAASvN,SAAU,CAEvB,GAEAwiB,GAAmB5c,MAEvB,GAEA,IAAMwZ,GAAkBpa,EAAAA,EAAAA,IAAgB,6BAGxCoa,EAAgBnrB,iBAAiB,QAAS,SAAAd,GAEtCuvB,GAF+CvvB,EAANjC,OAEhByZ,EAAY8X,GAAUrD,IAC/Cxa,GAAAA,EAAOnR,QAAOuR,EAAAA,EAAAA,IAAgB,oBAAoBY,MAEtD,GAEA,IAAMqd,EAAiBre,GAAAA,EAAOnR,QAAO2J,EAAAA,EAAAA,IAAU,mBACzC8lB,GAAiB9lB,EAAAA,EAAAA,IAAU,wBAGjCwO,GAAcpN,GAAG,iBAAkB,SAAA6F,GAAgB,IAG3C7Q,EAHoC6Q,EAANlQ,OAG9BX,QAEEyE,EAAW0S,EAAW5I,YAAYvO,EAAQmE,QAAQM,WAExDgG,EAAAA,EAAAA,IAAMilB,GAAgBnrB,OAAOE,EAASD,aACtCkrB,EAAevrB,QAAQH,MAAQ,IAAHpF,QAAOO,EAAAA,EAAAA,IAASa,KAC5CwR,EAAAA,EAAAA,IAAgB,yBAAyB9H,QACpC1J,EAAQqE,UAAUqpB,SAAS,aAEhC+B,EAAene,MAEnB,IAGA1H,EAAAA,EAAAA,IAAU,oBAAoBnJ,iBAAiB,QAAS,WAEpD,IAAMuD,GAAQ4F,EAAAA,EAAAA,IAAU8lB,EAAevrB,QAAQH,OAE1CA,IAIL8X,GAAI6T,sBAAsB3rB,GAC1ByrB,EAAerd,OAEnB,GAEA,IAAMwd,EAAStxB,OAAO2B,OAAO,MACvBiE,GAAOsN,EAAAA,EAAAA,IAAgB,wBAI7B4G,GAAcpN,GAAG,gBAAiB,SAAAgC,GAAgB,IAG1C5K,EAHmC4K,EAANrM,OAG7ByB,UAEEuB,EAAcvB,EAAUI,QAEzBotB,EAAOjsB,KACRisB,EAAOjsB,GAAe,GAG1BisB,EAAOjsB,IAAgB,EAEvBvB,EAAU0D,eAAerG,QAAQ,SAACgF,GAAa,IAAAorB,EAK1C,QAHDA,GAAAjmB,EAAAA,EAAAA,IAAU,sBAADhL,OACiB6F,EAASjC,QAAO,MACtC0B,UACH,IAAA2rB,GAHDA,EAGGxrB,UAAUkX,IAAI,aAErB,EAEJ,GAIAnD,GAAcpN,GAAG,mBAAoB,SAAAiI,GAAgB,IAG7C7Q,EAHsC6Q,EAANtS,OAGhCyB,UAEEuB,EAAcvB,EAAUI,QAE1BotB,EAAOjsB,KACPisB,EAAOjsB,IAAgB,GAGtBisB,EAAOjsB,IAERvB,EAAU0D,eAAerG,QAAQ,SAACgF,GAAa,IAAAqrB,EAK1C,QAHDA,GAAAlmB,EAAAA,EAAAA,IAAU,sBAADhL,OACiB6F,EAASjC,QAAO,MACtC0B,UACH,IAAA4rB,GAHDA,EAGGzrB,UAAUwF,OAAO,aAExB,EAIR,IAEAD,EAAAA,EAAAA,IAAU,uBAAuBnJ,iBAAiB,SAAU,SAAA0Q,GAAgB,IAAbzT,EAAMyT,EAANzT,OAC3DwG,EAAKG,UAAUC,OAAO,cAAe5G,EAAO8O,QAChD,EAEJ,GAEAwiB,GAAmBhkB,GAAGoG,GAAAA,EAAO+G,KAAM,SAAA5G,GAASA,EAAN7T,OAC3BosB,gBAAgB,cAC3B,GC3NA,IAGqBiG,GAAW,SAAAxJ,GAAA,SAAAwJ,IAAA,O,4FAAA5yB,CAAA,KAAA4yB,GAAA1sB,GAAA,KAAA0sB,EAAAzsB,UAAA,Q,sRAAAC,CAAAwsB,EAAAxJ,G,4GAAApmB,CAAA4vB,EAAA,EAAAhyB,IAAA,UAAAC,MAoB5B,SAAQoE,GAA6B,IAAlB4tB,EAAQ1sB,UAAA2D,OAAA,QAAApF,IAAAyB,UAAA,IAAAA,UAAA,GAGnB+F,EACAjM,KADAiM,OAEE4mB,GAAkBze,EAAAA,EAAAA,IAAgB,oBAAqBnI,IAE7DmI,EAAAA,EAAAA,IACI,mBACAnI,GACFxG,YAAcT,EAAUU,WAC1B0O,EAAAA,EAAAA,IACI,sBACAnI,GACFxG,YAAcT,EAAUuZ,cAC1BnK,EAAAA,EAAAA,IACI,qBACAnI,GACFK,QAAUsmB,EACZC,EAAgBtW,SAAWvX,EAAU8tB,UACrCD,EAAgB9rB,QAAQR,YAAcvB,EAAUI,OAEpD,IAAC,EAAAzE,IAAA,oBAAAC,MArCD,SAAyB8D,GAErBA,EAAQqC,QAAQkF,OAASvH,EAAQqC,QAAQgsB,Y,0HACzCtqB,CAAAkqB,EAAA,2BAAAlqB,CAAA,CAAwB/D,GAE5B,IAAC,CAV2B,CAASsP,GAAAA,G,k7CCPzC,IAGqBgf,GAAQ,WAsCzB,O,4GAAAjwB,CApBA,SAAAiwB,K,4FAAcjzB,CAAA,KAAAizB,GAMVhzB,KAAKmJ,WAAa,CACdnJ,KAAKinB,oBACLjnB,KAAKinB,oBACLjnB,KAAKinB,qBAOTjnB,KAAKoL,MAAQ,CAEjB,EAEA,EAAAzK,IAAA,oBAAAC,MAQA,WAEI,IACIqyB,EACAjzB,KAAKG,YADL8yB,eAGJ,IAAKA,EACD,MAAM,IAAI5gB,MAAM,iDAGpB,OAAO4gB,EAAehxB,OAC1B,GAEA,CAAAtB,IAAA,gBAAAC,MAYA,SAAcwK,GAIV,IAFAA,EAAQmO,OAAOnO,IAEH,GAAKA,GAASpL,KAAKmJ,WAAWU,OACtC,MAAM,IAAIqpB,WAAW,0BAAD1xB,OAA2B4J,IAGnD,OAAOA,CAEX,GAEA,CAAAzK,IAAA,gBAAAC,MAQA,WACI,OAAAoR,GAAWhS,KAAKmJ,WACpB,GAEA,CAAAxI,IAAA,eAAAC,MAUA,WAAiC,IAApBwK,EAAKlF,UAAA2D,OAAA,QAAApF,IAAAyB,UAAA,GAAAA,UAAA,GAAGlG,KAAKoL,MACtB,OAAOpL,KAAKmJ,WAAWnJ,KAAKmzB,cAAc/nB,GAC9C,GAEA,CAAAzK,IAAA,eAAAC,MAUA,SAAaoE,GAA+B,IAApBoG,EAAKlF,UAAA2D,OAAA,QAAApF,IAAAyB,UAAA,GAAAA,UAAA,GAAGlG,KAAKoL,MAE5BpG,IACDA,EAAYhF,KAAKinB,qBAGrBjnB,KAAKmJ,WAAWnJ,KAAKmzB,cAAc/nB,IAAUpG,CAEjD,GAEA,CAAArE,IAAA,iBAAAC,MAQA,SAAeoE,GACXhF,KAAKozB,sBAAsBpzB,KAAKmJ,WAAWoF,QAAQvJ,GACvD,GAEA,CAAArE,IAAA,wBAAAC,MASA,SAAsBwK,GAClBpL,KAAKmJ,WAAWnJ,KAAKmzB,cAAc/nB,IAAUpL,KAAKinB,mBACtD,GAEA,CAAAtmB,IAAA,WAAAC,MAOA,SAASwK,GACLpL,KAAKoL,MAAQpL,KAAKmzB,cAAc/nB,EACpC,GAEA,CAAAzK,IAAA,WAAAC,MAMA,WACI,OAAOZ,KAAKoL,KAChB,GAEA,CAAAzK,IAAA,YAAAC,MAOA,WACI,OAAOZ,KAAKmJ,WAAWmJ,IAAI,SAACtN,GAAS,OAAKA,EAAUI,OAAO,EAC/D,IAAC,EAAAzE,IAAA,oBAAAC,MAhLD,SAAyBqyB,GAMrBjzB,KAAKizB,eAAiBA,CAE1B,IAAC,CAhBwB,G,+sBCI7B,IAGqBI,GAAW,WA6C5B,O,4GAAAtwB,CAjBA,SAAAswB,EAAYC,I,4FAAUvzB,CAAA,KAAAszB,GAOlBrzB,KAAKoL,MAAQ,EAMbpL,KAAKszB,SAAWA,CAEpB,EAEA,EAAA3yB,IAAA,aAAAC,MAKA,SAAWgC,GAMP5C,KAAK4C,QAAUA,CAEnB,GAEA,CAAAjC,IAAA,aAAAC,MAMA,WACI,OAAOZ,KAAK4C,OAChB,GAEA,CAAAjC,IAAA,WAAAC,MAMA,SAASwK,GAELpL,KAAKoL,MAAQA,EAETpL,KAAK4C,UACL5C,KAAK4C,QAAQmE,QAAQwsB,QAAUvzB,KAAKoL,MAG5C,GAEA,CAAAzK,IAAA,YAAAC,MAQA,WAEI,IACI0yB,EAEAtzB,KAFAszB,SACA9F,EACAxtB,KADAwtB,cAGJ,MAAO,CACH3pB,MAAM2pB,aAAa,EAAbA,EAAegG,aAAc,GACnCjU,IAAK+T,EAASG,YAGtB,GAEA,CAAA9yB,IAAA,OAAAC,MAMA,WAAO,IAAAyE,EAAA,KAEH,OAAOrF,KAAKG,YAAY0B,SAAS0D,KAAK,CAClC,2BAA4B,SAAC3C,GACzBA,EAAQmE,QAAQwsB,QAAUluB,EAAK+F,KACnC,GAGR,GAEA,CAAAzK,IAAA,cAAAC,MAMA,WACI,MAAO,2CAAPY,OAAkDxB,KAAKoL,MAAK,KAChE,GAEA,CAAAzK,IAAA,cAAAC,MAOA,WACI,OAAOZ,KAAKszB,SAAS/F,UACzB,GAEA,CAAA5sB,IAAA,cAAAC,MAOA,SAAYwK,GACR,OAAOpL,KAAKszB,SAASI,SAAStoB,EAClC,GAEA,CAAAzK,IAAA,eAAAC,MAUA,SAAaoE,EAAWoG,GACpBpL,KAAKszB,SAASK,aAAa3uB,EAAWoG,EAC1C,GAEA,CAAAzK,IAAA,eAAAC,MASA,SAAawK,GACT,OAAOpL,KAAKszB,SAAS5iB,aAAatF,EACtC,GAEA,CAAAzK,IAAA,UAAAC,MAMA,WAEI,IACIgC,EACA5C,KADA4C,QAGJ,IAAKA,EACD,MAAM,IAAIyP,MAAM,oDAGpBzP,EAAQgxB,eAAe,CACnBC,MAAO,WAGf,GAEA,CAAAlzB,IAAA,QAAAC,MAIA,WAEI,IACIgC,EAKA5C,KALA4C,QACA0wB,EAIAtzB,KAJAszB,SAEIQ,EAEJ9zB,KAHAG,YACI2zB,MAIHlxB,IAIL5C,KAAK+zB,UAELT,EAAStF,gBAAgB3rB,QAAQ,SAAC2C,EAAWoG,GAEzC,IAAMU,GAASU,EAAAA,EAAAA,IAAU,wCAADhL,OACoB4J,EAAK,MAC7CxI,IAGJyK,EAAAA,EAAAA,IAAMvB,GAAQ3E,OAAOnC,EAAUoC,YAEnC,GAEAxE,EAAQgB,cAAc,IAAIJ,YAAYswB,EAAO,CACzCrwB,SAAS,EACTC,YAAY,EACZH,OAAQ,CACJywB,WAAYh0B,SAIxB,GAEA,CAAAW,IAAA,SAAAC,MAGA,WAAS,IAAAqzB,EACO,QAAZA,EAAAj0B,KAAK4C,eAAO,IAAAqxB,GAAZA,EAAcxnB,QAClB,GAEA,CAAA9L,IAAA,eAAAC,MAIA,WAEI,IACIgC,EAEA5C,KAFA4C,QACA0wB,EACAtzB,KADAszB,SAGEI,EAAWJ,EAAS/F,WACpBvoB,EAAYsuB,EAAS5iB,aAAagjB,IAExCrmB,EAAAA,EAAAA,KAAMb,EAAAA,EAAAA,IAAU,wCAADhL,OAC6BkyB,EAAQ,MAChD9wB,IACDuE,OAAOnC,EAAUoC,YAExB,GAEA,CAAAzG,IAAA,mBAAAC,MASA,SAAiB4sB,GAEbxtB,KAAKwtB,cAAgBA,EAEjBxtB,KAAKk0B,qBAEL1G,EAAczD,SAAS/pB,KAAKk0B,2BACrBl0B,KAAKk0B,mBAIpB,GAEA,CAAAvzB,IAAA,WAAAC,MAQA,SAASkF,GAEL,IACI0nB,EACAxtB,KADAwtB,cAGAA,EACAA,EAAczD,SAASjkB,GAWvB9F,KAAKk0B,mBAAqBpuB,CAIlC,IAAC,EAAAnF,IAAA,QAAAN,IAjUD,WACI,MAAO,mBACX,GAEA,CAAAM,IAAA,cAAAC,MAKA,SAAmBiB,GAMf7B,KAAK6B,SAAWA,CAEpB,IAAC,CAtB2B,G,49BCNhC,IAGqBsyB,GAAY,WA6H7B,O,4GAAApxB,CA1DA,SAAAoxB,EAAYxM,GAAW,IAAAtiB,EAAA,M,4FAAAtF,CAAA,KAAAo0B,GAMnBn0B,KAAKo0B,OAAS,GAMdp0B,KAAK2nB,UAAYA,EAOjB3nB,KAAKq0B,kBAAoB,EAOzBr0B,KAAKs0B,iBAAkB,EAQvBt0B,KAAKsE,SAAW,IAAIiwB,qBAAqB,SAACnyB,GAEtCA,EAAQC,QAAQ,SAAAC,GAAmC,IAAhChC,EAAMgC,EAANhC,OAAyBgC,EAAjBkyB,mBAEE,IAErBl0B,EAAOsD,cACH,IAAIJ,YAAY6B,EAAKlF,YAAYs0B,QAAS,CACtChxB,SAAS,EACTC,YAAY,IAM5B,EAEJ,EAAG,CACCgxB,KAAM/M,EACNgN,UAAW,CAAC,GAAK,IAAM,IAG/B,EAEA,EAAAh0B,IAAA,mBAAAC,MAIA,WAEA,GAEA,CAAAD,IAAA,WAAAC,MAGA,WACIZ,KAAKme,IAAIne,KAAK40B,mBAClB,GAEA,CAAAj0B,IAAA,MAAAC,MAYA,SAAImb,GAEA,IAAKA,EACD,MAAM,IAAI1J,MAAM,mCAGhBrS,KAAKgpB,IAAIjN,KAIbA,EAAM2X,SAAS1zB,KAAKo0B,OAAO7sB,KAAKwU,GAAS,GACzC/b,KAAK2nB,UAAUxgB,OAAO4U,EAAMxW,QAC5BwW,EAAM8Y,WAAW70B,KAAK2nB,UAAU9J,cAAc9B,EAAM+Y,gBACpD90B,KAAKsE,SAASgR,QAAQyG,EAAM8S,cAC5B9S,EAAM3X,QACNpE,KAAK+0B,sBAET,GAEA,CAAAp0B,IAAA,MAAAC,MAQA,SAAImb,GACA,OAAO/b,KAAKo0B,OAAOplB,SAAS+M,EAChC,GAEA,CAAApb,IAAA,WAAAC,MASA,SAASmb,GACL,OAAO/b,KAAKo0B,OAAO7lB,QAAQwN,EAC/B,GAEA,CAAApb,IAAA,SAAAC,MAQA,SAAOmb,GACH/b,KAAKg1B,cAAch1B,KAAKutB,SAASxR,GACrC,GAEA,CAAApb,IAAA,gBAAAC,MASA,SAAcwK,GAEV,IACIgpB,EACAp0B,KADAo0B,OAKJ,MAFAhpB,EAAQmO,OAAOnO,IAEH,GAAKA,GAASgpB,EAAOvqB,QAAjC,CAIA,IAAMkS,EAAQqY,EAAOhpB,GAErBpL,KAAKsE,SAAS2wB,UAAUlZ,EAAM8S,cAC9B9S,EAAMtP,SACN2nB,EAAO5lB,OAAOpD,EAAO,GACrBpL,KAAKk1B,iBACLl1B,KAAK+0B,qBARL,CAUJ,GAEA,CAAAp0B,IAAA,YAAAC,MAKA,WASI,IAPA,IAIIiJ,EAFA7J,KADAo0B,OAGAvqB,OAGGA,GAEHA,GAAU,EACV7J,KAAKg1B,cAAcnrB,EAI3B,GAEA,CAAAlJ,IAAA,iBAAAC,MAIA,WACIZ,KAAKo0B,OAAO/xB,QAAQ,SAAC0Z,EAAO3Q,GAAK,OAAK2Q,EAAM2X,SAAStoB,EAAM,EAC/D,GAEA,CAAAzK,IAAA,uBAAAC,MAKA,WACI,OAAOZ,KAAKq0B,iBAChB,GAEA,CAAA1zB,IAAA,uBAAAC,MAYA,SAAqBwK,GAIjB,IAFAA,EAAQmO,OAAOnO,IAEH,GAAKA,EAAQpL,KAAKo0B,OAAOvqB,OACjC,MAAM,IAAIqpB,WAAW,iBAAD1xB,OAAkB4J,EAAK,qBAG/CpL,KAAKq0B,kBAAoBjpB,EACzBpL,KAAK+0B,qBAET,GAEA,CAAAp0B,IAAA,kBAAAC,MAUA,WAEI,IAAMmb,EAAQ/b,KAAKo0B,OAAOp0B,KAAKq0B,mBAE/B,IAAKtY,EACD,MAAM,IAAI1J,MAAM,8BAAD7Q,OAA+BxB,KAAKq0B,oBAGvD,OAAOtY,CAEX,GAEA,CAAApb,IAAA,gBAAAC,MAOA,SAAcwK,GACVpL,KAAKm1B,kBAAkBC,YAAYhqB,EACvC,GAEA,CAAAzK,IAAA,gBAAAC,MAOA,WACI,OAAOZ,KAAKm1B,kBAAkBE,aAClC,GAEA,CAAA10B,IAAA,eAAAC,MAQA,SAAaoE,GAEThF,KAAKm1B,kBAAkBxB,aAAa3uB,GACpChF,KAAK+0B,qBAET,GAEA,CAAAp0B,IAAA,SAAAC,MAIA,WACIZ,KAAKm1B,kBAAkBG,cAC3B,GAEA,CAAA30B,IAAA,YAAAC,MAQA,WAEI,MAAO,CACHwK,MAAOpL,KAAKq0B,kBACZD,OAAQp0B,KAAKo0B,OAAO9hB,IAAI,SAACyJ,GAAK,OAAKA,EAAM0X,WAAW,GAG5D,GAEA,CAAA9yB,IAAA,uBAAAC,MAGA,WACIZ,KAAKs0B,iBAAkB,CAC3B,GAEA,CAAA3zB,IAAA,sBAAAC,MAGA,WACIZ,KAAKs0B,iBAAkB,CAC3B,GAEA,CAAA3zB,IAAA,sBAAAC,MAIA,WAESZ,KAAKs0B,iBAIVt0B,KAAKgqB,gBAET,GAEA,CAAArpB,IAAA,iBAAAC,MAIA,WAEA,GAEA,CAAAD,IAAA,YAAAC,MAUA,SAAU4E,GAEV,GAEA,CAAA7E,IAAA,QAAAC,MAIA,SAAK2B,GAAoB,IAAA6H,EAAA,KAAjBgB,EAAK7I,EAAL6I,MAAOgpB,EAAM7xB,EAAN6xB,OAEXp0B,KAAKu1B,YAELnB,EAAO/xB,QAAQ,SAAAoR,GAAmB,IAAhB5P,EAAI4P,EAAJ5P,KAAM0b,EAAG9L,EAAH8L,IAEdxD,EAAQ3R,EAAKwqB,mBAEnB,IAAK7Y,EACD,MAAM,IAAI1J,MAAM,gCAGpB0J,EAAMgO,SAASlmB,GACf0b,EAAIld,QAAQ,SAACmD,EAAI4F,GACb2Q,EAAM4X,aAAavpB,EAAKorB,UAAUhwB,GAAK4F,EAC3C,GAEAhB,EAAK+T,IAAIpC,EAEb,GAEA/b,KAAKy1B,qBAAqBrqB,GAC1BpL,KAAKm1B,kBAAkBpB,SAE3B,IAAC,EAAApzB,IAAA,UAAAN,IA3cD,WACI,MAAO,qBACX,GAEA,CAAAM,IAAA,eAAAC,MAMA,WACI,OAAOkM,GAAU,CAAE1B,MAAO,EAAGgpB,OAAQ,CAAC,CAAE7U,IAAK,MACjD,GAEA,CAAA5e,IAAA,MAAAC,MAMA,WACI,OAAOZ,KAAKuS,QAChB,GAEA,CAAA5R,IAAA,SAAAC,MASA,WAEI,IAAIsN,EAASlO,KAAKuS,SAElB,IAAKrE,EAAQ,SAAA8S,EAAA9a,UAAA2D,OAJAoX,EAAI,IAAArX,MAAAoX,GAAAE,EAAA,EAAAA,EAAAF,EAAAE,IAAJD,EAAIC,GAAAhb,UAAAgb,GAMbhT,E,iKAAMwnB,CAAO11B,KAAQihB,GAOrBjhB,KAAKuS,SAAWrE,CAEpB,CAEA,OAAOA,CAEX,IAAC,CA3D4B,G,muBCQjC,IAAM6E,GAAejQ,EAASD,OAAO,QAC/BmY,GAAgBlY,EAASD,OAAO,SAChC6rB,GAAc9B,GAAYvsB,MAC1B0yB,GAAcJ,GAAY9vB,QAAO2J,EAAAA,EAAAA,IAAU,gBAEjD6mB,GAAY/f,YAAY1R,EAASiB,QAAO2J,EAAAA,EAAAA,IAAU,4BAElD8D,GAAWlM,MAAM,SAAC2V,GAEdiZ,GAAS2C,kBAAkB5b,EAAWkN,qBAEtC,IAAM2O,GAAuBppB,EAAAA,EAAAA,IAAU,uBACjCqpB,EAAc1B,GAAatxB,OAAO+yB,GAwGxC,SAASE,EAAqBC,EAAW5xB,IAErCiQ,EAAAA,EAAAA,IAAgB,2BACXnN,UACAC,OAAO6uB,EAAW5xB,EAE3B,CA7GA0xB,EAAYjB,iBAAmB,kBAAM,IAAIvB,GAAY,IAAIL,GAAW,EACpE6C,EAAYL,UAAY,SAAChwB,GAAE,OAAKuU,EAAWrJ,aAAalL,EAAG,EAC3DqwB,EAAY7L,eAAiB,WAEzBhP,GAActW,QAAQ,QAAS,CAC3B5E,KAAM+1B,EAAYpC,aAG1B,EAEAmC,EAAqBvyB,iBAAiB,QAAS,SAAAf,GAAgB,IAErDwJ,EAF8CxJ,EAANhC,OAExBiK,QAAQ,6BACxBwR,EAAQjQ,aAAM,EAANA,EAAQvB,QAAQ,4BAEzBuB,GAAWiQ,GAIhB8Z,EAAYb,cAAcjZ,EAAMhV,QAAQwsB,QAE5C,GAEAqC,EAAqBvyB,iBAAiB,QAAS,SAAAd,GAAgB,IAErDuJ,EAF8CvJ,EAANjC,OAExBiK,QAAQ,wCAEzBuB,IAIL+pB,EAAYG,cAAclqB,EAAO/E,QAAQqE,OACzC2nB,GAAYgB,QACR8B,EAAYV,kBAAkBzkB,eAC9B5E,EAAO7E,UAAUqpB,SAAS,cAGlC,GAEAsF,EAAqBvyB,iBAAiB8wB,GAAaM,QAAS,SAAAhhB,GAAgB,IAAbnT,EAAMmT,EAANnT,OAC3Du1B,EAAYJ,qBAAqBn1B,EAAOyG,QAAQwsB,QACpD,GAEAqC,EAAqBvyB,iBAAiBgwB,GAAYS,MAAO,SAAAlkB,GAAgB,IAGjEokB,EAH0DpkB,EAANrM,OAGpDywB,WAEEpxB,EAAUoxB,EAAWnF,cAE3BlsB,EAAAA,EAAAA,IAAO,sBAAuBC,GAASP,QAAQ,SAACqC,GAC5CA,EAAQuH,OAAS0mB,GAAY1e,kBAAkBvP,EACnD,GAEA,IAAM8oB,EAAgB,IAAIhE,GACtB5mB,EAAQib,cAAc,8BACtBjb,EAAQib,cAAc,+BAE1B2P,EAAcxD,eAAiB,kBAAM6L,EAAY7L,gBAAgB,EACjEgK,EAAWiC,iBAAiBzI,EAEhC,GAEAqI,EAAYK,uBACZL,EAAYzxB,MAAM+vB,GAAagC,gBAC/BN,EAAYO,uBAEZ5pB,EAAAA,EAAAA,IAAU,eAAenJ,iBAAiB,QAAS,WAC/CwyB,EAAYQ,UAChB,GAEAtjB,GAAanF,GAAG,sBAAuB,SAAAiI,GAAgB,IAAbtS,EAAMsS,EAANtS,OAEhC+yB,EAAoB10B,EAASiB,QAC/BuR,EAAAA,EAAAA,IAAgB,6BAEdjL,EAAa,CACf4Q,EAAW5Q,WAAWmH,GAAWY,QAAM1P,OAAAwQ,GACpCzO,EAAO4F,cAGd+S,EAAAA,EAAAA,KACI9H,EAAAA,EAAAA,IAAgB,2BAChBjL,EAAWmJ,IAAI,SAACtN,GAAS,OAAKsxB,EAAkB/wB,KAAK,CACjD,4BAA2B,SAAC3C,GAExBA,EAAQmE,QAAQR,YAAcvB,EAAUI,QACxCxC,EAAQmE,QAAQc,KAAO7C,EAAU4W,SAErC,EACA,8BAA6B,SAAChZ,GAC1BA,EAAQmE,QAAQsD,QAAUrF,EAAUI,OACxC,EACA,6BAA4B,SAACxC,GACzBA,EAAQuE,OAAOnC,EAAUoC,YAC7B,GACF,GAGV,IAYAoF,EAAAA,EAAAA,IAAU,kBAAkBnJ,iBAAiB,SAAU,SAAA0Q,GACnD+hB,EAAqB,mBADuC/hB,EAANzT,OACN8O,QACpD,IAEA5C,EAAAA,EAAAA,IAAU,oBAAoBnJ,iBAAiB,SAAU,SAAA8Q,GACrD2hB,EAAqB,qBADyC3hB,EAAN7T,OACN8O,QACtD,IAEA5C,EAAAA,EAAAA,IAAU,cAAcnJ,iBAAiB,SAAU,SAAAqR,GAC/CohB,EAAqB,eADmCphB,EAANpU,OACN8O,QAChD,GAEA,IAAMmnB,EAAcr1B,OAAO2B,OAAO,MAElCmY,GAAcpN,GAAG,gBAAiB,SAAAkH,GAAgB,IAExCtP,EAFiCsP,EAANvR,OAEfyB,UAAUI,QAEvBmxB,EAAY/wB,KACb+wB,EAAY/wB,GAAM,GAGtB+wB,EAAY/wB,IAAO,CAEvB,GAEAwV,GAAcpN,GAAG,mBAAoB,SAAA0M,GAAgB,IAE3C9U,EAFoC8U,EAAN/W,OAElByB,UAAUI,QAExBmxB,EAAY/wB,KACZ+wB,EAAY/wB,IAAO,KAGlB+wB,EAAY/wB,IAAO+wB,EAAY/wB,GAAM,WAC/B+wB,EAAY/wB,EAG3B,GAEA,IAAMgxB,EAAkBxiB,GAAAA,EAAOnR,QAAO2J,EAAAA,EAAAA,IAAU,gBAEhDgqB,EAAgB5oB,GAAGoG,GAAAA,EAAOwK,KAAM,WAE5Btd,OACKoM,KAAKipB,GACL/0B,OAAOq0B,EAAYV,kBAAkB1B,YAAYlU,KACjDhW,OAAOxE,SACP1C,QAAQ,SAACmD,GAEN,IAAMoB,GAAQ4F,EAAAA,EAAAA,IAAU,+CAADhL,OAC4BgE,EAAE,OAErDoB,SAAAA,EAAOK,UAAUkX,IAAI,aAEzB,EAER,GAEAqY,EAAgB5oB,GAAGoG,GAAAA,EAAO+G,KAAM,YAE5BpY,EAAAA,EAAAA,IAAO,uCAAuCN,QAAQ,SAACuE,GACnDA,EAAMK,UAAUwF,OAAO,aAC3B,EAEJ,IAEAD,EAAAA,EAAAA,IAAU,2BAA2BnJ,iBAAiB,QAAS,SAAAmZ,GAAgB,IAErE1Q,EAF8D0Q,EAANlc,OAExCiK,QAAQ,mBAE9B,GAAKuB,EAAL,CAKA,IAAM9G,EAAY+U,EAAWrJ,aAAa5E,EAAO/E,QAAQsD,SACzDwrB,EAAYlC,aAAa3uB,GACzB6wB,EAAYY,SAEZD,EAAgBxhB,OAChB+d,GAAY/d,MARZ,CAUJ,IAIAZ,EAAAA,EAAAA,IACI,oBACA2e,GAAYlE,cACdxrB,iBAAiB,QAAS,SAAAuZ,GAAgB,IAAA8Z,EAElClxB,EAA0C,QAAxCkxB,EAFyB9Z,EAANtc,OAETiK,QAAQ,8BAAsB,IAAAmsB,OAAA,EAArCA,EAAuC3vB,QAAQR,YAErDf,IAILkpB,GAAY5B,OAAO,CAACtnB,IACpBkpB,GAAYxa,OACZ6e,GAAY/d,OAEhB,IAEAZ,EAAAA,EAAAA,IAAgB,oBAAoB/Q,iBAAiB,QAAS,SAAAyZ,GAAgB,IAAbxc,EAAMwc,EAANxc,OAE7DouB,GAAY5B,OAAO+I,EAAYV,kBAAkB1B,YAAYlU,KAC7DmP,GAAYvB,iBAAiB7sB,EAAOyG,QAAQjB,OAC5C4oB,GAAYxa,MAEhB,GAEAnB,GAAanF,GAAG,QAAS,WAErBioB,EAAYN,YACZM,EAAYQ,UAEhB,GAGAtjB,GAAanF,GAAG,sBAAuB,SAAAoP,GAAgB,IAAbzZ,EAAMyZ,EAANzZ,OAEtC+M,GAAWlM,MAAM,WAEb,IAAM2X,EAAQ8Z,EAAYV,kBAE1BpZ,EACKnZ,QACA0rB,iBAAiB,4BACjBjsB,QAAQ,SAACyJ,GAEN,IAAMV,EAAQU,EAAO/E,QAAQqE,MACvBpG,EAAY+W,EAAMuX,SAASnqB,WAAWiC,GAE5C,GAAIpG,EAAUI,UAAY4tB,GAASC,eAAe7tB,QAAlD,CAIA,IAAMuxB,EAAYpzB,EAAO4F,WAAWyM,UAAU,SAAC0b,GAC3C,OAAOA,EAAKlsB,UAAYJ,EAAUI,OACtC,GACA0G,EAAO7E,UAAUC,OAAO,YAAayvB,EAAY,EALjD,CAOJ,EAER,EAEJ,EAEJ,GC5RA,IAAM5jB,GAAejQ,EAASD,OAAO,Q,6tCAErC2J,EAAAA,EAAAA,IAAU,iBAAiBnJ,iBAAiB,QAAS,YACjD+Q,EAAAA,EAAAA,IAAgB,YAAYrI,MAAMiE,OAAS,EAC/C,IAEAxD,EAAAA,EAAAA,IAAU,mBAAmBnJ,iBAAiB,QAAS,SAAAf,GAAgB,IAAbhC,EAAMgC,EAANhC,OAElDuN,OAAO+oB,QAAQt2B,EAAOyG,QAAQ6vB,UAC9B7jB,GAAarO,QAAQ,QAG7B,GCJA,IAAMqO,GAAejQ,EAASD,OAAO,QAC/BmY,GAAgBlY,EAASD,OAAO,SAIhCg0B,GAAqB31B,OAAO2B,OAAO,MACnCi0B,GAAqB51B,OAAO2B,OAAO,MACrCyzB,GAAoB,KAExB,SAASS,KAEL,IAAMC,EAAa91B,OAAOgM,OAAM9G,GAAAA,GAAC,CAAC,EAC3BywB,IACAC,KAGFR,KAEDA,GAAoB10B,EAASiB,QACzBuR,EAAAA,EAAAA,IAAgB,+BAKxB8H,EAAAA,EAAAA,KACI9H,EAAAA,EAAAA,IAAgB,yBAChB4iB,EAAW1kB,IAAI,SAACgK,GAAS,OAAKga,GAAkB/wB,KAAK,CACjD,wDAAuD,SAAC3C,GACpDA,EAAQmE,QAAQsD,QAAUiS,EAAUlX,OACxC,EACA,6BAA4B,SAACxC,GACzBA,EAAQuE,OAAOmV,EAAUlV,YAC7B,GACF,KAGNgN,EAAAA,EAAAA,IAAgB,kBAAkBmI,UAAW,CAEjD,CAEAjM,GAAWlM,MAAM,SAAC2V,GAEd1M,GAAMwpB,IAEN9c,EACKW,mBACAnR,OAAO,SAACvE,GAAS,MAA6B,cAAxBA,EAAU4W,SAAyB,GACzDvZ,QAAQ,SAACia,GAAS,OAAKua,GAAmBva,EAAUlX,SAAWkX,CAAS,GAE7Eya,IAEJ,GAEAhkB,GAAanF,GAAG,sBAAuB,SAAAtL,GAAgB,IAAbiB,EAAMjB,EAANiB,OAItC8J,GAAMypB,IAENvzB,EAAO4F,WACFI,OAAO,SAACvE,GAAS,MAA6B,cAAxBA,EAAU4W,SAAyB,GACzDvZ,QAAQ,SAACia,GAAS,OAAKwa,GAAmBxa,EAAUlX,SAAWkX,CAAS,GAE7Eya,KAMA,IAAME,EAAe1zB,EAAO4F,WACvBI,OAAO,SAACvE,GAAS,MAA6B,cAAxBA,EAAU4W,SAAyB,GACzDtJ,IAAI,SAACtN,GAAS,OAAKA,EAAUI,OAAO,IAEzCzC,EAAAA,EAAAA,IACI,4CACAyR,EAAAA,EAAAA,IAAgB,0BAClB/R,QAAQ,SAAC8K,GAAI,OAAKA,EAAKlG,UAAUC,OAC/B,cACA+vB,EAAajoB,SAAS7B,EAAKpG,QAAQsD,SACtC,EAEL,GAIA,IAAMqU,IAAMtK,EAAAA,EAAAA,IAAgB,YAAYsK,KAExCtK,EAAAA,EAAAA,IAAgB,yBAAyB/Q,iBAAiB,QAAS,SAAAd,GAAgB,IAEzEuJ,EAFkEvJ,EAANjC,OAE5CiK,QAAQ,mBAEzBuB,GAILwE,GAAWlM,MAAM,SAAC2V,GAEd2E,GAAI6G,aAAaxL,EAAWrJ,aAAa5E,EAAO/E,QAAQsD,UACxD2J,GAAAA,EAAOnR,QAAOuR,EAAAA,EAAAA,IAAgB,oBAAoBY,MAEtD,EAEJ,GAKA,IAAMkiB,GAAiBh2B,OAAO2B,OAAO,M,4tCAErCmY,GAAcpN,GAAG,gBAAiB,SAAA6F,GAAgB,IAExCzO,EAFiCyO,EAANlQ,OAERyB,UAEzB,GAA4B,cAAxBA,EAAU4W,UAAd,CAIA,IAAMpW,EAAKR,EAAUI,QAEhB8xB,GAAe1xB,KAChB0xB,GAAe1xB,GAAM,GAGzB0xB,GAAe1xB,IAAO,CARtB,CAUJ,GAEAwV,GAAcpN,GAAG,mBAAoB,SAAAgC,GAAgB,IAE3C5K,EAFoC4K,EAANrM,OAEXyB,UAEzB,GAA4B,cAAxBA,EAAU4W,UAAd,CAIA,IAAMpW,EAAKR,EAAUI,QAEjB8xB,GAAe1xB,KACf0xB,GAAe1xB,IAAO,EAL1B,CAQJ,GAIAwV,GAAcpN,GAAG,gBAAiB,SAAAiI,GAAgB,IAExC7Q,EAFiC6Q,EAANtS,OAERyB,UAEG,cAAxBA,EAAU4W,WAId5W,EAAU0D,eAAerG,QAAQ,SAACgF,IAC9B+M,EAAAA,EAAAA,IAAgB,wBAAwBjN,OAAOE,EAASghB,WAC5D,EAEJ,GAEArN,GAAcpN,GAAG,mBAAoB,SAAAmG,GAAgB,IAE3C/O,EAFoC+O,EAANxQ,OAEXyB,UACnBkW,EAAQgc,GAAelyB,EAAUI,SAEX,cAAxBJ,EAAU4W,WAA6BV,GAI3ClW,EAAU0D,eAAerG,QAAQ,SAACgF,GAAa,IAAAorB,EAK1C,QAHDA,GAAAjmB,EAAAA,EAAAA,IAAU,sBAADhL,OACiB6F,EAASjC,QAAO,OACtCgP,EAAAA,EAAAA,IAAgB,gCACnB,IAAAqe,GAHDA,EAGGhmB,QAEP,EAEJ,GCjLA,IAAMsG,GAAejQ,EAASD,OAAO,QAC/BmY,GAAgBlY,EAASD,OAAO,SAKhCs0B,GAAiBj2B,OAAO2B,OAAO,MAC/Bu0B,GAAiBl2B,OAAO2B,OAAO,MACjCyzB,GAAoB,KAExB,SAASe,KAEL,IAAMC,EAASp2B,OAAOgM,OAAM9G,GAAAA,GAAC,CAAC,EAAGgxB,IAAmBD,KAE/Cb,KAEDA,GAAoB10B,EAASiB,QACzBuR,EAAAA,EAAAA,IAAgB,+BAKxB8H,EAAAA,EAAAA,KACI9H,EAAAA,EAAAA,IAAgB,sBAChBkjB,EAAOhlB,IAAI,SAACilB,GAAK,OAAKjB,GAAkB/wB,KAAK,CACzC,wDAAuD,SAAC3C,GACpDA,EAAQmE,QAAQsD,QAAUktB,EAAMnyB,OACpC,EACA,6BAA4B,SAACxC,GACzBA,EAAQuE,OAAOowB,EAAMnwB,YACzB,GACF,KAGNgN,EAAAA,EAAAA,IAAgB,eAAemI,UAAW,CAE9C,CAEAxJ,GAAanF,GAAG,sBAAuB,SAAAtL,GAAgB,IAAbiB,EAAMjB,EAANiB,OAEtC8J,GAAM8pB,IAEN5zB,EAAO4F,WACFI,OAAO,SAACvE,GAAS,MAA6B,WAAxBA,EAAU4W,SAAsB,GACtDvZ,QAAQ,SAAC2C,GAAS,OAAKmyB,GAAenyB,EAAUI,SAAWJ,CAAS,GAEzEqyB,IAEJ,GAEA/mB,GAAWlM,MAAM,SAAC2V,GAEd1M,GAAM+pB,IAENrd,EACKW,mBACAnR,OAAO,SAACvE,GAAS,MAA6B,WAAxBA,EAAU4W,SAAsB,GACtDvZ,QAAQ,SAAC2C,GAAS,OAAKoyB,GAAepyB,EAAUI,SAAWJ,CAAS,GAEzEqyB,IAEJ,GAIA,IAAM3Y,IAAMtK,EAAAA,EAAAA,IAAgB,YAAYsK,KAExCtK,EAAAA,EAAAA,IAAgB,sBAAsB/Q,iBAAiB,QAAS,SAAAd,GAAgB,IAEtEuJ,EAF+DvJ,EAANjC,OAEzCiK,QAAQ,mBAEzBuB,GAILwE,GAAWlM,MAAM,SAAC2V,GAEd2E,GAAI6G,aAAaxL,EAAWrJ,aAAa5E,EAAO/E,QAAQsD,UACxD2J,GAAAA,EAAOnR,QAAOuR,EAAAA,EAAAA,IAAgB,iBAAiBY,MAEnD,EAEJ,GAKA,IAAMwiB,GAAct2B,OAAO2B,OAAO,MAElCmY,GAAcpN,GAAG,gBAAiB,SAAA6F,GAAgB,IAExCzO,EAFiCyO,EAANlQ,OAERyB,UAEzB,GAA4B,WAAxBA,EAAU4W,UAAd,CAIA,IAAMpW,EAAKR,EAAUI,QAEhBoyB,GAAYhyB,KACbgyB,GAAYhyB,GAAM,GAGtBgyB,GAAYhyB,IAAO,CARnB,CAUJ,GAEAwV,GAAcpN,GAAG,mBAAoB,SAAAgC,GAAgB,IAE3C5K,EAFoC4K,EAANrM,OAEXyB,UAEzB,GAA4B,WAAxBA,EAAU4W,UAAd,CAIA,IAAMpW,EAAKR,EAAUI,QAEjBoyB,GAAYhyB,KACZgyB,GAAYhyB,IAAO,EALvB,CAQJ,GAIAwV,GAAcpN,GAAG,gBAAiB,SAAAiI,GAAgB,IAExC7Q,EAFiC6Q,EAANtS,OAERyB,UAEG,WAAxBA,EAAU4W,WAId5W,EAAU0D,eAAerG,QAAQ,SAACgF,IAC9B+M,EAAAA,EAAAA,IAAgB,wBAAwBjN,OAAOE,EAASghB,WAC5D,EAEJ,GAEArN,GAAcpN,GAAG,mBAAoB,SAAAmG,GAAgB,IAE3C/O,EAFoC+O,EAANxQ,OAEXyB,UACnBkW,EAAQsc,GAAYxyB,EAAUI,SAER,WAAxBJ,EAAU4W,WAA0BV,GAIxClW,EAAU0D,eAAerG,QAAQ,SAACgF,GAAa,IAAAorB,EAK1C,QAHDA,GAAAjmB,EAAAA,EAAAA,IAAU,sBAADhL,OACiB6F,EAASjC,QAAO,OACtCgP,EAAAA,EAAAA,IAAgB,gCACnB,IAAAqe,GAHDA,EAGGhmB,QAEP,EAEJ,GClKA,IAAMgrB,GAAWv2B,OAAO2B,OAAO,MAE/B0K,GAAM1K,OAAO,mBAAmB60B,YAAY,SAAAp1B,GAAgB,IAAbiB,EAAMjB,EAANiB,OAE3C8J,GAAMoqB,IACNv2B,OAAO0N,OAAO6oB,GAAU,CACpBE,OAAQp0B,EAAO4F,WAAWtF,KAC1B+zB,MAAO,IAAIC,MAAQC,cACnBC,IAAK,EACLC,QAASz0B,EAAOkK,OAAO6E,IAAI,SAAC1L,GAExB,MAAO,CACH6G,OAAQ,GACR5J,KAAM+C,EAAMkI,WACZmpB,IAAI,EACJC,KAAMtxB,EAAMyB,OACZ7C,GAAIqI,OAAOgL,OAAOsf,aAClBC,cAAe,CACX5yB,GAAIoB,EAAMpB,IAItB,IAGR,GAEA,IAAMd,IAAU8H,EAAAA,EAAAA,IAAU,mBACpBX,IAASW,EAAAA,EAAAA,IAAU,kBACnBlG,IAAQkG,EAAAA,EAAAA,IAAU,iBAExB9H,GAAQrB,iBAAiB,QAAS,WAE9BqB,GAAQuC,UAAUkX,IAAI,cAEtBxL,MAAM,qDAAsD,CACpDoE,OAAQ,OACRG,QAAS,CACL,eAAgB,oBAEpBpD,KAAMrS,KAAKE,UAAU81B,MAExBjmB,KAAK,SAACoB,GAAQ,OAAKA,EAASC,MAAM,GAClCrB,KAAK,SAACqB,GAEHvM,GAAMX,IAAMkN,EAAKwlB,GACjB3zB,GAAQuC,UAAUwF,OAAO,cACzBZ,GAAOS,QAAS,CAEpB,EAER,GAEe0H,GAAAA,EAAOnR,QAAO2J,EAAAA,EAAAA,IAAU,iBAEhCoB,GAAGoG,GAAAA,EAAO+G,KAAM,WACnBlP,GAAOS,QAAS,EAChB5H,GAAQuC,UAAUwF,OAAO,aAC7B,GC1DA,IAAMsG,GAAejQ,EAASD,OAAO,QAC/BmY,GAAgBlY,EAASD,OAAO,S,mtDAEtCyN,GAAWlM,MAAM,SAAC2V,GAEd,IAAMue,EAAgBp3B,OAAO2B,OAAO,MAC9B01B,EAAe32B,EAASiB,QAAO2J,EAAAA,EAAAA,IAAU,yBA+B/C,SAASgsB,EAAe7zB,GAAM,IAAA8zB,EAEpBC,EAAyB,QAAlBD,EAAG9zB,EAAKg0B,kBAAU,IAAAF,OAAA,EAAfA,EAAiBrzB,QAEjC,GAAKszB,GAAYJ,EAAcI,GAA/B,CAIA,IAAMttB,EAAQktB,EAAcI,GAASnqB,QAAQ5J,EAAKiZ,YAAYxY,SAE1DgG,EAAQ,IAIZktB,EAAcI,GAASlqB,OAAOpD,EAAO,GAEhCktB,EAAcI,GAAS7uB,eACjByuB,EAAcI,GAXzB,CAcJ,CASA,SAASE,EAAaj0B,GAElBA,EAAK4O,YAAYyH,IACjBrW,EAAK2O,YAAYilB,GAvDrB,SAAsB5zB,GAAM,IAAAk0B,EAElBH,EAAyB,QAAlBG,EAAGl0B,EAAKg0B,kBAAU,IAAAE,OAAA,EAAfA,EAAiBzzB,QAE5BszB,IAIAJ,EAAcI,KACfJ,EAAcI,GAAW,IAG7BJ,EAAcI,GAASnxB,KAAK5C,EAAKiZ,YAAYxY,SAEjD,CA0CI0zB,CAAan0B,EAEjB,CAEAoV,EAAWgf,eAAe12B,QAAQu2B,GAGlC7lB,GAAanF,GAAG,sBAAuB,SAAAtL,GAAgB,IAAbiB,EAAMjB,EAANiB,OAEtCwW,EAAWgf,eAAe12B,QAAQ,SAACsC,GAAI,OAAKA,EAAKE,aAAY,EAAM,GACnEkV,EAAWif,uBAAuB32B,QAAQm2B,GAC1Cze,EAAWkf,0BAEX,IACI9vB,EACA5F,EADA4F,WAGJA,EAAW9G,QAAQ,SAAC2C,GAMZA,EAAU1D,QAAQ,WAElB0D,EAAUvE,QAAQ,UAAU4B,QAAQ,SAAAE,GAAoB,IAAjBiD,EAAEjD,EAAFiD,GAAItB,EAAM3B,EAAN2B,OAKjCD,EACF8V,EAAWrJ,aAAalL,IACrB2D,EAAWW,KAAK,SAAC9E,GAChB,OAAOA,EAAUI,UAAYI,CACjC,GAEEb,EAAO,IAAIX,EAAKC,EAAOC,GAC7BS,EAAKu0B,eAAc,GACnBl0B,EAAU6D,QAAQlE,GAClBi0B,EAAaj0B,GACboV,EAAWlR,QAAQlE,EAEvB,GAIJK,EAAUm0B,eAAehwB,EAE7B,GAEA,IAAMiwB,EAAYrf,EAAWgf,eAE7BhmB,GAAarO,QAAQ,eAAgB,CACjC8D,OAAQ4wB,EAAU7vB,OAAO,SAAC5E,GAAI,OAAKA,EAAK6E,SAAS,IAGzD,GAGAuJ,GAAanF,GAAG,mBAAoB,SAAA6F,GAAgB,IAAA4lB,EAAb91B,EAAMkQ,EAANlQ,OAG/BiC,EAEAjC,EAFAiC,GACAnB,EACAd,EADAc,OAGEW,EAAY+U,EAAWrJ,aAAalL,GAE1CR,EAAUs0B,iBAAiBj1B,GAEV,QAAjBg1B,EAAAf,EAAc9yB,UAAG,IAAA6zB,GAAjBA,EAAmBh3B,QAAQ,SAACk3B,GAExBxf,EACKrJ,aAAa6oB,GACbC,gBAAgBx0B,EAAWX,EAEpC,EAEJ,GAGA,IAAMo1B,GAAcjtB,EAAAA,EAAAA,IAAU,WACxBktB,GAAYltB,EAAAA,EAAAA,IAAU,eAE5BuG,GAAanF,GAAG,eAAgB,SAAAgC,GAAgB,IAGxCpH,EAHiCoH,EAANrM,OAG3BiF,OAGJixB,EAAYntB,OAA2B,IAAlB9D,EAAOqB,QAE5BqS,EAAAA,EAAAA,IACIwd,EACAlxB,EAAO8J,IAAI,SAAC3N,GAAI,OAAKA,EAAKY,MAAM,GAGxC,GAEAyV,GAAcpN,GAAG,qBAAsB,SAAAiI,GAAgB,IAAA4c,EAAblvB,EAAMsS,EAANtS,OAGlCoB,EAEApB,EAFAoB,KACAN,EACAd,EADAc,OAGyB,QAA7BouB,GAAAjmB,EAAAA,EAAAA,IAAU,IAADhL,OAAKmD,EAAKS,iBAAU,IAAAqtB,GAA7BA,EAA+BxrB,UAAUC,OAAO,YAAa7C,EAEjE,GAIA,IAAM8E,EAAa,GAEnB,SAASoc,EAAavgB,GAElB,IAAMwD,EAAStH,OAAO2B,OAAO,MAE7BmC,EAAU4D,YAAYvG,QAAQ,SAACsC,GAE3BA,EAAK2E,cAAa,GAClBd,EAAO7D,EAAKg0B,WAAWvzB,SAAWT,CAEtC,GACAwE,EAAW9G,QAAQ,SAACivB,GAAS,IAAAqI,EAEzBrI,EAAKkI,gBAAgBx0B,GAAW,GACZ,QAApB20B,EAAAnxB,EAAO8oB,EAAKlsB,gBAAQ,IAAAu0B,GAApBA,EAAsBtwB,aAAY,EAEtC,GACAF,EAAW5B,KAAKvC,EAEpB,CAEA,SAAS4gB,EAAgB5gB,GAErB,IAAMQ,EAAKR,EAAUI,QAErB+D,EAAWqF,OAAOrF,EAAWoF,QAAQvJ,GAAY,GAE5CmE,EAAWW,KAAK,SAACwnB,GAAI,OAAKA,EAAKlsB,UAAYI,CAAE,KAE9CR,EAAU4D,YAAYvG,QAAQ,SAACsC,GAAI,OAAKA,EAAK2E,cAAa,EAAM,GAChEH,EAAW9G,QAAQ,SAACivB,GAAI,OAAKA,EAAKkI,gBAAgBx0B,GAAW,EAAM,GAI3E,CAEAgW,GAAcpN,GAAG,gBAAiB,SAAAmG,GAC9BwR,EADuCxR,EAANxQ,OACbyB,UACxB,GAEAgW,GAAcpN,GAAG,mBAAoB,SAAAuG,GACjCyR,EAD0CzR,EAAN5Q,OACbyB,UAC3B,GAGAgW,GAAcpN,GAAG,eAAgB,SAAA8G,GAAgB,IAGzCrN,EAHkCqN,EAANnR,OAG5B8D,SAEErC,EAAY+U,EAAWrJ,aAAarJ,EAASmqB,kBAG/CnqB,EAASuyB,eACNvyB,EAASjC,QAAQy0B,SAAS,OAC1B70B,EAAUqY,eAAe,SAAU,sBAEtCkI,EAAavgB,EAGrB,GAGAgW,GAAcpN,GAAG,kBAAmB,SAAAkH,GAAgB,IAG5CzN,EAHqCyN,EAANvR,OAG/B8D,SAEErC,EAAY+U,EAAWrJ,aAAarJ,EAASmqB,kBAG/CnqB,EAASuyB,eACNvyB,EAASjC,QAAQy0B,SAAS,OAC1B70B,EAAUqY,eAAe,SAAU,sBAEtCuI,EAAgB5gB,EAGxB,IAGAwH,EAAAA,EAAAA,IAAU,oBAAoBnJ,iBAAiB,SAAU,SAAAiX,GAAgB,IAAbha,EAAMga,EAANha,OACxDo5B,EAAUzyB,UAAUC,OAAO,cAAe5G,EAAO8O,QACrD,EAEJ,GChRA,IAGqB0qB,GAAU,WAgC3B,O,4GAAA/2B,CA9BA,SAAA+2B,K,4FAAc/5B,CAAA,KAAA+5B,GAMV95B,KAAK+5B,UAAW,EAMhB/5B,KAAKg6B,eAAgB,EAMrBh6B,KAAKF,KAAO,GAKZE,KAAK4L,QAAU,CACX4kB,MAAO,KACPC,MAAO,KAGf,EAEA,EAAA9vB,IAAA,aAAAC,MAIA,SAAWgL,GACP5L,KAAK4L,QAAUA,CACnB,GAEA,CAAAjL,IAAA,QAAAC,MAIA,WAEI,IACId,EACAE,KADAF,KAGJA,EAAKuC,QAAQ,SAAAC,GAAsB,IAAnBkuB,EAAKluB,EAALkuB,MAAOC,EAAKnuB,EAALmuB,MAEfD,IAEAA,EAAM3V,YAAYpO,SAClB+jB,EAAM5tB,QAAQ6J,UAIdgkB,IAEAA,EAAM5V,YAAYpO,SAClBgkB,EAAM7tB,QAAQ6J,SAItB,GAEA3M,EAAK+J,OAAS,CAElB,GAEA,CAAAlJ,IAAA,cAAAC,MAMA,SAAYm5B,GAER/5B,KAAK+5B,SAAWA,EAChB/5B,KAAKi6B,mBAET,GAEA,CAAAt5B,IAAA,mBAAAC,MAMA,SAAiBo5B,GAEbh6B,KAAKg6B,cAAgBA,EACrBh6B,KAAKi6B,mBAET,GAEA,CAAAt5B,IAAA,gBAAAC,MAMA,SAAcuI,GAAY,IAAA9D,EAAA,KACtB8D,EAAW9G,QAAQ,SAAC2C,GAAS,OAAKK,EAAKsuB,aAAa3uB,EAAU,EAClE,GAEA,CAAArE,IAAA,eAAAC,MAMA,SAAaoE,GAET,IAAMlF,EAAO,CACTkF,UAAAA,EACAk1B,MAAO,EACPC,OAAQ,GAENryB,EAAa9C,EAAU8rB,gBACvB9oB,EAAahD,EAAU+rB,gBACvBvrB,EAAKR,EAAUI,QAEjB0C,IAEAhI,EAAK0wB,MAAQ,CACT5lB,MAAO9C,EACP+S,YAAa5X,SAASm3B,cAAc50B,GACpC5C,QAASoC,EAAUq1B,gBAAe,GAAMC,oBAK5CtyB,IAEAlI,EAAK2wB,MAAQ,CACT7lB,MAAO5C,EACP6S,YAAa5X,SAASm3B,cAAc50B,GACpC5C,QAASoC,EAAUq1B,gBAAe,GAAOC,oBAKjDt6B,KAAKF,KAAKyH,KAAKzH,EAEnB,GAEA,CAAAa,IAAA,eAAAC,MAWA,SAAaoE,GAAW,IAAAoF,EAAA,KAEdgB,EAAQpL,KAAKu6B,aAAav1B,GAE5BoG,EAAQ,GAIZ,CACI,CAAC,QAAS,iBACV,CAAC,QAAS,kBACZ/I,QAAQ,SAAAE,GAAwB,IAAAkR,EAAAjR,GAAAD,EAAA,GAAtBhC,EAAQkT,EAAA,GAAEsD,EAAMtD,EAAA,GAElB3T,EAAOsK,EAAKtK,KAAKsL,GAAO7K,GAE9B,GAAKT,EAAL,CAIA,IAAM06B,EAAOpwB,EAAKtK,KACbyJ,OAAO,SAACkxB,GAAK,OAAKA,EAAMl6B,EAAS,GACjC0R,KAAK,SAACC,EAAGC,GAAC,OAAKD,EAAE3R,GAAUqK,MAAQuH,EAAE5R,GAAUqK,KAAK,GACpDd,KAAK,SAAA8F,GAAQ,OAAAA,EAALhF,MAAoB5F,EAAU+R,IAAS,GAC9C2jB,EACFtwB,EAAKuwB,WAAW76B,GACdA,EAAK8C,QACL9C,EAAK+a,YAGP2f,EAEApwB,EAAKwB,QAAQrL,GAAU+rB,aACnBoO,EAEIF,EAAK53B,QAAQg4B,cACXJ,EAAK53B,QACL43B,EAAK3f,aAKfzQ,EAAKwB,QAAQrL,GAAU4G,OAAOuzB,EAxBlC,CA2BJ,EAEJ,GAEA,CAAA/5B,IAAA,iBAAAC,MAOA,SAAeoE,GAAW,IAAA+c,EAAA,KAEhB3W,EAAQpL,KAAKu6B,aAAav1B,GAE5BoG,EAAQ,IAIZ,CAAC,QAAS,SAAS/I,QAAQ,SAAC9B,GAExB,IAAMT,EAAOiiB,EAAKjiB,KAAKsL,GAAO7K,GAEzBT,IAILA,EAAK+a,YAAYpO,SACjB3M,EAAK8C,QAAQ6J,SAEjB,GAEAzM,KAAKF,KAAK0O,OAAOpD,EAAO,GAE5B,GAEA,CAAAzK,IAAA,iBAAAC,MASA,SAAei6B,GAAc,IAAA9X,EAAA,KAGrBjjB,EACAE,KADAF,KAEES,EACFs6B,EACE,QACA,QAGN,OAAO/6B,EACFyJ,OAAO,SAACkxB,GAAK,OAAKA,EAAMl6B,EAAS,GACjC0R,KAAK,SAACC,EAAGC,GAAC,OAAKD,EAAE3R,GAAUqK,MAAQuH,EAAE5R,GAAUqK,KAAK,GACpDiR,OAAO,SAACif,EAAUh7B,GAEf,IAAAi7B,EAGIj7B,EAAKS,GAFLqC,EAAOm4B,EAAPn4B,QACAiY,EAAWkgB,EAAXlgB,YASJ,OANAigB,EAAS3zB,OACL4b,EAAK4X,WAAW76B,GACd8C,EACAiY,GAGCigB,CAEX,EAAG73B,SAAS+3B,yBAGpB,GAEA,CAAAr6B,IAAA,qBAAAC,MAGA,WAAqB,IAAAq6B,EAAA,KAEjB/5B,OAAOkB,QAAQpC,KAAK4L,SAASvJ,QAAQ,SAAAwT,GAAqB,IAAA9B,EAAAvR,GAAAqT,EAAA,GAAnBhS,EAAIkQ,EAAA,GAAEnR,EAAOmR,EAAA,GAE3CnR,IAILyK,EAAAA,EAAAA,IAAMzK,GAASuE,OAAO8zB,EAAKZ,eAAwB,UAATx2B,GAE9C,EAEJ,GAEA,CAAAlD,IAAA,gBAAAC,MAOA,SAAcoE,GACVhF,KAAKk7B,oBAAoBl7B,KAAKS,QAAQuE,GAC1C,GAEA,CAAArE,IAAA,sBAAAC,MAOA,SAAoBd,GAAM,IAAAq7B,EAAA,KAEhBR,EAAa36B,KAAK26B,WAAW76B,GAEnC,CAAC,QAAS,SAASuC,QAAQ,SAAC9B,GAExB,GAAKT,EAAKS,GAAV,CAIA,IAAA66B,EAGIt7B,EAAKS,GAFLsa,EAAWugB,EAAXvgB,YACAjY,EAAOw4B,EAAPx4B,QAGJA,EAAQqE,UAAUC,OAAO,aAAci0B,EAAKE,SAASv7B,IACrD8C,EAAQqE,UAAUC,OAAO,UAAWi0B,EAAK9yB,OAAOvI,IAE5C66B,GAAc9f,EAAY+f,cAC1B/f,EAAYygB,YAAY14B,IAChB+3B,GAAc/3B,EAAQg4B,eAC9Bh4B,EAAQ04B,YAAYzgB,EAbxB,CAgBJ,EAEJ,GAEA,CAAAla,IAAA,oBAAAC,MAIA,WAAoB,IAAA26B,EAAA,KAChBv7B,KAAKF,KAAKuC,QAAQ,SAACvC,GAAI,OAAKy7B,EAAKL,oBAAoBp7B,EAAK,EAC9D,GAEA,CAAAa,IAAA,SAAAC,MAUA,SAAOd,GACH,OAAOA,EAAKq6B,OAAS,GAAoB,IAAfr6B,EAAKo6B,KACnC,GAEA,CAAAv5B,IAAA,WAAAC,MAQA,SAASd,GACL,OAAOA,EAAKq6B,OAAS,CACzB,GAEA,CAAAx5B,IAAA,aAAAC,MASA,SAAWd,GAEP,IACIi6B,EAEA/5B,KAFA+5B,SACAC,EACAh6B,KADAg6B,cAEE3xB,EAASrI,KAAKqI,OAAOvI,GACrBu7B,EAAWr7B,KAAKq7B,SAASv7B,GAE/B,OACKu7B,IAAahzB,IACTgzB,GAAYrB,GACb3xB,GAAU0xB,CAGtB,GAEA,CAAAp5B,IAAA,eAAAC,MASA,SAAaoE,GAET,IAAMQ,EAAKR,EAAUI,QAErB,OAAOpF,KAAKF,KAAK8V,UAAU,SAAC9V,GACxB,OAAOA,EAAKkF,UAAUI,UAAYI,CACtC,EAEJ,GAEA,CAAA7E,IAAA,UAAAC,MAYA,SAAQoE,GAEJ,IAAMoG,EAAQpL,KAAKu6B,aAAav1B,GAEhC,GAAIoG,EAAQ,EAER,MAAM,IAAI7J,eAAe,0BAADC,OACMwD,EAAUI,QAAO,MAKnD,OAAOpF,KAAKF,KAAKsL,EAErB,GAEA,CAAAzK,IAAA,eAAAC,MAQA,SAAaoE,GACT,OAAOhF,KAAKu6B,aAAav1B,IAAc,CAC3C,GAEA,CAAArE,IAAA,eAAAC,MAOA,SAAaoE,GAET,IAAMlF,EAAOE,KAAKS,QAAQuE,GAE1BhF,KAAKw7B,aAAa17B,EAAM,GAEnBkF,EAAU+D,aACX/I,KAAKy7B,YAAY37B,EAAM,GAG3BE,KAAKk7B,oBAAoBp7B,EAE7B,GAEA,CAAAa,IAAA,kBAAAC,MAOA,SAAgBoE,GAEZ,IAAMlF,EAAOE,KAAKS,QAAQuE,GAErBA,EAAU+D,aACX/I,KAAKy7B,YAAY37B,GAAO,GAG5BE,KAAKw7B,aAAa17B,GAAO,GACzBE,KAAKk7B,oBAAoBp7B,EAE7B,GAEA,CAAAa,IAAA,aAAAC,MASA,SAAWoE,EAAWqD,GAElB,IAAMvI,EAAOE,KAAKS,QAAQuE,GAE1BhF,KAAKy7B,YAAY37B,EACbuI,GACG,EACD,GAENrI,KAAKk7B,oBAAoBp7B,EAE7B,GAEA,CAAAa,IAAA,cAAAC,MAWA,SAAYd,EAAM47B,GACd57B,EAAKo6B,MAAQ/gB,KAAKlG,IAAInT,EAAKq6B,OAAQhhB,KAAKjG,IAAIpT,EAAKo6B,MAAQwB,EAAU,GACvE,GAEA,CAAA/6B,IAAA,eAAAC,MAUA,SAAad,EAAM47B,GACf57B,EAAKq6B,OAAShhB,KAAKjG,IAAI,EAAGpT,EAAKq6B,OAASuB,EAC5C,IAAC,CA3iB0B,GCAzB3oB,GAAejQ,EAASD,OAAO,QAC/BmY,GAAgBlY,EAASD,OAAO,SAChC8H,GAAa,IAAImvB,GAEvBnvB,GAAWgxB,WAAW,CAClBnL,OAAOpc,EAAAA,EAAAA,IAAgB,gBACvBqc,OAAOrc,EAAAA,EAAAA,IAAgB,mBAG3BrB,GAAanF,GAAG,sBAAuB,SAAAtL,GAAgB,IAAbiB,EAAMjB,EAANiB,OAEtCoH,GAAWqV,QACXrV,GAAWixB,cACPr4B,EAAO4F,WACFI,OAAO,SAACvE,GAAS,OAAM,CAAC,SAAU,aAAagK,SAAShK,EAAU4W,UAAU,IAErFjR,GAAWkxB,oBAEf,GAGA9oB,GAAanF,GAAG,QAAS,YACrBwG,EAAAA,EAAAA,IAAgB,8BAA8B0nB,WAAa,CAC/D,GAIA,IAAMC,GAAe,CACjBzE,OAAQp2B,OAAO2B,OAAO,MACtByZ,UAAWpb,OAAO2B,OAAO,OAG7BmY,GAAcpN,GAAG,gBAAiB,SAAArL,GAAgB,IAG1CyC,EAHmCzC,EAANgB,OAG7ByB,UAEE6C,EAAO7C,EAAU4W,UAGvB,GAAImgB,GAAal0B,GAAO,CAEpB,IAAMrC,EAAKR,EAAUI,QAEhB22B,GAAal0B,GAAMrC,KACpBu2B,GAAal0B,GAAMrC,GAAM,GAG7Bu2B,GAAal0B,GAAMrC,IAAO,EAE1BmF,GAAWgpB,aAAa3uB,GACxB2F,GAAWqxB,aAAah3B,EAE5B,CAGK2F,GAAWsxB,aAAaj3B,IAI7B2F,GAAW4a,aAAavgB,EAE5B,GAEAgW,GAAcpN,GAAG,mBAAoB,SAAA6F,GAAgB,IAG7CzO,EAHsCyO,EAANlQ,OAGhCyB,UAEE6C,EAAO7C,EAAU4W,UAGvB,GAAImgB,GAAal0B,GAAO,CAEpB,IAAMrC,EAAKR,EAAUI,QAEjB22B,GAAal0B,GAAMrC,KAEnBu2B,GAAal0B,GAAMrC,IAAO,EAEtBu2B,GAAal0B,GAAMrC,IAAO,IAE1BmF,GAAWuxB,eAAel3B,UACnB+2B,GAAal0B,GAAMrC,IAMtC,CAGKmF,GAAWsxB,aAAaj3B,IAI7B2F,GAAWib,gBAAgB5gB,EAE/B,GAEAgW,GAAcpN,GAAG,gBAAiB,SAAAgC,GAAgB,IAAbrM,EAAMqM,EAANrM,OAG5BoH,GAAWsxB,aAAa14B,EAAOyB,YAIpC2F,GAAWqb,WAAWziB,EAAOyB,UAAWzB,EAAO8E,OAEnD,GAEA,IAAM0xB,IAAWvtB,EAAAA,EAAAA,IAAU,cAE3ButB,GAAS12B,iBAAiB,SAAU,SAAAwS,GAAgB,IAE1CkkB,EAFmClkB,EAANvV,OAEX8O,QAExBzE,GAAWwxB,YAAYpC,GACvBhnB,GAAarO,QAAQ,wBAAyB,CAC1Cq1B,SAAAA,GAGR,IAEAvtB,EAAAA,EAAAA,IAAU,aAAanJ,iBAAiB,SAAU,SAAA0Q,GAAgB,IAExDqoB,EAFiDroB,EAANzT,OAE1B8O,QAEvBzE,GAAW0xB,iBAAiBD,GAC5BrpB,GAAarO,QAAQ,uBAAwB,CACzC03B,QAAAA,IAMAA,IAAYrC,GAAS3qB,UAErB2qB,GAAS3qB,SAAU,GACnB0L,EAAAA,EAAAA,IAAcif,IAItB,GC/IA,IAAMuC,IAAe9vB,EAAAA,EAAAA,IAAU,6BACzB+vB,IAAe/vB,EAAAA,EAAAA,IAAU,6BAE/BnB,GAAUgI,aAAa,CACnBvH,OAAQlK,EAASiB,QAAO2J,EAAAA,EAAAA,IAAU,gCAClCP,OAAQrK,EAASiB,QAAO2J,EAAAA,EAAAA,IAAU,kCAEtCnB,GAAUswB,WAAW,CACjB7vB,OAAQwwB,GACR5wB,QAAQc,EAAAA,EAAAA,IAAU,6BAClBP,OAAQswB,KAGZ96B,KAAKC,MAAM46B,GAAav1B,QAAQ2G,YAAYrL,QAAQ,SAACvC,GAEnC,IAAIuL,GAAUvL,GACtByF,MAEV,GAEA,IAAMjB,GAAWxB,EAASD,OAAO,eAEjC2J,EAAAA,EAAAA,IAAU,mBAAmBnJ,iBAAiB,QAAS,WAEnD,IAAMgD,EAAOwH,OAAO2uB,OAAO3uB,OAAO6F,KAAK+oB,iBAEvC,GAAKp2B,EAAL,CAIA,IAAMO,EAAQ,IAAIyE,GAAU,CACxBkB,IAAKlG,EACLqF,QAAQ,IAEZ9E,EAAMrB,OAENjB,GAASI,QAAQ,mBAAoB,CACjCkC,MAAAA,GATJ,CAYJ,GAEA,IAAM81B,GAAe,IAAIC,QAqBzB,SAASC,GAAYh2B,GAEjBoN,GAAAA,EAAOnR,OAAO+D,EAAMi2B,aAAa7nB,OACjCpO,EAAM6F,SACNnI,GAASI,QAAQ,qBAAsB,CACnCkC,MAAAA,GAGR,CA3BAtC,GAASsJ,GAAG,mBAAoB,SAAAtL,GAAgB,IAGxCsE,EAHiCtE,EAANiB,OAG3BqD,MAGJ81B,GAAand,IAAI3Y,EAAMi2B,YAAaj2B,EAExC,GAqBA21B,GAAal5B,iBAAiB,QAAS,SAAAd,GAAgB,IAE7CuJ,EAFsCvJ,EAANjC,OAEhBiK,QAAQ,uBAE9B,GAAKuB,EAAL,CAIA,IAAMlF,EAAQ81B,GAAar8B,IAAIyL,EAAOvB,QAAQ,4BAE9C,GAAK3D,EAIL,OAAQkF,EAAO/E,QAAQ+1B,QAEvB,IAAK,OAED,IAAMh9B,EAAO8G,EAAMnG,UACb4F,EAAOwH,OAAO2uB,OAAO3uB,OAAO6F,KAAK+oB,gBAAiB38B,EAAKyM,KAEzDlG,EAxCZ,SAAmBO,EAAO2F,GAEtB3F,EAAMm2B,UAAUxwB,GAChBjI,GAASI,QAAQ,qBAAsB,CACnCkC,MAAAA,GAGR,CAkCYo2B,CAAUp2B,EAAOP,GAEjBu2B,GAAYh2B,GAGhB,MAEJ,IAAK,SAEDg2B,GAAYh2B,GAzBhB,CA8BJ,GChHA,IAAMkF,IAASU,EAAAA,EAAAA,IAAU,mBACnBwL,IAAQxL,EAAAA,EAAAA,IAAU,aAExBV,GAAOzI,iBAAiB,QAAS,WAEzBwK,OAAO+oB,QAAQ9qB,GAAO/E,QAAQk2B,WAE9BjlB,GAAMpX,MAAQ,IACdka,EAAAA,EAAAA,IAAc9C,IAItB,GCbO,IAAMklB,GAAU,S,qgCCIvB1wB,EAAAA,EAAAA,IAAU,YAAY/G,YAAcy3B,GCapC,IAAMzqB,GAAQlF,GAAM1K,OAAO,mBACrBkQ,GAAejQ,EAASD,OAAO,QAC/BmY,GAAgBlY,EAASD,OAAO,SAChCs6B,GAAoBr6B,EAASD,OAAO,cAEpCqlB,IAAa9T,EAAAA,EAAAA,IAAgB,YAC7BsK,GAAMwJ,GAAWxJ,IACjB3P,GAAQ+C,GAAMjP,SAEpBkQ,GAAanF,GAAG,sBAAuB,SAAAtL,GAAgB,IAAbiB,EAAMjB,EAANiB,OAEtCkP,GAAMmpB,cACFr4B,EAAOM,KACPN,EAAO4F,WAAWmJ,IAAI,SAACtN,GAAS,OAC5BA,EAAUgM,WACRhM,EAAUo4B,aACVp4B,EAAUI,OAAO,GAEvB7B,EAAO+K,MAEXmE,GAAM4qB,mBAEV,GAEAtqB,GAAanF,GAAG,oBAAqB,SAAArL,GAAgB,IAAbgB,EAAMhB,EAANgB,OACpCkP,GAAM6qB,UAAU/5B,EAAOyM,OAC3B,GAEAgL,GAAcpN,GAAG,gBAAiB,SAAA6F,GAAgB,IAAblQ,EAAMkQ,EAANlQ,OACjCkP,GAAM9D,SAASpL,EAAOyB,UAC1B,GAEAgW,GAAcpN,GAAG,mBAAoB,SAAAgC,GAAgB,IAAbrM,EAAMqM,EAANrM,OACpCkP,GAAM8qB,YAAYh6B,EAAOyB,UAC7B,GAEAgW,GAAcpN,GAAG,eAAgB,SAAAiI,GAAgB,IAAbtS,EAAMsS,EAANtS,OAChCkP,GAAM9D,SAASpL,EAAO8D,SAC1B,GAEA2T,GAAcpN,GAAG,kBAAmB,SAAAmG,GAAgB,IAAbxQ,EAAMwQ,EAANxQ,OACnCkP,GAAM8qB,YAAYh6B,EAAO8D,SAC7B,GAEA2T,GAAcpN,GAAG,OAAQ,SAAAuG,GAAgB,IAAb5Q,EAAM4Q,EAAN5Q,OAGpBX,EAIAW,EAJAX,QACA6L,EAGAlL,EAHAkL,KACAtE,EAEA5G,EAFA4G,IACAuE,EACAnL,EADAmL,OAEE9H,EACF8X,GAAImH,oBAAoBjjB,IACrB8b,GAAI+H,mBAAmB7jB,GAG1BgE,GACA6L,GAAMmd,UAAUhpB,EAAO6H,EAAMtE,EAAKuE,EAG1C,GAEAsM,GAAcpN,GAAG,SAAU,SAAA8G,GAAgB,IAAbnR,EAAMmR,EAANnR,OAGtBX,EAEAW,EAFAX,QACA8L,EACAnL,EADAmL,OAEE9H,EACF8X,GAAImH,oBAAoBjjB,IACrB8b,GAAI+H,mBAAmB7jB,GAG1BgE,GACA6L,GAAM+qB,WAAW52B,EAAO8H,EAGhC,GAEAsM,GAAcpN,GAAG,gBAAiB,SAAAkH,GAAgB,IAAbvR,EAAMuR,EAANvR,OACjCkP,GAAMuT,WAAWtH,GAAImH,oBAAoBtiB,EAAOqD,OAAQrD,EAAO8E,OACnE,GAEA2S,GAAcpN,GAAG,gBAAiB,SAAA0M,GAAgB,IAAb/W,EAAM+W,EAAN/W,OACjCkP,GAAM0T,OAAOzH,GAAImH,oBAAoBtiB,EAAOqD,OAAQrD,EAAO+E,aAC/D,GAEA0S,GAAcpN,GAAG,kBAAmB,SAAA4O,GAAgB,IAAbjZ,EAAMiZ,EAANjZ,OAEnCkP,GAAMoM,cAAcH,GAAImH,oBAAoBtiB,EAAOqD,OAAQrD,EAAOM,MAClEkL,GAAMoP,IAAI5a,EAAOM,KAErB,GAEAmX,GAAcpN,GAAG,oBAAqB,SAAAgP,GAAgB,IAAbrZ,EAAMqZ,EAANrZ,OAErCkP,GAAM5D,aACF6P,GAAImH,oBAAoBtiB,EAAOqD,OAC/BrD,EAAOgF,aAGf,GAEAyS,GAAcpN,GAAG,QAAS,SAAAkP,GAAgB,IAAbvZ,EAAMuZ,EAANvZ,OACzBkP,GAAMgrB,UAAUl6B,EAAOzD,KAC3B,GAEAq9B,GAAkBvvB,GAAG,mBAAoB,SAAAoP,GAAgB,IAAbzZ,EAAMyZ,EAANzZ,OACxCkP,GAAMirB,cAAcn6B,EAAOqD,MAAOrD,EAAO6H,MAC7C,GAEA+xB,GAAkBvvB,GAAG,qBAAsB,SAAA6P,GAAgB,IAAbla,EAAMka,EAANla,OAC1CkP,GAAMkrB,gBAAgBp6B,EAAOqD,MACjC,GAEAu2B,GAAkBvvB,GAAG,qBAAsB,SAAAwQ,GAAgB,IAAb7a,EAAM6a,EAAN7a,OAC1CkP,GAAMmrB,gBAAgBr6B,EAAOqD,MACjC,GAEA,IjClG0Ci3B,GAEhCC,GACAC,GiC+FJC,GAAevrB,GAAMwrB,aAEtBD,KAA4D,KjCpGvBH,GiCoGSX,GjClGzCY,GAAS1kB,GiCkGkB4kB,IjCjG3BD,GAAS3kB,GAAaykB,IAYrB3kB,IAAO,EAVC4kB,GAAOjiB,OAAO,SAACpC,EAAQykB,EAAMjlB,GAMxC,OAJe,IAAXQ,IACAA,EAASykB,EAAOH,GAAO9kB,IAGpBQ,CAEX,EAAG,GAEsB,MiCwFrBukB,IACGnwB,OAAO+oB,QAAQljB,KAAKyqB,gBAEvBnqB,GAAAA,EAAOnR,QAAOuR,EAAAA,EAAAA,IAAgB,iBAAiBF,OAGnDzB,GAAM2rB,WAAWlB,KAIrB,IACIppB,GACA7Q,SADA6Q,KAGJA,GAAKzQ,iBAAiB,QAAS,SAAA+tB,GAAgB,IAErCliB,EAF8BkiB,EAAN9wB,OAETiK,QAAQ,yBAExB2E,EAAMK,aAAa,kBACpBkD,GAAM4rB,UAAUnvB,EAGxB,GAEA4E,GAAKzQ,iBAAiB,SAAU,SAAAguB,GAAgB,IAAb/wB,EAAM+wB,EAAN/wB,OAC/BmS,GAAM6rB,YAAYh+B,EAAOiK,QAAQ,WACrC,EAAG,CACCg0B,SAAS,IAGb,IAAMC,GAAY/rB,GAAMjF,OAExB8C,GAAWlM,MAAM,SAAC2V,GAId,IAAMqL,EAAOoZ,GAAUr1B,WAEnBic,GAAQA,EAAKjc,YAAcic,EAAKjc,WAAWU,QAE3CkJ,GAAarO,QAAQ,sBAAuB,CACxCb,KAAMuhB,EAAKvhB,KACXsF,WAAYic,EAAKjc,WACZmJ,IAAI,SAACnF,GAAI,OACN4M,EAAWrJ,aACS,iBAATvD,EACLA,EACAA,EAAK3H,KAERuU,EAAWtC,sBAAsBtK,EAAK,GAE5C5D,OAAOxE,SACZuJ,KAAM8W,EAAK9W,OAOnB,IAAImwB,EAAc,EAElBD,GAAU/wB,OAAOpL,QAAQ,SAAAkvB,GASnB,IARF/rB,EAAE+rB,EAAF/rB,GACAiJ,EAAI8iB,EAAJ9iB,KACAtE,EAAGonB,EAAHpnB,IACAuE,EAAM6iB,EAAN7iB,OACArG,EAAMkpB,EAANlpB,OACAC,EAAYipB,EAAZjpB,aACAwG,EAAUyiB,EAAVziB,WACAG,EAASsiB,EAATtiB,UAGMyvB,EAAcpuB,GAAWquB,cAAcn5B,GACvC4f,EACFsZ,EACEhgB,GAAI6G,aAAaxL,EAAW9I,kBAAkBzL,IAC9CkZ,GAAI/V,YAAYoR,EAAWgY,iBAAiBvsB,IAG9CoB,EAEAwe,EAFAxe,MACA5B,EACAogB,EADApgB,UAGJ0Z,GAAIkR,UAAUhpB,EAAO6H,EAAMtE,EAAKuE,GAE5BgwB,IAEAhgB,GAAIsH,WAAWhhB,EAAWD,QAAQsD,IAClCqW,GAAIyH,OAAOnhB,EAAWD,QAAQuD,IAC9BoW,GAAIG,cAAc7Z,EAAW8J,GAC7B4P,GAAI7P,aAAa7J,EAAWD,QAAQkK,KAIpCP,EAAS+vB,IACTA,EAAc/vB,EAGtB,GAEAgQ,GAAIgI,UAAU+X,GAKd,IACIvwB,EACAswB,GADAtwB,OAOJ,GAJKhN,OAAOoM,KAAKY,GAAQrE,SACrBqE,EAASimB,GAAagC,gBAGQ,iBAAvBjoB,EAAO,YAA0B,CAExC,IAAMb,EAAQ8mB,GAAagC,eAC3B9oB,EAAM+mB,OAAO,GAAG7U,IAAMre,OAAOgM,OAAOgB,GACpCA,EAASb,CAEb,CAEA8mB,GAAa9zB,MAAM+D,MAAM8J,GAIzBhN,OAAOkB,QAAQo8B,GAAU/uB,QAAQpN,QAAQ,SAAAqvB,GAAuB,IAAAkN,EAAAC,EAAAr8B,GAAAkvB,EAAA,GAArBjvB,EAAQo8B,EAAA,GAAEj+B,EAAKi+B,EAAA,GAEhDpvB,GAAS9M,EAAAA,EAAAA,IAAOF,GAEhBiH,EAAgB,QAAZk1B,EAAGnvB,EAAO,UAAE,IAAAmvB,OAAA,EAATA,EAAWl1B,KAClBo1B,EAAmB,UAATp1B,EACVwF,EACF4vB,EACErvB,EAAO3F,KAAK,SAACoF,GAAK,OAAKA,EAAMtO,QAAUA,CAAK,GAC5C6O,EAAO,GAGRP,IAID4vB,EACA5vB,EAAME,SAAU,EACA,aAAT1F,EACPwF,EAAME,QAAUxO,EAEhBsO,EAAMtO,MAAQA,GAGlBka,EAAAA,EAAAA,IAAc5L,GAElB,GAEA6D,GAAarO,QAAQ,sBAIrBxD,OAAOkB,QAAQo8B,GAAU7uB,SAAStN,QAAQ,SAAA08B,GAAwB,IAAAC,EAAAx8B,GAAAu8B,EAAA,GAAtBt8B,EAAQu8B,EAAA,GAAEnW,EAAMmW,EAAA,GAElDrvB,GAAUnD,EAAAA,EAAAA,IAAU/J,GAE1B,GAAKkN,EAAL,CAIA,IAAMsvB,EAAYtvB,EAAQJ,aAAa,QACvCI,EAAQE,KAAOgZ,EAEXoW,IAAcpW,GAEdlZ,EAAQ/L,cAAc,IAAIs7B,MAAM,SAAU,CACtCz7B,SAAS,IARjB,CAaJ,GAOI+6B,GAAUxuB,SACVkY,GAAWnc,MAAMiE,OAASwuB,GAAUxuB,QAKxCwuB,GAAU9wB,WAAWrL,QAAQ,SAACkK,EAAK0M,GAE/B,IAAMrS,EAAQ,IAAIyE,GAAU,CACxBkB,IAAAA,EACAb,QAAQ,IAEZ9E,EAAMrB,OAEN43B,GAAkBz4B,QAAQ,mBAAoB,CAC1CkC,MAAAA,EACAwE,MAAO6N,GAGf,EAEJ,E","sources":["webpack:///./assets/js/classes/Token.js","webpack:///./assets/js/classes/Template.js","webpack:///./assets/js/classes/Observer.js","webpack:///./assets/js/classes/Jinx.js","webpack:///./assets/js/classes/ReminderToken.js","webpack:///./assets/js/classes/CharacterToken.js","webpack:///./assets/js/utils/strings.js","webpack:///./assets/js/classes/InfoToken.js","webpack:///./assets/js/utils/objects.js","webpack:///./assets/js/classes/Store.js","webpack:///./assets/js/classes/TokenStore.js","webpack:///./assets/js/utils/promises.js","webpack:///./assets/js/constants/language.js","webpack:///./assets/js/classes/Names.js","webpack:///./assets/js/utils/fetch.js","webpack:///./assets/js/processes/setup/general.js","webpack:///./assets/js/processes/setup/select-edition.js","webpack:///./assets/js/utils/arrays.js","webpack:///./assets/js/utils/numbers.js","webpack:///./assets/js/processes/setup/select-characters.js","webpack:///./assets/js/processes/setup/select-your-character.js","webpack:///./assets/js/processes/setup/character-sheet.js","webpack:///./assets/js/processes/setup/clear-cache.js","webpack:///./assets/js/utils/functions.js","webpack:///./assets/js/classes/Tokens.js","webpack:///./assets/js/classes/Positioner.js","webpack:///./assets/js/classes/Pad.js","webpack:///./assets/js/processes/grimoire/general.js","webpack:///./assets/js/classes/ProcessList.js","webpack:///./assets/js/classes/SelectDialog.js","webpack:///./assets/js/classes/SettableTitle.js","webpack:///./assets/js/classes/Draggable.js","webpack:///./assets/js/classes/TokenDialog.js","webpack:///./assets/js/processes/grimoire/characters.js","webpack:///./assets/js/processes/grimoire/reminders.js","webpack:///./assets/js/classes/BluffDialog.js","webpack:///./assets/js/classes/BluffSet.js","webpack:///./assets/js/classes/BluffsGroup.js","webpack:///./assets/js/classes/BluffsGroups.js","webpack:///./assets/js/processes/grimoire/demon-bluffs.js","webpack:///./assets/js/processes/grimoire/reset.js","webpack:///./assets/js/processes/grimoire/travellers.js","webpack:///./assets/js/processes/grimoire/fabled.js","webpack:///./assets/js/processes/grimoire/export.js","webpack:///./assets/js/processes/jinxes.js","webpack:///./assets/js/classes/NightOrder.js","webpack:///./assets/js/processes/night-order.js","webpack:///./assets/js/processes/info-tokens.js","webpack:///./assets/js/processes/notes.js","webpack:///./assets/js/constants/version.js","webpack:///./assets/js/processes/acknowledgements.js","webpack:///./assets/js/processes/store.js"],"sourcesContent":["/**\n * An abstract class designed for working with the token data. This class has\n * magic methods, starting with \"get\", that access information from the data.\n * @abstract\n */\nexport default class Token {\n\n    /**\n     * Helper function that converts a property into a data key. For example,\n     * \"getLoremIpsum\" is converted into \"loremIpsum\".\n     *\n     * @param  {String} property\n     *         Property to convert.\n     * @return {String}\n     *         Converted property.\n     */\n    static convertProperty(property) {\n\n        const clipped = property.replace(/^get/, \"\");\n\n        return clipped.charAt(0).toLowerCase() + clipped.slice(1);\n\n    }\n\n    /**\n     * @param {Object} data\n     *        Data to access.\n     */\n    constructor(data) {\n\n        /**\n         * The data to access.\n         * @type {Object}\n         */\n        this.data = this.processData(data);\n\n        this.setup();\n\n        const constructor = this.constructor;\n\n        return new Proxy(this, {\n\n            get(target, property) {\n\n                if (!(property in target) && property.startsWith(\"get\")) {\n\n                    target[property] = () => target.getData(\n                        constructor.convertProperty(property)\n                    );\n\n                }\n\n                return target[property];\n\n            }\n\n        });\n\n    }\n\n    /**\n     * A function called before the magic methods are created, allowing\n     * sub-classes to adjust the setup.\n     */\n    setup() {\n        return;\n    }\n\n    /**\n     * Processes the data. This method mainly exists so that it can be easily\n     * modified in sub-classes.\n     *\n     * @param  {Object} data\n     *         Original data.\n     * @return {Object}\n     *         Processed data.\n     */\n    processData(data) {\n        return data;\n    }\n\n    /**\n     * Creates a new instance of {@link Token} with the same data.\n     *\n     * @return {Token}\n     *         A cloned instance.\n     */\n    clone() {\n        return new this.constructor(this.data);\n    }\n\n    /**\n     * Checks to see if the key exists within the data.\n     *\n     * @param  {String} key\n     *         Key for the data to check for.\n     * @return {Boolean}\n     *         true if the data has the given key, false if it doesn't.\n     */\n    hasData(key) {\n        return Object.prototype.hasOwnProperty.call(this.data, key);\n    }\n\n    /**\n     * Gets the key from {@link Template#data} and returns the value.\n     *\n     * @param  {String} key\n     *         Key for the data to access.\n     * @return {?}\n     *         Corresponding data.\n     * @throws {ReferenceError}\n     *         The given key must exist in {@link Token#data}.\n     */\n    getData(key) {\n\n        if (!this.hasData(key)) {\n            throw new ReferenceError(`Unrecognised property \"${key}\"`);\n        }\n\n        return this.data[key];\n\n    }\n\n    /**\n     * Returns a clone of {@link Token#data}, although any Symbol that was added\n     * will be missing.\n     *\n     * @return {Object}\n     *         Cloned data.\n     */\n    getAllData() {\n        return JSON.parse(JSON.stringify(this.data));\n    }\n\n}\n","import {\n    lookup,\n    identify\n} from \"../utils/elements.js\";\n\n/**\n * A class that helps work with templates.\n */\nexport default class Template {\n\n    /**\n     * A cache of the template IDs to {@link Template} instances.\n     * @type {Object}\n     */\n    static cache = Object.create(null);\n\n    /**\n     * A function that creates an instance of {@link Template} but also saves it\n     * in {@link Template.cache} so that it can be accessed again. If the\n     * instance already exists, it is returned instead of being re-created.\n     *\n     * @param  {Element} template\n     *         Template element that the instance should help work with.\n     * @return {Template}\n     *         Template instance.\n     */\n    static create(template) {\n\n        const {\n            cache\n        } = this;\n        const key = identify(template);\n\n        if (!cache[key]) {\n            cache[key] = new this(template);\n        }\n\n        return cache[key];\n\n    }\n\n    /**\n     * @param {Element} template\n     *        Template element.\n     */\n    constructor(template) {\n\n        /**\n         * Template element.\n         * @type {Element}\n         */\n        this.template = template;\n\n    }\n\n    /**\n     * Clones the contents in {@link Template#template} and populates it based\n     * on the information given.\n     *\n     * The population is an array of arrays. Each inner array has 2 or 3 items:\n     * 0: A CSS selector identifying the parts of the template to populate.\n     * 1: The contents that should be added to anything matching the selector.\n     * 2: A function that takes the element and content and describes how to\n     *    populate that content. If ommitted, {@link Template.setText} is used.\n     *\n     * @param  {Object} populates\n     *         An object of selectors to the functions that will populate the\n     *         matching elements.\n     * @return {DocumentFragment}\n     *         The populated template.\n     */\n    draw(populates) {\n\n        const clone = this.template.content.cloneNode(true);\n\n        Object.entries(populates).forEach(([selector, populate]) => {\n            lookup(selector, clone).forEach((element) => populate(element));\n        });\n\n        return clone;\n\n    }\n\n}\n","/**\n * Listens for and dispatches events.\n */\nexport default class Observer {\n\n    /**\n     * A cache of all observers created using {@link Observer.create}.\n     * @type {Object}\n     */\n    static observers = Object.create(null);\n\n    /**\n     * A helper function for creating/getting observers.\n     *\n     * @param  {String} name\n     *         Name of the observer.\n     * @return {Observer}\n     *         Observer instance.\n     */\n    static create(name) {\n\n        const {\n            observers\n        } = this;\n\n        if (!observers[name]) {\n            observers[name] = new this();\n        }\n\n        return observers[name];\n\n    }\n\n    /**\n     * Creates the observer.\n     */\n    constructor() {\n\n        /**\n         * A dummy element that has the events bound to it.\n         * @type {Element}\n         */\n        this.dummy = document.createElement(\"div\");\n\n    }\n\n    /**\n     * Listens for an event and binds the given handler to it.\n     *\n     * @param {String} eventName\n     *        Name of the event to listen for.\n     * @param {Function} handler\n     *        Handler to execute when the event is heard.\n     */\n    on(eventName, handler) {\n        this.dummy.addEventListener(eventName, handler);\n    }\n\n    /**\n     * Removes a handler from the given event.\n     *\n     * @param {String} eventName\n     *        Name of the event.\n     * @param {Function} handler\n     *        Handler to remove from the event.\n     */\n    off(eventName, handler) {\n        this.dummy.removeEventListener(eventName, handler);\n    }\n\n    /**\n     * Creates an event.\n     *\n     * @param  {String} eventName\n     *         Name of the event to create.\n     * @param  {?} [detail]\n     *         Optional detail for the event.\n     * @return {CustomEvent}\n     *         Event that was created.\n     */\n    create(eventName, detail) {\n\n        return new CustomEvent(eventName, {\n            bubbles: true,\n            cancelable: true,\n            detail\n        });\n\n    }\n\n    /**\n     * Dispatches an event and returns it.\n     *\n     * @param  {CustomEvent|String} eventName\n     *         Either the event to trigger or the name of the event to trigger.\n     * @param  {?} [detail]\n     *         Optional detail for the event. This parameter is only used if the\n     *         eventName parameter is a string and the event is created.\n     * @return {CustomEvent}\n     *         Event that was dispatched.\n     */\n    trigger(eventName, detail) {\n\n        const event = (\n            typeof eventName === \"string\"\n            ? this.create(eventName, detail)\n            : eventName\n        );\n\n        this.dummy.dispatchEvent(event);\n\n        return event;\n\n    }\n\n}\n","import CharacterToken from \"./CharacterToken\";\nimport Observer from \"./Observer\";\n\n/**\n * Manages a Jinx.\n *\n * The comments in the code might use a few terms to describe a jinx. Here's a\n * glossary:\n *\n * Theoretical.\n * The jinx exists but isn't part of this script.\n * For example: the Cerenovus is jinxed with the Goblin. If the Cerenovus is on\n * the current script but the Goblin is not then the jinx is theoretical.\n *\n * Ready.\n * The jinx is on the script.\n * For example: the Chambermaid is jinxed with the Mathematician. If both\n * characters are on the script then the jinx is ready, but not necessarily\n * active.\n *\n * Active.\n * Both characters that form this jinx have been selected.\n * For example, the Butler is jinxed with the Cannibal. If both tokens are in\n * the grimoire then the jinx is active.\n *\n * Target.\n * The character that has the jinx.\n * For example: the Pit-Hag is jinxed with the Heretic. The Pit-Hag is the\n * target. On a character sheet, the target is the larger icon above the smaller\n * jinxes.\n *\n * Trick.\n * The character that is jinxed with the target.\n * For example: the Lycanthrope is jinxed with the Gambler. The Gambler is the\n * trick. On a character sheet, the trick is the smaller icon under the main\n * character.\n */\nexport default class Jinx {\n\n    /**\n     * @param {CharacterToken|undefined} trick\n     *        The character that the source character will be jinxed with. If\n     *        the jinx is between 2 homebrew characters and only one is defined\n     *        in the data, `trick` may be undefined.\n     * @param {String} reason\n     *        The reason for the jinx.\n     */\n    constructor(trick, reason) {\n\n        /**\n         * The character that the source character is jinxed with.\n         * @type {CharacterToken|undefined}\n         */\n        this.trick = trick;\n\n        /**\n         * The reason for the jinx.\n         * @type {String}\n         */\n        this.reason = reason;\n\n        /**\n         * The state of this jinx.\n         * @type {Object}\n         */\n        this.state = {\n            ready: false,\n            trick: false,\n            target: false,\n            active: false\n        };\n\n    }\n\n    /**\n     * Sets the target of the jinx, which is to say the larger icon on the\n     * character sheet.\n     *\n     * @param {CharacterToken} target\n     *        The jinx target.\n     */\n    setTarget(target) {\n        this.target = target;\n    }\n\n    /**\n     * Sets an observer which can trigger events as the state changes.\n     *\n     * @param {Observer} observer\n     *        Observer that will dispatch events at key moments.\n     */\n    setObserver(observer) {\n        this.observer = observer;\n    }\n\n    /**\n     * Helper function for toggling a state from within {@link Jinx#state}.\n     * Optionally the state can be forced. If the state is the same, no action\n     * is taken. Don't call this method directly, use one of the helper\n     * functions {@link Jinx#toggleReady}, {@link Jinx#toggleTrick}, or\n     * {@link Jinx#toggleTarget}.\n     *\n     * @param  {String} name\n     *         Name of the state to toggle.\n     * @param  {Boolean} [forceState]\n     *         The state to force. If ommitted, the state is simply toggled.\n     * @return {Boolean}\n     *         The new state.\n     * @throws {ReferenceError}\n     *         The name of the state must be recognised.\n     */\n    toggleState(name, forceState) {\n\n        const {\n            state\n        } = this;\n\n        if (!Object.prototype.hasOwnProperty.call(state, name)) {\n            throw new ReferenceError(`Unrecognised state \"${name}\"`);\n        }\n\n        if (forceState === undefined) {\n            forceState = !state[name];\n        }\n\n        if (forceState !== state[name]) {\n\n            state[name] = forceState;\n\n            // Next line can trigger: toggle-jinx-ready, toggle-jinx-trick, toggle-jinx-target, toggle-jinx-active\n            this.observer?.trigger(`toggle-jinx-${name}`, {\n                jinx: this,\n                state: forceState\n            });\n\n        }\n\n        return forceState;\n\n    }\n\n    /**\n     * Toggles the ready state. A jinx is considered \"ready\" when it's on the\n     * script, but not necessarily active. Optionally the state can be forced\n     * with the same logic as {@link Jinx#toggleState}.\n     *\n     * @param {Boolean} [forceState]\n     *        The optional state to force.\n     */\n    toggleReady(forceState) {\n\n        if (this.toggleState(\"ready\", forceState) === false) {\n            this.toggleState(\"active\", false);\n        }\n\n    }\n\n    /**\n     * Exposes whether or not this jinx is ready.\n     *\n     * @return {Boolean}\n     *         true if the jinx is ready, false otherwise.\n     */\n    isReady() {\n        return this.state.ready;\n    }\n\n    /**\n     * Activates the jinx by making sure that both the \"ready\" and \"active\"\n     * states are set.\n     */\n    activate() {\n\n        this.toggleReady(true);\n        this.toggleState(\"active\", true);\n\n    }\n\n    /**\n     * Toggles the trick state. The jinx's trick is the character that the\n     * target is jinxed with (the smaller icon on the character sheet). If the\n     * trick state is true then that character has been selected for the game.\n     * If the trick and target states are both active, the jinx will be\n     * activated. Optionally the trick's state can be forced with the same logic\n     * as {@link Jinx#toggleState}.\n     *\n     * @param {Boolean} [forceState]\n     *        The optional state to force.\n     */\n    toggleTrick(forceState) {\n\n        if (\n            this.toggleState(\"trick\", forceState)\n            && this.state.target\n        ) {\n            this.activate();\n        } else {\n            this.toggleState(\"active\", false);\n        }\n\n    }\n\n    /**\n    * Toggles the target state. The jinx's target is the character that the\n    * target has the jinx (the larger icon on the character sheet). If the\n    * target state is true then that character has been selected for the game.\n    * If the trick and target states are both active, the jinx will be\n    * activated. Optionally the target's state can be forced with the same logic\n    * as {@link Jinx#toggleState}.\n     *\n     * @param {Boolean} [forceState]\n     *        The optional state to force.\n     */\n    toggleTarget(forceState) {\n\n        if (\n            this.toggleState(\"target\", forceState)\n            && this.state.trick\n        ) {\n            this.activate();\n        } else {\n            this.toggleState(\"active\", false);\n        }\n\n    }\n\n    /**\n     * Exposes whether or not this jinx is active.\n     *\n     * @return {Boolean}\n     *         true if the jinx is active, false otherwise.\n     */\n    isActive() {\n        return Boolean(this.trick) && this.state.ready && this.state.active;\n        // return this.isReady() && this.state.trick && this.state.target;\n    }\n\n    /**\n     * Checks to see if {@link Jinx#trick} matches the given character.\n     *\n     * @param  {CharacterToken} character\n     *         Character to test for.\n     * @return {Boolean}\n     *         true if the character matches, false if it doesn't.\n     */\n    matches(character) {\n        return Boolean(this.trick) && this.trick.matches(character);\n    }\n\n    /**\n     * Exposes {@link Jinx#target}.\n     *\n     * @return {CharacterToken}\n     *         The target character for the jinx.\n     */\n    getTarget() {\n        return this.target;\n    }\n\n    /**\n     * Exposes {@link Jinx#trick}.\n     *\n     * @return {CharacterToken|undefined}\n     *         The character that the source character is jinxed with, if we\n     *         know it.\n     */\n    getTrick() {\n        return this.trick;\n    }\n\n    /**\n     * Exposes {@link Jinx#reason}\n     *\n     * @return {String}\n     *         The reason for the jinx.\n     */\n    getReason() {\n        return this.reason;\n    }\n\n    /**\n     * Exposes {@link Jinx#isHomebrew}\n     *\n     * @returns {Boolean}\n     *          true if the Jinx is homebrew, false if it's not.\n     */\n    getIsHomebrew() {\n        return Boolean(this.isHomebrew);\n    }\n\n    /**\n     * Sets whether or not this Jinx is from a homebrew role.\n     *\n     * @param {Boolean} isHomebrew\n     *        true if the Jinx comes from a homebrew source, false otherwise.\n     */\n    setIsHomebrew(isHomebrew) {\n\n        /**\n         * Whether or not this Jinx has ceom from a homebrew role or not.\n         * @type {Boolean}\n         */\n        this.isHomebrew = isHomebrew;\n\n    }\n\n    /**\n     * Sets the template that can be used to draw the jinx.\n     *\n     * @param {Template} template\n     *        The template that will draw the jinx.\n     */\n    setTemplate(template) {\n\n        /**\n         * The template to draw the jinx.\n         * @type {Template}\n         */\n        this.template = template;\n\n    }\n\n    /**\n     * Helper function for drawing the jinx character icon.\n     *\n     * @param {Element} element\n     *        Image element to modify.\n     * @param {CharacterToken} character\n     *        Character whose data should be sued to populate the image.\n     */\n    static drawImg(element, character) {\n\n        if (!character) {\n            return;\n        }\n\n        element.src = character.getImage();\n        element.alt = character.getName();\n        element.title = character.getName();\n\n    }\n\n    /**\n     * Gets an ID for the jinx.\n     *\n     * @return {String}\n     *         An ID for the jinx.\n     */\n    getId() {\n        return `jinx--${this.target.getId()}-${this.trick?.getId() || '_unknown_'}`;\n    }\n\n    /**\n     * Draws the jinx.\n     *\n     * @return {DocumentFragment}\n     *         The jinx markup.\n     */\n    draw() {\n\n        const {\n            target,\n            trick,\n            reason,\n            template,\n            constructor: {\n                drawImg\n            }\n        } = this;\n\n        // if (!template) {\n        //     throw new Error(\"Jinx template has not been set.\");\n        // }\n\n        return template.draw({\n            \".js--jinx-table--jinx\": (element) => {\n                element.id = this.getId();\n            },\n            \".js--jinx-table--target\"(element) {\n                drawImg(element, target);\n            },\n            \".js--jinx-table--target-name\"(element) {\n                element.textContent = target.getName();\n            },\n            \".js--jinx-table--trick\"(element) {\n                drawImg(element, trick);\n            },\n            \".js--jinx-table--trick-name\"(element) {\n                element.textContent = trick?.getName() || '';\n            },\n            \".js--jinx-table--reason\"(element) {\n                element.textContent = reason;\n            }\n        });\n\n    }\n\n}\n","import Token from \"./Token.js\";\nimport Template from \"./Template.js\";\n\n/**\n * A version of {@link Token} for reminder tokens.\n * @extends Token\n */\nexport default class ReminderToken extends Token {\n\n    /**\n     * Sets the templates that will be access when drawing views.\n     *\n     * @param {Object} templates\n     *        A map of keys to {@link Template} instances.\n     */\n    static setTemplates(templates) {\n\n        /**\n         * The templates that all instances will access.\n         * @type {Object}\n         */\n        this.templates = templates;\n\n    }\n\n    /**\n     * A collection of all global reminders - reminders that aren't attached to\n     * any character but might still be useful for play.\n     * @type {Array.<ReminderToken>}\n     */\n    static global = [];\n\n    /**\n     * Adds a reminder to {@link ReminderToken.global}.\n     *\n     * @param {ReminderToken} reminder\n     *        Global reminder to add.\n     */\n    static addGlobal(reminder) {\n        this.global.push(reminder);\n    }\n\n    /**\n     * Exposes {@link ReminderToken.global}.\n     *\n     * @return {Array.<ReminderToken>}\n     *         All global reminders.\n     */\n    static getGlobal() {\n        return this.global;\n    }\n\n    /**\n     * @inheritDoc\n     */\n    processData(data) {\n\n        // Provide some default values so that .get() methods don't worry about\n        // missing data and instead worry about typos.\n\n        return {\n            id: \"\",\n            text: \"\",\n            image: \"\",\n            characterId: \"\",\n            characterName: \"\",\n            isGlobal: false,\n            ...data\n        };\n\n    }\n\n    /**\n     * Draws the reminder token.\n     *\n     * @return {DocumentFragment}\n     *         Populated token.\n     */\n    drawToken() {\n\n        const {\n            image,\n            text,\n            characterName\n        } = this.data;\n\n        return this.constructor.templates.token.draw({\n            \".js--reminder--name\"(element) {\n                element.textContent = characterName;\n            },\n            \".js--reminder--text\"(element) {\n                element.textContent = text;\n            },\n            \".js--reminder--image\"(element) {\n                element.src = image;\n            }\n        });\n\n    }\n\n    /**\n     * Draws the reminder list item.\n     *\n     * @return {DocumentFragment}\n     *         Populated reminder list item.\n     */\n    drawList() {\n\n        const {\n            id,\n            isGlobal\n        } = this.data;\n\n        return this.constructor.templates.list.draw({\n            \".js--reminder-list--item,.js--reminder-list--button\"(element) {\n                element.dataset.reminderId = id;\n            },\n            \".js--reminder-list--item\"(element) {\n                element.classList.toggle(\"is-global\", isGlobal);\n            },\n            \".js--reminder-list--button\": (element) => {\n                element.append(this.drawToken());\n            },\n            \".js--reminder-list--checkbox\"(element) {\n                element.value = id;\n            }\n        });\n\n    }\n\n\n}\n","import Token from \"./Token.js\";\nimport Template from \"./Template.js\";\nimport Jinx from \"./Jinx.js\";\nimport ReminderToken from \"./ReminderToken.js\";\nimport {\n    identify,\n} from \"../utils/elements.js\";\n\nconst emptyProperty = Symbol(\"empty\");\nconst customProperty = Symbol(\"custom\");\n\n/**\n * A version of {@link Token} that handles character information.\n */\nexport default class CharacterToken extends Token {\n\n    /**\n     * A property that we use to work out if this token is the empty character.\n     * @type {Symbol}\n     * @constant\n     */\n    static get empty() {\n        return emptyProperty;\n    }\n\n    /**\n     * A property that we use to work out if this token is a custom character.\n     * @type {Symbol}\n     * @constant\n     */\n    static get custom() {\n        return customProperty;\n    }\n\n    /**\n     * Sets the templates that will be access when drawing views.\n     *\n     * @param {Object} templates\n     *        A map of keys to {@link Template} instances.\n     */\n    static setTemplates(templates) {\n\n        /**\n         * The templates that all instances will access.\n         * @type {Object}\n         */\n        this.templates = templates;\n\n    }\n\n    /**\n     * @inheritDoc\n     */\n    processData(data) {\n\n        // Provide some default values so that .get() methods don't worry about\n        // missing data and instead worry about typos.\n\n        return {\n            id: \"\",\n            name: \"\",\n            edition: \"\",\n            team: \"\",\n            firstNight: 0,\n            firstNightReminder: \"\",\n            otherNight: 0,\n            otherNightReminder: \"\",\n            reminders: [],\n            setup: false,\n            ability: \"\",\n            image: \"\",\n            special: null,\n            ...data\n        };\n\n    }\n\n    /**\n     * @inheritDoc\n     */\n    setup() {\n\n        /**\n         * A flag showing whether or not the character is dead.\n         * @type {Boolean}\n         */\n        this.isDead = false;\n\n        /**\n         * A flag showing whether or not the character is upside down,\n         * indicating that the character is the opposite alignment (or on the\n         * evil team if it's a traveller).\n         * @type {Boolean}\n         */\n        this.isUpsideDown = false;\n\n        /**\n         * A flag showing whether or not the character has a ghost vote.\n         * @type {Boolean}\n         */\n        this.hasGhostVote = true;\n\n        /**\n         * A collection of all jinxes that may affect this character.\n         * @type {Array.<Jinx>}\n         */\n        this.jinxes = [];\n\n        /**\n         * Collection of all reminders that this character uses.\n         * @type {Array.<ReminderToken>}\n         */\n        this.reminders = [];\n\n    }\n\n    /**\n     * @inheritDoc\n     */\n    clone() {\n\n        const clone = super.clone();\n\n        this.getReminders().forEach((reminder) => {\n            clone.addReminder(reminder.clone());\n        });\n\n        this.getJinxes().forEach((jinx) => {\n            clone.addJinx(jinx);\n        });\n\n        return clone;\n\n    }\n\n    /**\n     * Adds a reminder for this character.\n     *\n     * @param {ReminderToken} reminder\n     *        Instance of {@link ReminderToken} for the reminder.\n     */\n    addReminder(reminder) {\n        this.reminders.push(reminder);\n    }\n\n    /**\n     * Gets the reminders that this character has. The returned array may be\n     * empty if the character doesn't have any reminders.\n     *\n     * @return {Array.<ReminderToken>}\n     *         All the reminders for this character.\n     */\n    getReminders() {\n        return this.reminders;\n    }\n\n    /**\n     * Toggles the dead state for this character. The state can be forced by\n     * passing a boolean to this method.\n     *\n     * @param  {Boolean} [state]\n     *         Optional state to set. If ommitted, the state is toggled.\n     * @return {Boolean}\n     *         The new state.\n     */\n    toggleDead(state) {\n\n        if (state === undefined) {\n            state = !this.isDead;\n        }\n\n        this.isDead = state;\n\n        if (state) {\n            this.toggleGhostVote(true);\n        }\n\n        return this.getIsDead();\n\n    }\n\n    /**\n     * Exposes {@link CharacterToken#isDead}.\n     *\n     * @return {Boolean}\n     *         true if the character is dead, false otherwise.\n     */\n    getIsDead() {\n        return Boolean(this.isDead);\n    }\n\n    /**\n     * Toggles the upside-down state for this character. The state can be forced\n     * by passing a boolean to this method.\n     *\n     * @param  {Boolean} [state]\n     *         Optional state to set. If ommitted, the state is toggled.\n     * @return {Boolean}\n     *         The new state.\n     */\n    rotate(state) {\n\n        if (state === undefined) {\n            state = !this.isUpsideDown;\n        }\n\n        this.isUpsideDown = state;\n\n        return this.getIsUpsideDown();\n\n    }\n\n    /**\n     * Exposes {@link CharacterToken#isUpsideDown}.\n     *\n     * @return {Boolean}\n     *         true if the character is upside-down, false otherwise.\n     */\n    getIsUpsideDown() {\n        return Boolean(this.isUpsideDown);\n    }\n\n    /**\n     * Toggles whether or not the player has a ghost vote. The state can be\n     * forced by passing a boolean to this method.\n     *\n     * @param  {Boolean} [state]\n     *         Optional state to set. If ommitted, the state is toggled.\n     * @return {Boolean}\n     *         The new state.\n     */\n    toggleGhostVote(state) {\n\n        if (state === undefined) {\n            state = !this.hasGhostVote;\n        }\n\n        this.hasGhostVote = state;\n\n        return this.getHasGhostVote();\n\n    }\n\n    /**\n     * Exposes {@link CharacterToken#hasGhostVote}.\n     *\n     * @return {Boolean}\n     *         true if the character has a ghost vote, false otherwise.\n     */\n    getHasGhostVote() {\n        return Boolean(this.hasGhostVote);\n    }\n\n    /**\n     * Checks to see if the given character matches this one. It may not be the\n     * same object, it may be a clone.\n     *\n     * @param  {CharacterToken} character\n     *         Character to check.\n     * @return {Boolean}\n     *         true if the character matches, false if it doesn't.\n     */\n    matches(character) {\n        return character === this || character.getId() === this.getId();\n    }\n\n    /**\n     * Adds a jinx top {@link CharacterToken#jinxes}.\n     *\n     * @param {Jinx} jinx\n     *        Jinx to add.\n     */\n    addJinx(jinx) {\n\n        jinx.setTarget(this);\n\n        this.jinxes.push(jinx);\n\n    }\n\n    /**\n     * Sets any jinxes that match any of the given characters \"ready\".\n     *\n     * @param {Array.<CharacterToken>} characters\n     *        Characters that may be tricks in a jinx.\n     */\n    readyAllJinxes(characters) {\n\n        characters.forEach((character) => {\n            this.toggleJinxReady(character, true);\n        });\n\n    }\n\n    /**\n     * Sets all jinxes in {@link CharacterToken#jinxes} to unready.\n     */\n    unreadyAllJinxes() {\n        this.jinxes.forEach((jinx) => jinx.toggleReady(false));\n    }\n\n    /**\n     * Toggles the ready state of a jinx. Optionally the state can be defined.\n     *\n     * @param {CharacterToken} character\n     *        Character that has a jinx with this character.\n     * @param {Boolean} [state]\n     *        Optional state to force. If ommitted, the state is toggled.\n     */\n    toggleJinxReady(character, state) {\n\n        this.jinxes.forEach((jinx) => {\n\n            if (jinx.matches(character)) {\n                jinx.toggleReady(state);\n            }\n\n        });\n\n    }\n\n    /**\n     * Toggles the active state of a jinx. Optionally the state can be defined.\n     *\n     * @param {CharacterToken} trick\n     *        Character that has a jinx with this character.\n     * @param {Boolean} [state]\n     *        Optional state to force. If ommitted, the state is toggled.\n     */\n    toggleJinxTrick(trick, state) {\n\n        this.jinxes.forEach((jinx) => {\n\n            if (jinx.matches(trick)) {\n                jinx.toggleTrick(state);\n            }\n\n        });\n\n    }\n\n    /**\n     * Sets the target state for all the jinxes in\n     * {@link CharacterToken#jinxes}.\n     *\n     * @param {Boolean} [state]\n     *        Optional state to set. If ommited, the state of each of the jinxes\n     *        will be toggled.\n     */\n    toggleJinxTarget(state) {\n        this.jinxes.forEach((jinx) => jinx.toggleTarget(state));\n    }\n\n    /**\n     * Exposes {@link CharacterToken#jinxes}.\n     *\n     * @return {Array.<Jinx>}\n     *         Collection of all jinxes.\n     */\n    getJinxes() {\n        return this.jinxes;\n    }\n\n    /**\n     * Exposes all the ready jinxes.\n     *\n     * @return {Array.<Jinx>}\n     *         Collection of all ready jinxes.\n     */\n    getReadyJinxes() {\n        return this.jinxes.filter((jinx) => jinx.isReady());\n    }\n\n    /**\n     * Exposes all the active jinxes.\n     *\n     * @return {Array.<Jinx>}\n     *         Collection of all active jinxes.\n     */\n    getActiveJinxes() {\n        return this.jinxes.filter((jinx) => jinx.isActive());\n    }\n\n    /**\n     * Checks to see if this is the empty character token.\n     *\n     * @return {Boolean}\n     *         true if this is the empty character token, false otherwise.\n     */\n    isEmpty() {\n        return Boolean(this.data[emptyProperty]);\n    }\n\n    /**\n     * Checks to see if this is a custom character token.\n     *\n     * @return {Boolean}\n     *         true if this is a custom character token, false otherwise.\n     */\n    isCustom() {\n        return Boolean(this.data[customProperty]);\n    }\n\n    /**\n     * Gets the special data for this character, if it exists.\n     *\n     * @param  {String} type\n     *         The special type.\n     * @param  {String} name\n     *         The special name.\n     * @return {Object|undefined}\n     *         Either the special object or undefined if the special cannot be\n     *         found.\n     */\n    getSpecialData(type, name) {\n\n        const {\n            special\n        } = this.data;\n        const isArray = Array.isArray(special);\n\n        if (!special || (isArray && !special.length)) {\n            return;\n        }\n\n        return special.find((data) => {\n            return data.type === type && data.name === name;\n        });\n\n    }\n\n    /**\n     * Checks to see if the character has any special data matching the given\n     * type and name.\n     *\n     * @param  {String} type\n     *         The special type.\n     * @param  {String} name\n     *         The special name.\n     * @return {Boolean}\n     *         true if the special exists, false if it doesn't.\n     */\n    hasSpecialData(type, name) {\n        return Boolean(this.getSpecialData(type, name));\n    }\n\n    /**\n     * Draws the token that can be shown on the grimoire.\n     *\n     * @return {DocumentFragment}\n     *         Populated token.\n     */\n    drawToken() {\n\n        const {\n            name,\n            image,\n            reminders = [],\n            remindersGlobal = [],\n            firstNight,\n            otherNight,\n            setup\n        } = this.data;\n\n        return this.constructor.templates.token.draw({\n            \".js--character--leaves\"(element) {\n\n                element.classList.toggle(\"character--setup\", setup);\n                element.classList.toggle(\"character--left-1\", firstNight);\n                element.classList.toggle(\"character--right-1\", otherNight);\n                const top = reminders.length + remindersGlobal.length;\n                element.classList.toggle(`character--top-${top}`, top);\n\n            },\n            \".js--character--image\"(element) {\n                element.src = image;\n            },\n            \".js--character--name\"(element) {\n                element.textContent = name;\n            }\n        });\n\n    }\n\n    /**\n     * Draws the character token list item.\n     *\n     * @return {DocumentFragment}\n     *         Populated character token list item.\n     */\n    drawList() {\n\n        const {\n            id\n        } = this.data;\n\n        return this.constructor.templates.list.draw({\n            \".js--character-list--button\"(element) {\n                element.dataset.tokenId = id;\n            },\n            \".js--character-list--token\": (element) => {\n                element.append(this.drawToken());\n            }\n        });\n\n    }\n\n    /**\n     * Draws the character's icon, name, and ability for the \"Select Characters\"\n     * dialog box.\n     *\n     * @return {DocumentFragment}\n     *         Populated select entry.\n     */\n    drawSelect() {\n\n        const {\n            id,\n            name,\n            image,\n            ability,\n            setup\n        } = this.data;\n\n        return this.constructor.templates.select.draw({\n            \".js--character-select--image\"(element) {\n                element.src = image;\n            },\n            \".js--character-select--name\"(element) {\n\n                element.textContent = name;\n                element.classList.toggle(\"is-setup\", setup);\n\n            },\n            \".js--character-select--ability\"(element) {\n                element.textContent = ability;\n            },\n            \".js--character-select--input\"(element) {\n\n                element.value = id;\n                element.closest(\"label\").htmlFor = identify(element);\n\n            },\n            \".js--character-select--count\"(element) {\n\n                element.name += id;\n                element.dataset.for = id;\n\n            }\n        });\n\n    }\n\n    /**\n     * Draws the entry in the Night Order lists for this token.\n     *\n     * @param  {Boolean} [isFirst=true]\n     *         A flag for whether the entry should be for the first night (true)\n     *         or other nights (false). Defaults to true.\n     * @return {DocumentFragment}\n     *         Populated night order entry.\n     */\n    drawNightOrder(isFirst = true) {\n\n        const {\n            id,\n            name,\n            image,\n            firstNight,\n            firstNightReminder,\n            otherNight,\n            otherNightReminder\n        } = this.data;\n\n        return this.constructor.templates.nightOrder.draw({\n            \".js--night-info--wrapper\"(element) {\n\n                element.dataset.id = id;\n                element.dataset.order = (\n                    isFirst\n                    ? firstNight\n                    : otherNight\n                );\n\n            },\n            \".js--night-info--icon\"(element) {\n                element.src = image;\n            },\n            \".js--night-info--role\"(element) {\n                element.textContent = name;\n            },\n            \".js--night-info--ability\"(element) {\n\n                element.textContent = (\n                    isFirst\n                    ? firstNightReminder\n                    : otherNightReminder\n                );\n\n            }\n        });\n\n    }\n\n}\n","/**\n * Interprets the bytes within a string as UTF-8. We need this when importing\n * JSON - for some reason it struggles to understand accented characters.\n *\n * @param  {String} bytes\n *         String to convert.\n * @return {String}\n *         Converted string.\n * @see    https://stackoverflow.com/a/24282873/557019\n * @deprecated\n */\nexport function readUTF8(bytes) {\n\n    const {\n        length\n    } = bytes;\n    let index = bytes.slice(0, 3) === \"\\xEF\\xBB\\xBF\" ? 3 : 0;\n    let string = \"\";\n\n    while (index < length) {\n\n        const byte1 = (bytes[index] || \"\").charCodeAt(0);\n        const byte2 = (bytes[index + 1] || \"\").charCodeAt(0);\n        const byte3 = (bytes[index + 2] || \"\").charCodeAt(0);\n        const byte4 = (bytes[index + 3] || \"\").charCodeAt(0);\n\n        if (byte1 < 0x80) {\n            string += String.fromCharCode(byte1);\n        } else if (byte1 >= 0xC2 && byte1 < 0xE0) {\n\n            string += String.fromCharCode(\n                ((byte1 & 0x1F) << 6)\n                + (byte2 & 0x3F)\n            );\n            index += 1;\n\n        } else if (byte1 > 0XE0 && byte1 < 0xF0) {\n\n            string += String.fromCharCode(\n                ((byte1 & 0xFF) << 12)\n                + ((byte2 & 0x3F) << 6)\n                + (byte3 & 0x3F)\n            );\n            index += 2;\n\n        } else if (byte1 >= 0xF0 && byte1 < 0xF5) {\n\n            let codepoint = (\n                ((byte1 & 0x07) << 18)\n                + ((byte2 & 0x3F) << 12)\n                + ((byte3 & 0x3F) << 6)\n                + (byte4 & 0x3F)\n            );\n            codepoint -= 0x10000;\n            string += String.fromCharCode(\n                (codepoint >> 10) + 0xD800,\n                (codepoint & 0x3FF) + 0xDC00,\n            );\n            index += 3;\n\n        }\n\n        index += 1;\n\n    }\n\n    return string;\n\n}\n\n/**\n * Removes any HTML markup from the given string.\n *\n * @param  {String} string\n *         String from which HTML markup should be removed.\n * @return {String}\n *         String without any HTML markup.\n * @see    https://css-tricks.com/snippets/javascript/strip-html-tags-in-javascript/\n */\nexport function striptags(string) {\n    return String(string).replace(/(<([^>]+)>)/gi, \"\");\n}\n\n/**\n * A simple function that converts the double asterists into strong tags.\n *\n * @param  {String} string\n *         Text to convert.\n * @return {String}\n *         Converted text.\n */\nexport function markdown2html(string) {\n    return string.replace(/\\*\\*([^*]*)\\*\\*/g, \"<strong>$1</strong>\");\n}\n\n/**\n * Replaces placeholders in the given string with the replacements provided.\n *\n * @param  {String} template\n *         String with placeholders to replace.\n * @param  {Array|Object} replacements\n *         Replacements to populate the string.\n * @return {String}\n *         String with replacements.\n */\nexport function supplant(template, replacements) {\n\n    return template.replace(/\\{([^{}]*)\\}/g, (whole, index) => (\n        Object.prototype.hasOwnProperty.call(replacements, index)\n        ? replacements[index]\n        : whole\n    ));\n\n}\n","import {\n    identify,\n    lookupOne\n} from \"../utils/elements.js\";\nimport {\n    markdown2html,\n    striptags\n} from \"../utils/strings.js\";\n\n/**\n * Handles info tokens.\n */\nexport default class InfoToken {\n\n    /**\n     * The prefix for the ID of any info token dialog.\n     * @type {String}\n     */\n    static get ID_PREFIX() {\n        return \"info-token-\";\n    }\n\n    /**\n     * Stores templates that all info tokens will refer to.\n     *\n     * @param {Object} templates\n     *        A list of all templates that the info tokens will refer to.\n     */\n    static setTemplates(templates) {\n\n        /**\n         * A list of all templates that this info tokens will refer to.\n         * @type {Object}\n         */\n        this.templates = templates;\n\n    }\n\n    /**\n     * Stores holders that all info tokens will draw to.\n     *\n     * @param {Object} templates\n     *        A list of all templates that the info tokens will refer to.\n     */\n    static setHolders(holders) {\n\n        /**\n         * A list of all holders that this info tokens will draw to.\n         * @type {Object}\n         */\n        this.holders = holders;\n\n    }\n\n    /**\n     * Converts the text into a unique ID.\n     *\n     * @param  {String} text\n     *         Text to act as a prefix for the ID.\n     * @return {String}\n     *         Unique ID.\n     */\n    static makeId(text) {\n\n        const lower = text.replace(/\\W/g, \"\").toLowerCase();\n\n        return identify({}, `${this.ID_PREFIX}${lower}-`);\n\n    }\n\n    /**\n     * Interprets the given object to make sure it has the correct keys for the\n     * data.\n     *\n     * @param  {Object} data\n     *         Data to interpret.\n     * @param  {String} [raw]\n     *         The raw text to convert into markup (markdown).\n     * @param  {String} markup\n     *         Markup for the dialog box.\n     * @param  {String} [id]\n     *         ID for the dialog box. If ommitted, one will be generated - see\n     *         {@link InfoToken.makeId}.\n     * @param  {String} [colour=\"grey\"]\n     *         Colour of the button and dialog box.\n     * @param  {Boolean} [custom=false]\n     *         Whether or not the info token is custom-made.\n     * @return {Object}\n     *         Interpretted data.\n     */\n    static interpret({ raw, markup, id, colour, custom }) {\n\n        if (raw && !markup) {\n            markup = markdown2html(raw);\n        }\n\n        const text = striptags(markup);\n\n        if (!id) {\n            id = this.makeId(text);\n        }\n\n        const prefix = this.ID_PREFIX;\n\n        if (!id.startsWith(prefix)) {\n            id = `${prefix}${id}`;\n        }\n\n        return {\n            raw,\n            text,\n            markup,\n            id,\n            colour: `var(--${colour || \"grey\"})`,\n            custom: Boolean(custom)\n        };\n\n    }\n\n    /**\n     * @param {Object} data\n     *        Data for the info token.\n     */\n    constructor(data) {\n\n        /**\n         * Interpretted data - see {@link InfoToken.interpret}.\n         * @type {Object}\n         */\n        this.data = this.constructor.interpret(data);\n\n    }\n\n    /**\n     * A helper function for drawing all the elements.\n     */\n    draw() {\n\n        this.drawTrigger();\n        this.drawDialog();\n\n    }\n\n    /**\n     * Draws the button and adds it to the correct holder.\n     */\n    drawTrigger() {\n\n        const {\n            text,\n            id,\n            colour,\n            custom\n        } = this.data;\n        const {\n            holders,\n            templates\n        } = this.constructor;\n        const holder = holders[\n            custom\n            ? \"custom\"\n            : \"button\"\n        ];\n\n        const trigger = templates.button.draw({\n            \".js--info-token--button\"(element) {\n\n                element.textContent = text;\n                element.style.setProperty(\"--bg-colour\", colour);\n                element.dataset.dialog = `#${id}`;\n\n            }\n        });\n\n        holder.append(trigger);\n\n        /**\n         * The wrapper list item that holds the button that triggers\n         * {@link InfoToken#dialog}.\n         * @type {Element}\n         */\n        this.trigger = holder.lastElementChild;\n\n    }\n\n    /**\n     * Draws the dialog and adds it to the correct holder.\n     */\n    drawDialog() {\n\n        const {\n            markup,\n            id,\n            colour,\n            custom\n        } = this.data;\n        const {\n            holders,\n            templates\n        } = this.constructor;\n        const holder = holders.dialog;\n\n        const dialog = templates.dialog.draw({\n            \".js--info-token--dialog\"(element) {\n\n                element.id = id;\n                element.style.setProperty(\"--colour\", colour);\n\n            },\n            \".js--info-token--dialog-text\"(element) {\n                element.innerHTML = markup;\n            },\n            \".js--info-token--actions\"(element) {\n                element.hidden = !custom;\n            }\n        });\n\n        holder.append(dialog);\n\n        /**\n         * The dialog element for this info token.\n         * @type {Element}\n         */\n        this.dialog = holder.lastElementChild;\n\n    }\n\n    /**\n     * Exposes a copy of {@link InfoToken#data}.\n     *\n     * @return {Object}\n     *         A copy of the info token's data.\n     */\n    getData() {\n\n        return {\n            ...this.data\n        };\n\n    }\n\n    /**\n     * Exposes the \"raw\" key from {@link InfoToken#data}.\n     *\n     * @return {String}\n     *         The raw markdown.\n     */\n    getRaw() {\n        return this.data.raw;\n    }\n\n    /**\n     * Exposes {@link InfoToken#trigger}\n     *\n     * @return {Element}\n     *         Trigger element.\n     */\n    getTrigger() {\n        return this.trigger;\n    }\n\n    /**\n     * Exposes {@link InfoToken#dialog}\n     *\n     * @return {Element}\n     *         Dialog element.\n     */\n    getDialog() {\n        return this.dialog;\n    }\n\n    /**\n     * Updates the contents of the info token based on the raw input given.\n     *\n     * @param {String} raw\n     *        Markdown that should be updated.\n     */\n    updateRaw(raw) {\n\n        const {\n            data,\n            dialog,\n            trigger\n        } = this;\n\n        const markup = markdown2html(raw);\n        const text = striptags(markup);\n\n        data.raw = raw;\n        data.text = text;\n        lookupOne(\".js--info-token--button\", trigger).textContent = text;\n        data.markup = markup;\n        lookupOne(\".js--info-token--dialog-text\", dialog).innerHTML = markup;\n\n    }\n\n    /**\n     * Removes the elements that were added to the DOM for this info token.\n     */\n    remove() {\n\n        this.dialog.remove();\n        this.trigger.remove();\n\n    }\n\n}\n","/**\n * Clones an object, including any nested objects.\n *\n * @param  {Object|Array|String|Number|Boolean|null} object\n *         Object to clone.\n * @return {Object|Array|String|Number|Boolean|null}\n *         Cloned object.\n */\nexport function deepClone(object) {\n    return JSON.parse(JSON.stringify(object));\n}\n\n/**\n * Freezes the given object and any nested objects.\n *\n * @param  {Object} object\n *         Object to freeze.\n * @return {Object}\n *         Frozen object.\n */\nexport function deepFreeze(object) {\n\n    if (object && typeof object === \"object\") {\n        Object.values(object).forEach((item) => deepFreeze(item));\n    }\n\n    return Object.freeze(object);\n\n}\n\n/**\n * Removes all the properties from an object.\n *\n * @param {Object} object\n *        Object to empty.\n */\nexport function empty(object) {\n    Object.keys(object).forEach((key) => delete object[key]);\n}\n","import Token from \"./Token.js\";\nimport CharacterToken from \"./CharacterToken.js\";\nimport InfoToken from \"./InfoToken.js\";\nimport Observer from \"./Observer.js\";\nimport {\n    deepClone,\n    deepFreeze\n} from \"../utils/objects.js\";\nimport {\n    lookup\n} from \"../utils/elements.js\";\n\n/**\n * Stores data in localStorage so it can be quickly retrieved.\n */\nexport default class Store {\n\n    /**\n     * The default, empty information from localStorage.\n     * @type {Object}\n     */\n    static defaults = {\n        lookup: {},\n        characters: {},\n        bluffs: {},\n        tokens: [],\n        inputs: {},\n        details: {},\n        infoTokens: [],\n        names: [],\n        height: \"\",\n        version: \"\",\n        user: \"\"\n    };\n\n    /**\n     * A cache of any instances created.\n     * @type {Object}\n     */\n    static cache = Object.create(null);\n\n    /**\n     * Creates an instance of {@link Store} and stores it in {@link Store.cache}\n     * so that it can be retrieved later. If an instance already exists for the\n     * given key, it's returned intead of beaing created anew.\n     *\n     * @param  {String} key\n     *         Storage key.\n     * @return {Store}\n     *         Store instance.\n     */\n    static create(key) {\n\n        const {\n            cache\n        } = this;\n\n        if (!cache[key]) {\n            cache[key] = new this(key);\n        }\n\n        return cache[key];\n\n    }\n\n    /**\n     * Create an instance of {@link Store}. The key is the key used for\n     * localStorage.\n     *\n     * @param {String} key\n     *        Storage key.\n     */\n    constructor(key) {\n\n        /**\n         * Storage key.\n         * @type {String}\n         */\n        this.key = key;\n\n        /**\n         * The stored data.\n         * @type {Object}\n         */\n        this.data = this.read();\n\n        /**\n         * All the token elements that are being remembered.\n         * @type {Array.<Element>}\n         */\n        this.tokens = [];\n\n        /**\n         * The info tokens that have been added.\n         * @type {Array.<String>}\n         */\n        this.infoTokens = [];\n\n        /**\n         * An observer that works behind-the-scenes to allow other code to\n         * listen to changes in the store.\n         */\n        this.observer = new Observer();\n\n    }\n\n    addListener(listener) {\n        this.observer.on(\"written\", listener);\n    }\n\n    /**\n     * Writes {@link Store#data} to localStorage.\n     */\n    write() {\n        window.localStorage.setItem(this.key, JSON.stringify(this.data));\n        this.observer.trigger(\"written\", this.get());\n    }\n\n    /**\n     * Reads the data from localStorage.\n     *\n     * @return {Object}\n     *         The stored data.\n     */\n    read() {\n\n        return {\n            ...deepClone(this.constructor.defaults),\n            ...(JSON.parse(window.localStorage.getItem(this.key)) || {})\n        };\n\n    }\n\n    /**\n     * Deletes the information for the given key from {@link Store#data},\n     * setting that key back to its default value.\n     *\n     * @param {String} key\n     *        Key for the data to remove.\n     */\n    delete(key) {\n\n        const {\n            defaults\n        } = this.constructor;\n\n        if (!Object.prototype.hasOwnProperty.call(defaults, key)) {\n            return;\n        }\n\n        this.data[key] = deepClone(defaults[key]);\n\n        if (key === \"tokens\") {\n\n            this.tokens.length = 0;\n            this.data.bluffs = deepClone(defaults.bluffs);\n\n        }\n\n        if (key === \"info_tokens\") {\n            this.infoTokens.length = 0;\n        }\n\n        this.write();\n\n    }\n\n    /**\n     * Restores all the data in {@link Store#data} to its default value.\n     */\n    deleteAll() {\n\n        Object\n            .keys(this.constructor.defaults)\n            .forEach((key) => this.delete(key));\n\n    }\n\n    /**\n     * Gets a copy of {@link Store#data} that can't be modified.\n     *\n     * @return {Object}\n     *         The stored data.\n     */\n    get() {\n        return deepFreeze(deepClone(this.data));\n    }\n\n    /**\n     * Gets the results from a lookup.\n     *\n     * @param  {String} url\n     *         URL for the lookup.\n     * @return {?}\n     *         The data from the URL.\n     */\n    getLookup(url) {\n        return this.data.lookup[url];\n    }\n\n    /**\n     * Saves the given results for the given lookup.\n     *\n     * @param {String} url\n     *        URL that fetches information.\n     * @param {?} results\n     *        Results from the lookup.\n     */\n    setLookup(url, results) {\n\n        this.data.lookup[url] = results;\n        this.write();\n\n    }\n\n    /**\n     * Stores the character list and the name of the script.\n     *\n     * @param {String|undefined} name\n     *        Name of the script, which may be blank.\n     * @param {Array.<String>} characters\n     *        Array of all the character IDs that are in this script.\n     * @param {String|null} game\n     *        The ID of the homebrew game being used. This will be null for any\n     *        game that only consists of recognised characters.\n     */\n    setCharacters(name, characters, game) {\n\n        const data = {\n            characters\n        };\n\n        if (name) {\n            data.name = name;\n        }\n\n        if (game) {\n            data.game = game;\n        }\n\n        this.data.characters = data;\n        this.write();\n\n    }\n\n    /**\n     * Adds a token to the store so it's existence can be remembered.\n     *\n     * @param {Token} token\n     *        Token to add.\n     */\n    addToken(token) {\n\n        const {\n            data,\n            tokens\n        } = this;\n        const index = tokens.length;\n\n        tokens.push(token);\n        data.tokens[index] = {\n            id: token.getId()\n        };\n        this.write();\n\n        return index;\n\n    }\n\n    /**\n     * Removes the token so it's no longer remembered.\n     *\n     * @param {Token} token\n     *        Token to stop remembering.\n     */\n    removeToken(token) {\n\n        const {\n            data,\n            tokens\n        } = this;\n        const index = tokens.indexOf(token);\n\n        if (index < 0) {\n            return;\n        }\n\n        data.tokens.splice(index, 1);\n        tokens.splice(index, 1);\n        this.write();\n\n    }\n\n    /**\n     * Stores the location of the given token.\n     *\n     * @param {Token} token\n     *        Token whose position should be stored.\n     * @param {Number} left\n     *        The X position of the token.\n     * @param {Number} top\n     *        The Y position of the token.\n     * @param {Number} zIndex\n     *        The Z position of the token.\n     */\n    moveToken(token, left, top, zIndex) {\n\n        const {\n            data,\n            tokens\n        } = this;\n        let index = tokens.indexOf(token);\n\n        if (index < 0) {\n            index = this.addToken(token);\n        }\n\n        Object.assign(data.tokens[index], {\n            left,\n            top,\n            zIndex\n        });\n        this.write();\n\n    }\n\n    /**\n     * Updates the Z position of the given token.\n     *\n     * @param {Token} token\n     *        Token whose Z position should be updated.\n     * @param {Number} zIndex\n     *        The Z positiong of the token.\n     */\n    alignToken(token, zIndex) {\n\n        const {\n            data,\n            tokens\n        } = this;\n        let index = tokens.indexOf(token);\n\n        if (index < 0) {\n            index = this.addToken(token);\n        }\n\n        data.tokens[index].zIndex = zIndex;\n        this.write();\n\n    }\n\n    /**\n     * Toggles the \"dead\" state of the given character.\n     *\n     * @param {CharacterToken} token\n     *        Character whose dead state should be updated in the store.\n     * @param {Boolean} isDead\n     *        The dead state to store.\n     */\n    toggleDead(token, isDead) {\n\n        const {\n            data,\n            tokens\n        } = this;\n        let index = tokens.indexOf(token);\n\n        if (index < 0) {\n            return;\n        }\n\n        data.tokens[index].isDead = isDead;\n\n        if (isDead) {\n            this.setGhostVote(token, true);\n        } else {\n            this.write();\n        }\n\n    }\n\n    /**\n     * Toggles the \"upside-down\" state of the given character.\n     *\n     * @param {CharacterToken} token\n     *        Character whose upside-down state should be updated in the store.\n     * @param {Boolean} isDead\n     *        The upside-down state to store.\n     */\n    rotate(token, isUpsideDown) {\n\n        const {\n            data,\n            tokens\n        } = this;\n        let index = tokens.indexOf(token);\n\n        if (index < 0) {\n            return;\n        }\n\n        data.tokens[index].isUpsideDown = isUpsideDown;\n        this.write();\n\n    }\n\n    /**\n     * Sets the player name for the given character.\n     *\n     * @param {CharacterToken} token\n     *        Character whose player name should be updated in the store.\n     * @param {String} name\n     *        The player name of this character.\n     */\n    setPlayerName(token, name) {\n\n        const {\n            data,\n            tokens\n        } = this;\n        const index = tokens.indexOf(token);\n\n        if (index < 0) {\n            return;\n        }\n\n        data.tokens[index].playerName = name;\n\n        if (!data.names.includes(name)) {\n            data.names.push(name);\n        }\n\n        this.write();\n\n    }\n\n    /**\n     * Sets whether or not the given character has a ghost vote.\n     *\n     * @param {CharacterToken} token\n     *        Character whose ghost vote should be updated in the store.\n     * @param {Boolean} hasGhostVote\n     *        The ghost vote state to store.\n     */\n    setGhostVote(token, hasGhostVote) {\n\n        const {\n            data,\n            tokens\n        } = this;\n        const index = tokens.indexOf(token);\n\n        if (index < 0) {\n            return;\n        }\n\n        data.tokens[index].ghostVote = hasGhostVote;\n        this.write();\n\n    }\n\n    /**\n     * Saves the state of the given input.\n     *\n     * @param {Element} input\n     *        Input element whose value or checked state should be saved.\n     */\n    saveInput(input) {\n\n        const {\n            name,\n            form,\n            type,\n            value,\n            checked,\n            nodeName\n        } = (input || {});\n\n        if (!name || type === \"file\") {\n            return;\n        }\n\n        let selector = `${nodeName.toLowerCase()}[name=\"${name}\"]`;\n        const isCheckbox = type === \"checkbox\";\n\n        if (isCheckbox && input.hasAttribute(\"value\")) {\n            selector += `[value=\"${value}\"]`;\n        }\n\n        const formId = form?.id;\n        if (formId) {\n            selector = `#${formId} ${selector}`;\n        }\n\n        this.data.inputs[selector] = (\n            isCheckbox\n            ? checked\n            : value\n        );\n        this.write();\n\n    }\n\n    /**\n     * Removes all inputs from the data that don't exist. This can be useful for\n     * times when a lot of inputs have been removed, such as when the list of\n     * characters has changed.\n     */\n    removeStaleInputs() {\n\n        const {\n            data\n        } = this;\n\n        data.inputs = Object.fromEntries(\n            Object\n                .entries(data.inputs)\n                .filter(([selector]) => lookup(selector).length)\n        );\n        this.write();\n\n    }\n\n    /**\n     * Saves information about the open/closed state of the given details\n     * element.\n     *\n     * @param {Element} details\n     *        The details element whose open/closed state should be saved.\n     */\n    saveDetails(details) {\n\n        const {\n            id,\n            open\n        } = details || {};\n\n        if (!id) {\n            return;\n        }\n\n        this.data.details[`#${id}`] = open;\n        this.write();\n\n    }\n\n    /**\n     * Adds a custom info token to the data.\n     *\n     * @param {InfoToken} infoToken\n     *        The custom info token to save.\n     */\n    saveInfoToken(infoToken, index) {\n\n        const {\n            infoTokens,\n            data\n        } = this;\n\n        if (infoTokens.includes(infoToken)) {\n            return;\n        }\n\n        if (typeof index === \"number\") {\n            infoTokens[index] = infoToken;\n        } else {\n            infoTokens.push(infoToken);\n            data.infoTokens.push(infoToken.getRaw());\n        }\n\n        this.write();\n\n    }\n\n    /**\n     * Updates the stored data for the given info token. If the info token is\n     * not recognised, no action is taken.\n     *\n     * @param {InfoToken} infoToken\n     *        Info token whose data should be updated.\n     */\n    updateInfoToken(infoToken) {\n\n        const index = this.infoTokens.indexOf(infoToken);\n\n        if (index > -1) {\n\n            this.data.infoTokens[index] = infoToken.getRaw();\n            this.write();\n\n        }\n\n    }\n\n    /**\n     * Removes the given info token from the stored data. If the info token is\n     * not recognised then no action is taken.\n     *\n     * @param {InfoToken} infoToken\n     *        Info token to be removed.\n     */\n    removeInfoToken(infoToken) {\n\n        const {\n            infoTokens,\n            data\n        } = this;\n        const index = infoTokens.indexOf(infoToken);\n\n        if (index > -1) {\n\n            infoTokens.splice(index, 1);\n            data.infoTokens.splice(index, 1);\n            this.write();\n\n        }\n\n    }\n\n    /**\n     * Saves the height of the pad.\n     *\n     * @param {String} height\n     *        Height of the pad, in pixels.\n     */\n    setHeight(height) {\n\n        this.data.height = height;\n        this.write();\n\n    }\n\n    /**\n     * Saves information about the bluffs\n     *\n     * @param {Object} bluffs\n     *        The serialised data about the bluffs. See\n     *        {@link BluffsGroup#serialise}.\n     */\n    setBluffs(bluffs) {\n\n        this.data.bluffs = bluffs;\n        this.write();\n\n    }\n\n    /**\n     * Saves the current version.\n     *\n     * @param {String} version\n     *        The version number, in semver.\n     */\n    setVersion(version) {\n\n        this.data.version = version;\n        this.write();\n\n    }\n\n    /**\n     * Exposes the currently saved version.\n     *\n     * @return {String}\n     *         The saved version number, in semver.\n     */\n    getVersion() {\n        return this.data.version;\n    }\n\n    /**\n     * Sets the user ID. I use this to watch sessions and debug any errors. It\n     * should be unique and contain no identifiable information.\n     *\n     * @param {String} user\n     *        A string identifying the user.\n     */\n    setUser(user) {\n\n        this.data.user = user;\n        this.write();\n\n    }\n\n    /**\n     * Gets the user ID.\n     *\n     * @return {String}\n     *         A string identifying the user.\n     */\n    getUser() {\n        return this.data.user;\n    }\n\n}\n","import CharacterToken from \"./CharacterToken.js\";\nimport ReminderToken from \"./ReminderToken.js\";\nimport Jinx from \"./Jinx.js\";\nimport {\n    defer\n} from \"../utils/promises.js\";\n\n/**\n * Manages all the data for all the tokens, allowing instances of\n * {@link CharacterToken} and {@link ReminderToken} whenever needed.\n */\nexport default class TokenStore {\n\n    /**\n     * An ID that will only match an empty character.\n     * @type {String}\n     */\n    static get EMPTY() {\n        return \"\";\n    }\n\n    /**\n     * The promise that resolves when the tokens data is loaded.\n     * @type {Promise}\n     */\n    static promise = defer();\n\n    /**\n     * Resolves {@link TokenStore.promise} with an instance of\n     * {@link TokenStore} that has the data passed to it.\n     *\n     * @param  {Array.<Object>} data\n     *         Data for the characters.\n     * @return {Promise}\n     *         The promise that resolves with an instance of {@link TokenStore}.\n     */\n    static create(data) {\n        return this.promise.resolve(new this(data));\n    }\n\n    /**\n     * Exposes {@link TokenStore.promise}.\n     *\n     * @return {Promise}\n     *         The promise that can be resolved.\n     */\n    static get() {\n        return this.promise;\n    }\n\n    /**\n     * Checks to see if the given ID looks like it's the ID for a character or\n     * not.\n     *\n     * @param  {String} id\n     *         ID to check.\n     * @return {Boolean}\n     *         true if the ID looks like a character id, false if it doesn't.\n     */\n    static isCharacterId(id) {\n        return !this.isReminderId(id);\n    }\n\n    /**\n     * Checks to see if the given ID looks like it's the ID for a reminder or\n     * not.\n     *\n     * @param  {String} id\n     *         ID to check.\n     * @return {Boolean}\n     *         true if the ID looks like a reminder id, false if it doesn't.\n     */\n    static isReminderId(id) {\n        return (/:\\d+$/).test(id);\n    }\n\n    /**\n     * The script tool used to create IDs with a slightly different format from\n     * our version. This function converts the old ID format into our one.\n     * Examples: was = lil_monsta, now = lilmonsta\n     * Examples: was = al-hadikhia, now = alhadikhia\n     *\n     * @param  {String} id\n     *         Character ID.\n     * @return {String}\n     *         Correctly formatted character ID.\n     */\n    static normaliseId(id) {\n        return id.replace(/[-_]/g, \"\").toLowerCase();\n    }\n\n    /**\n     * Executes the given function when {@link TokenStore.promise} has resolved.\n     * Be aware that this is always asynchronous.\n     *\n     * @param  {Function} handler\n     *         Function to execute when the promise resolves. It's passed an\n     *         instance of {@link TokenStore}.\n     * @return {Promise}\n     *         The promise that has resolved.\n     */\n    static ready(handler) {\n        return this.get().then(handler);\n    }\n\n    /**\n     * @param {Object} data\n     *        Data to store.\n     * @param {Array.<Object>} data.characters\n     *        Character data.\n     * @param {Array.<Object>} data.reminders\n     *        Data for reminders that aren't attached to any character.\n     * @param {Array.<Object>} data.jinxes\n     *        Jinx data.\n     */\n    constructor({\n        characters,\n        reminders,\n        jinxes\n    }) {\n\n        /**\n         * A list of all the {@link CharacterToken} instances.\n         * @type {Object}\n         */\n        this.characters = Object.create(null);\n\n        /**\n        * A list of all the {@link ReminderToken} instances.\n        * @type {Object}\n         */\n        this.reminders = Object.create(null);\n\n        characters.forEach((character) => this.createCharacter(character));\n        reminders?.forEach((reminder, index) => {\n            ReminderToken.addGlobal(this.createReminder(reminder, index));\n        });\n\n        /**\n         * A collection of all jinxes.\n         * @type {Array.<Jinx>}\n         */\n        this.jinxes = [];\n\n        // Add all jines but leave them theoretical.\n        jinxes.forEach(({ id, jinx }) => {\n\n            const character = this.getCharacter(id);\n\n            if (!character) {\n                return;\n            }\n\n            jinx.forEach((trick) => {\n\n                const trickCharacter = this.getCharacter(trick.id);\n\n                if (!trickCharacter) {\n                    return;\n                }\n\n                const newJinx = new Jinx(trickCharacter, trick.reason);\n\n                character.addJinx(newJinx);\n                this.jinxes.push(newJinx);\n\n            });\n\n        });\n\n    }\n\n    /**\n     * Creates a {@link CharacterToken} instance for the given data and stores\n     * it in {@link TokenStore#characters} before returning it.\n     *\n     * @param  {Object} data\n     *         Character data.\n     * @return {CharacterToken}\n     *         CharacterToken instance for the data.\n     */\n    createCharacter(data) {\n\n        const {\n            name,\n            image,\n            reminders = [],\n            remindersGlobal = []\n        } = data;\n        const id = this.constructor.normaliseId(data.id);\n        const character = new CharacterToken(data);\n\n        reminders\n            .concat(remindersGlobal)\n            .forEach((text, index) => {\n\n                character.addReminder(\n                    this.createReminder({\n                        id,\n                        name,\n                        image,\n                        text,\n                        isGlobal: remindersGlobal.includes(text)\n                    }, index)\n                );\n\n            });\n\n        this.characters[id] = character;\n\n        return character;\n\n    }\n\n    /**\n     * Creates a {@link CharacterToken} for a custom character by passing the\n     * data to {@link TokenStore#createCharacter} but with a flag denoting the\n     * fact that it's custom.\n     *\n     * @param  {Object} data\n     *         Character data.\n     * @return {CharacterToken}\n     *         CharacterToken instance for the data.\n     */\n    createCustomCharacter(data) {\n\n        return this.createCharacter({\n            [CharacterToken.custom]: true,\n            ...data\n        });\n\n    }\n\n    /**\n     * Creates a {@link ReminderToken} instance for the given data and stores\n     * it in {@link TokenStore#reminders} before returning it.\n     *\n     * @param  {Object} data\n     *         Reminder data.\n     * @param  {Number} index\n     *         The index of this reminder - used to identify the reminder while\n     *         still allowing for localisation.\n     * @return {ReminderToken}\n     *         ReminderToken instance for the data.\n     */\n    createReminder(data, index) {\n\n        const {\n            name,\n            text,\n            image,\n            isGlobal\n        } = data;\n        const id = this.constructor.normaliseId(data.id);\n        const reminderId = `${id}:${index}`.toLowerCase().replace(/\\s+/g, \"-\");\n        const reminder = new ReminderToken({\n            text,\n            image,\n            isGlobal,\n            id: reminderId,\n            characterId: id,\n            characterName: name\n        });\n\n        this.reminders[reminderId] = reminder;\n\n        return reminder;\n\n    }\n\n    /**\n     * Gets the character for the given ID.\n     *\n     * @param  {String} id\n     *         ID of the character to get.\n     * @return {CharacterToken|undefined}\n     *         The matching instance or undefined if the character isn't found.\n     */\n    getCharacter(id) {\n        return this.characters[this.constructor.normaliseId(id)];\n    }\n\n    /**\n     * Gets the character for the given ID, the same as\n     * {@link TokenStore#getCharacter}, but if the character is custom then\n     * undefined is returned.\n     *\n     * @param  {String} id\n     *         ID of the character to get.\n     * @return {CharacterToken|undefined}\n     *         The matching instance or undefined if the character isn't found.\n     */\n    getOfficialCharacter(id) {\n\n        const character = this.getCharacter(id);\n\n        if (character?.isCustom()) {\n            return undefined;\n        }\n\n        return character;\n\n    }\n\n    /**\n     * Gets a clone of the character for the given ID.\n     *\n     * @param  {String} id\n     *         ID of the character to get.\n     * @return {CharacterToken}\n     *         A clone of the matching instance.\n     * @throws {ReferenceError}\n     *         The id must match an existing character.\n     */\n    getCharacterClone(id) {\n\n        const character = this.getCharacter(id);\n\n        if (!character) {\n            throw new ReferenceError(`Unable to find \"${id}\" character`);\n        }\n\n        return character.clone();\n\n    }\n\n    /**\n     * Gets an array of all characters.\n     *\n     * @return {Array.<CharacterToken>}\n     *         Collection of all characters.\n     */\n    getAllCharacters() {\n        return Object.values(this.characters);\n    }\n\n    /**\n     * Returns an empty character.\n     *\n     * @return {CharacterToken}\n     *         A clone of an empty character.\n     */\n    getEmptyCharacter() {\n        return this.getCharacterClone(this.constructor.EMPTY);\n    }\n\n    /**\n     * Gets the reminder for the given ID.\n     *\n     * @param  {String} id\n     *         ID of the reminder to get.\n     * @return {ReminderToken|undefined}\n     *         The matching instance or undefined if the reminder isn't found.\n     */\n    getReminder(id) {\n        return this.reminders[id];\n    }\n\n    /**\n     * Gets a clone of the reminder for the given ID.\n     *\n     * @param  {String} id\n     *         ID of the reminder to get.\n     * @return {ReminderToken}\n     *         A clone of the matching instance.\n     * @throws {ReferenceError}\n     *         The id must match an existing reminder.\n     */\n    getReminderClone(id) {\n\n        const reminder = this.getReminder(id);\n\n        if (!reminder) {\n            throw new ReferenceError(`Unable to find the \"${id}\" reminder`);\n        }\n\n        return reminder.clone();\n\n    }\n\n    /**\n     * Gets an array of all reminders.\n     *\n     * @return {Array.<ReminderToken>}\n     *         Collection of all reminders.\n     */\n    getAllReminders() {\n        return Object.values(this.reminders);\n    }\n\n    /**\n     * Gets an array of all the jinxes.\n     *\n     * @return {Array.<Jinx>}\n     *         Collection of all jinxes.\n     */\n    getAllJinxes() {\n        return this.jinxes;\n    }\n\n    /**\n     * Adds a jinx to {@link TokenStore#jinxes}.\n     *\n     * @param {Jinx} jinx\n     *        Jinx to add.\n     */\n    addJinx(jinx) {\n        this.jinxes.push(jinx);\n    }\n\n    /**\n     * Gets all the homebrew jinxes that have been registered.\n     *\n     * @return {Array.<Jinx>}\n     *         Collection of all homebrew jinxes.\n     */\n    getAllHomebrewJinxes() {\n        return this.jinxes.filter((jinx) => jinx.getIsHomebrew());\n    }\n\n    /**\n     * Removes all the homebrew jinxes from {@link TokenStore#jinxes}.\n     */\n    removeAllHomebrewJinxes() {\n        this.jinxes = this.jinxes.filter((jinx) => !jinx.getIsHomebrew());\n    }\n\n}\n","/**\n * Creates a Promise that can be resolved externally.\n *\n * @return {Promise}\n *         A Promise that can be externally resolved or rejected.\n */\nexport function defer() {\n\n    let res = () => {};\n    let rej = () => {};\n\n    const promise = new Promise((resolve, reject) => {\n        res = resolve;\n        rej = reject;\n    });\n\n    promise.resolve = (value) => {\n        res(value);\n        return promise;\n    };\n\n    promise.reject = (reason) => {\n        rej(reason);\n        return promise;\n    };\n\n    return promise;\n\n}\n","/**\n * The current language that the user has the application set to. If the\n * language cannot be worked out that it defaults to \"en-GB\".\n * @type {String}\n */\nexport const LANGUAGE = document.documentElement.lang || \"en-GB\";\n","import Template from \"./Template.js\";\nimport {\n    LANGUAGE\n} from \"../constants/language.js\";\n\n/**\n * Keeps track of the player names.\n */\nexport default class Names {\n\n    /**\n     * Creates a version of {@link Names}. The instance is cached and stored so\n     * that it can be returned each time this function is called instead of\n     * creating a new object.\n     *\n     * @return {Names}\n     *         Instance of {@link Names}.\n     */\n    static create() {\n\n        if (!this.instance) {\n\n            /**\n             * An instance of {@link Names} that can be returned each time\n             * instead of being re-created.\n             * @type {this}\n             */\n            this.instance = new this();\n\n        }\n\n        return this.instance;\n\n    }\n\n    /**\n     * Creates the names.\n     */\n    constructor() {\n\n        /**\n         * A collection of the names that have been saved. The names are always\n         * stored in alphabetical order, based on the current locale.\n         * @type {Array.<String>}\n         */\n        this.names = [];\n\n    }\n\n    /**\n     * Sets {@link Names#template}. The current instance is returned to allow\n     * for chaining.\n     *\n     * @param {Template} template\n     *        The template that will be used to populate datalists.\n     */\n    setTemplate(template) {\n\n        /**\n         * The template that's used to populate datalists.\n         * @type {Template}\n         */\n        this.template = template;\n\n        return this;\n\n    }\n\n    /**\n     * Sets {@link Names#observer}. The current instance is returned to allow\n     * for chaining.\n     *\n     * @param {Observer} observer\n     *        Observer that will trigger events at key moments.\n     */\n    setObserver(observer) {\n\n        /**\n         * Observer that will trigger events at key moments.\n         * @type {Observer}\n         */\n        this.observer = observer;\n\n        return this;\n\n    }\n\n    /**\n     * Adds a name to {@link Names#names} but only if the name isn't already in\n     * that list. If the list changes then an event is triggered.\n     *\n     * @param  {String} name\n     *         Name to add.\n     */\n    add(name) {\n\n        const {\n            names,\n            observer\n        } = this;\n        const {\n            length\n        } = names;\n\n        if (name && !names.includes(name)) {\n\n            names.push(name);\n            this.alphabetise();\n            observer.trigger(\"names-added\", { name, names: [...names] });\n\n        }\n\n    }\n\n    /**\n     * Sorts {@link Names#names} alphabetically based on the current language.\n     * @return {[type]} [description]\n     */\n    alphabetise() {\n        this.names.sort((a, b) => a.localeCompare(b, LANGUAGE));\n    }\n\n    /**\n     * Removes all names from {@link Names#names}.\n     */\n    clear() {\n\n        this.names.length = 0;\n        observer.trigger(\"names-cleared\");\n\n    }\n\n    /**\n     * A helper function that sets the value of the given element to the given\n     * constant. As a separate function, it doesn't need to be re-created each\n     * time that {@link Names#drawList} is called.\n     *\n     * @param {Element} element\n     *        Element whose value should be set.\n     * @param {String} content\n     *        Content of the value to set.\n     */\n    // static setValue(element, content) {\n    //     element.value = content;\n    // }\n\n    /**\n     * Draws a list of elements for each entry in {@link Names#names}.\n     *\n     * @return {Array.<Element>}\n     *         Element for each of the names.\n     * @throws {Error}\n     *         The template {@link Names#template} must be set.\n     */\n    drawList() {\n\n        const {\n            constructor,\n            names,\n            template\n        } = this;\n\n        if (!template) {\n            throw new Error(\"Cannot draw a list because the template is not set\");\n        }\n\n        return names.map((name) => template.draw({\n            \".js--player-name--option\"(element) {\n                element.value = name;\n            }\n        }));\n\n    }\n\n    /**\n     * Binds a handler to an event that's triggered on {@link Names#observer}.\n     *\n     * @param {String} eventName\n     *        Name of the event to listen for.\n     * @param {Function} handler\n     *        Handler to execute when the event is heard.\n     */\n    on(eventName, handler) {\n        this.observer.on(eventName, handler);\n    }\n\n}\n","/**\n * Fetches information from the given URL and stores it in the given store. The\n * URL is checked against the store to see if the data already exists and only\n * performs a lookup if it needs to.\n *\n * @param  {String} key\n *         The key for identifying the URL. This allows the URL to be updated\n *         with a hash, making it unique, while also allowing it to be cached.\n * @param  {String} url\n *         URL from which to get the data.\n * @param  {Store} store\n *         Store that will store the results.\n * @return {Promise}\n *         Promise that resolves with the data from the lookup.\n */\nexport function fetchFromStore(key, url, store) {\n\n    const results = store.getLookup(key);\n\n    if (results !== undefined) {\n        return Promise.resolve(results);\n    }\n\n    return fetch(url)\n        .then((response) => response.json())\n        .then((json) => {\n\n            store.setLookup(key, json);\n            return json;\n\n        });\n\n}\n\n/**\n * Helper function for POSTing JSON data to the given URL.\n *\n * @param  {String} url\n *         URL to POST the data to.\n * @param  {Array|Object|String|Boolean|Number|null} data\n *         JSON data to POST.\n * @return {Promise}\n *         A promise that resolves with the response from the server, converted\n *         into JSON.\n */\nexport function post(url, data) {\n\n    return fetch(url, {\n        method: \"POST\",\n        mode: \"cors\",\n        cache: \"no-cache\",\n        credentials: \"same-origin\",\n        headers: {\n            \"Accept\": \"application/json\",\n            \"Content-type\": \"application/json\"\n        },\n        redirect: \"follow\",\n        referrerPolicy: \"no-referrer\",\n        body: JSON.stringify(data)\n    }).then((response) => response.json());\n\n}\n","import Store from \"../../classes/Store.js\";\nimport Observer from \"../../classes/Observer.js\";\nimport Template from \"../../classes/Template.js\";\nimport CharacterToken from \"../../classes/CharacterToken.js\";\nimport ReminderToken from \"../../classes/ReminderToken.js\";\nimport TokenStore from \"../../classes/TokenStore.js\";\nimport Dialog from \"../../classes/Dialog.js\";\nimport Names from \"../../classes/Names.js\";\nimport {\n    fetchFromStore\n} from \"../../utils/fetch.js\";\nimport {\n    lookup,\n    lookupOne,\n    lookupOneCached\n} from \"../../utils/elements.js\";\nimport {\n    LANGUAGE\n} from \"../../constants/language.js\";\n\nconst store = Store.create(\"pocket-grimoire\");\nconst gameObserver = Observer.create(\"game\");\n\nfetchFromStore(`characters_${LANGUAGE}`, URLS.characters, store).then((characters) => {\n    gameObserver.trigger(\"characters-loaded\", { characters });\n});\n\nfetchFromStore(`jinxes_${LANGUAGE}`, URLS.jinxes, store).then((jinxes) => {\n    gameObserver.trigger(\"jinxes-loaded\", { jinxes });\n});\n\nfetchFromStore(\"game\", URLS.game, store).then((breakdown) => {\n    gameObserver.trigger(\"team-breakdown-loaded\", { breakdown });\n});\n\nCharacterToken.setTemplates({\n    token: Template.create(lookupOne(\"#character-template\")),\n    list: Template.create(lookupOne(\"#character-list-template\")),\n    select: Template.create(lookupOne(\"#character-select-template\")),\n    nightOrder: Template.create(lookupOne(\"#night-info-template\"))\n});\nReminderToken.setTemplates({\n    token: Template.create(lookupOne(\"#reminder-template\")),\n    list: Template.create(lookupOne(\"#reminder-list-template\"))\n});\nNames.create()\n    .setTemplate(Template.create(lookupOne(\"#player-name-template\")))\n    .setObserver(new Observer());\n\nPromise.all([\n    new Promise((resolve) => {\n        gameObserver.on(\"characters-loaded\", ({ detail }) => {\n            resolve(detail.characters);\n        });\n    }),\n    new Promise((resolve) => {\n        gameObserver.on(\"jinxes-loaded\", ({ detail }) => {\n            resolve(detail.jinxes);\n        });\n    })\n]).then(([ characters, jinxes ]) => {\n\n    TokenStore.create({\n        characters: [\n            // Create an empty character which we can use as a token placeholder.\n            {\n                id: TokenStore.EMPTY,\n                image: \"data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7\",\n                ability: I18N.emptyCharacterAbility,\n                [CharacterToken.empty]: true,\n            },\n            ...characters\n        ],\n        reminders: [\n            {\n                id: TokenStore.EMPTY,\n                name: \"\",\n                text: I18N.goodTeam,\n                image: \"/build/img/icons/townsfolk.webp\",\n                isGlobal: true\n            },\n            {\n                id: TokenStore.EMPTY,\n                name: \"\",\n                text: I18N.evilTeam,\n                image: \"/build/img/icons/demon.webp\",\n                isGlobal: true\n            }\n        ],\n        jinxes\n    });\n\n});\n\n// Delegate this event for two reasons:\n// 1. We can add dialogs dynamically and they'll still work.\n// 2. It's more efficient to only create the instance when it's needed.\ndocument.body.addEventListener(\"click\", ({ target }) => {\n\n    if (target.hasAttribute(\"data-dialog\") && !target.dialog) {\n\n        target.dialog = Dialog.createFromTrigger(target);\n        target.dialog.show();\n\n    }\n\n});\n\nlookup(\"input[data-filter-list]\").forEach((input) => {\n\n    input.addEventListener(\"change\", ({ target }) => {\n\n        const list = lookupOneCached(target.dataset.filterList);\n\n        if (!list) {\n            return;\n        }\n\n        list.classList.toggle(\"is-show-all\", target.checked);\n\n    });\n\n});\n\nlookupOne(\"#locale-form\").addEventListener(\"submit\", (e) => {\n    e.preventDefault();\n    window.location.href = lookupOneCached(\"#select-locale\").value;\n});\n\nlookupOneCached(\"#select-locale\").addEventListener(\"change\", ({ target }) => {\n    target.form.requestSubmit();\n});\n\nfunction setTrackWidth(input) {\n\n    const {\n        min,\n        max,\n        value\n    } = input;\n\n    input.style.setProperty(\n        \"--size\",\n        ((value - min) * 100) / (max - min)\n    );\n\n}\n\nconst rangeObserver = new MutationObserver((entries) => {\n\n    entries.forEach(({ type, target }) => {\n\n        if (type == \"attributes\") {\n            setTrackWidth(target);\n        }\n\n    });\n\n});\n\nlookup(\"input[type=\\\"range\\\"][data-output]\").forEach((input) => {\n\n    const output = lookupOne(input.dataset.output);\n\n    input.addEventListener(\"input\", () => {\n\n        setTrackWidth(input);\n\n        if (output) {\n            output.value = input.value\n        }\n\n    });\n\n    setTrackWidth(input);\n    rangeObserver.observe(input, {\n        attributes: true,\n        attributeFilter: [\"min\", \"max\", \"value\"]\n    });\n\n});\n","import Observer from \"../../classes/Observer.js\";\nimport TokenStore from \"../../classes/TokenStore.js\";\nimport Dialog from \"../../classes/Dialog.js\";\nimport {\n    lookup,\n    lookupOne,\n    lookupOneCached,\n    getLabelText,\n    announceInput\n} from \"../../utils/elements.js\";\nimport {\n    supplant\n} from \"../../utils/strings.js\";\nimport {\n    post\n} from \"../../utils/fetch.js\";\n\n/**\n * Checks to see if the given data looks like a script.\n *\n * @param  {Array.<Object|String>} json\n *         Data to check.\n * @return {Boolean}\n *         true if the data looks like a script, false if it doesn't.\n */\nfunction isScriptJson(json) {\n\n    return (\n        Array.isArray(json)\n        && json.length\n        && json.every((item) => (\n            (\n                typeof item === \"object\"\n                && typeof item?.id === \"string\"\n            )\n            || typeof item === \"string\"\n        ))\n    );\n\n}\n\n/**\n * Checks to see if the given json looks like it contains any homebrew content.\n *\n * @param  {Array.<Object>} json\n *         Data to check.\n * @return {Boolean}\n *         true if the data seems to contain any homebrew, false if it doesn't\n *         seem to contain any homebrew.\n */\nfunction containsHomebrew(json) {\n\n    return json\n        .filter(({ id }) => id !== \"_meta\")\n        .some(({ ability }) => typeof ability === \"string\");\n\n}\n\n/**\n * Announces that a script has been added to the grimoire.\n *\n * @param {String} name\n *        Name of the script. This may be an empty string.\n * @param {Array.<Object>} characters\n *        Characters in the script.\n * @param {String|null} [game=null]\n *        The ID of the homebrew script that was uploaded. This will be null for\n *        a game that only consists of recognised characters.\n */\nfunction announceScript(name, characters, game = null) {\n\n    Observer.create(\"game\").trigger(\"characters-selected\", {\n        name,\n        characters,\n        game\n    });\n    Dialog.create(lookupOneCached(\"#edition-list\")).hide();\n\n}\n\n/**\n * Shows the given error message on the given input.\n *\n * @param {Element} input\n *        Element that should show an error.\n * @param {String} error\n *        Error message to show.\n */\nfunction showInputError(input, error) {\n\n    input.setCustomValidity(error);\n    input.form.reportValidity();\n\n}\n\n// A map of any common mistakes that we find in the homebrew code.\nconst normalMap = {\n    team: {\n        // The American spelling has one L, but I'm British and I use two L's.\n        \"traveler\": \"traveller\"\n    }\n};\n\n/**\n * Fixes any common mistakes in the homebrew code.\n *\n * @param  {Array} json\n *         Homebrew JSON.\n * @return {Array}\n *         The homebrew JSON, mapped so that it works with our system.\n */\nfunction normaliseHomebrew(json) {\n\n    return json.map((entry) => {\n\n        // An official character may be a simple string rather than the\n        // old-school approach of an object with an \"id\" key.\n        if (typeof entry === \"string\") {\n            entry = { id: entry };\n        }\n\n        Object.entries(normalMap).forEach(([key, map]) => {\n            entry[key] = map[entry[key]] || entry[key];\n        });\n\n        if (Array.isArray(entry.image)) {\n            entry.image = entry.image[0];\n        }\n\n        if (entry.team && !entry.image) {\n            entry.image = `/build/img/icons/${entry.team}.png`;\n        }\n\n        return entry;\n\n    });\n\n}\n\n/**\n * Removes the \"_meta\" entry from the given JSON data, if it exists, and returns\n * the name within that entry. If the entry isn't found, an empty string is\n * returned.\n *\n * @param  {Array.<Object>} json\n *         JSON data whose \"_meta\" entry should be removed.\n * @return {String}\n *         Name of the script, taking from the \"_meta\" entry, or an empty string\n *         if the name cannot be found.\n */\nfunction extractMetaEntry(json) {\n\n    let name = \"\";\n    const metaIndex = json.findIndex(({ id }) => id === \"_meta\");\n\n    if (metaIndex > -1) {\n\n        name = json[metaIndex].name;\n        json.splice(metaIndex, 1);\n\n    }\n\n    return name;\n\n}\n\n/**\n * Sets the loading state of the form, setting the state of the loading\n * animation in the submit button.\n *\n * @param {Element} form\n *        Form whose loading state should be set.\n * @param {Boolean} state\n *        true if the form is loading, false if it's not.\n */\nfunction setFormLoadingState(form, state) {\n\n    if (\n        form.dataset.isLoading === state\n        || String(form.dataset.isLoading) === String(state)\n    ) {\n        return;\n    }\n\n    form.dataset.isLoading = state;\n\n    const submit = lookupOneCached(\"[type=\\\"submit\\\"]\", form);\n    submit.classList.toggle(\"is-loading\", state);\n\n    const progress = lookupOneCached(\"[role=\\\"progressbar\\\"]\", submit);\n    progress.setAttribute(\"aria-busy\", state);\n    progress.setAttribute(\n        \"aria-valuenow\",\n        (\n            state\n            ? \"0\"\n            : progress.getAttribute(\"aria-valuemax\")\n        )\n    );\n\n}\n\n/**\n * Converts a character entry into a normalised ID.\n *\n * @param  {Object|String} item\n *         Item whose normalised ID should be returned.\n * @return {String}\n *         Normalised character ID.\n */\nfunction convertCharacterId(item) {\n\n    let id = \"\";\n\n    if (typeof item === \"string\") {\n        id = item;\n    } else if (item && typeof item === \"object\") {\n        id = item.id || \"\";\n    }\n\n    return TokenStore.normaliseId(id);\n\n}\n\n/**\n * Processes the JSON to set up the game.\n *\n * @param  {Object} json\n *         JSON to process.\n * @param  {Element} json.form\n *         The form that was submitted so the JSON could be processed.\n * @param  {Array.<Object>} json.json\n *         Script to process.\n * @param  {Element} json.input\n *         File input that uploads scripts.\n * @param  {TokenStore} json.store\n *         Store for any data.\n * @return {Promise}\n *         An empty, resolved Promise.\n */\nfunction processJSON({\n    form,\n    json,\n    input,\n    store\n}) {\n\n    if (!isScriptJson(json)) {\n\n        showInputError(input, I18N.invalidScript);\n        return Promise.resolve();\n\n    }\n\n    if (containsHomebrew(json)) {\n\n        const normalised = normaliseHomebrew(json);\n\n        setFormLoadingState(form, true);\n\n        return post(URLS.homebrew, normalised)\n            .then(({ success, game, message, reasons }) => {\n\n                setFormLoadingState(form, false);\n\n                if (success) {\n\n                    announceScript(\n                        extractMetaEntry(normalised),\n                        normalised.map((item) => (\n                            store.getOfficialCharacter(convertCharacterId(item))\n                            || store.createCustomCharacter(item)\n                        )),\n                        game\n                    );\n                    Dialog.create(lookupOneCached(\"#edition-list\")).hide();\n\n                } else {\n\n                    if (reasons && reasons.length) {\n                        message += \"\\n\\n\" + reasons.join(\"\\n\");\n                    }\n\n                    showInputError(input, message);\n\n                }\n\n        });\n\n    }\n\n    const name = extractMetaEntry(json);\n    const characters = json\n        .map((item) => store.getCharacter(convertCharacterId(item)))\n        .filter(Boolean);\n\n    if (!characters.length) {\n\n        showInputError(input, I18N.noCharacters);\n        return Promise.resolve();\n\n    }\n\n    announceScript(name, characters);\n    return Promise.resolve();\n\n}\n\n/**\n * Sets the validation on the given fields.\n *\n * @param {Array.<Element>} fields\n *        Input fields that should have their validity set.\n * @param {Boolean} isVisible\n *        true if the fields are visible and their validity should be set, false\n *        if they're not visible and their validity should be removed.\n */\nfunction setFieldsValidity(fields, isVisible) {\n\n    if (isVisible) {\n\n        const inputted = fields.find((field) => field.value);\n        fields.forEach((field) => {\n            field.required = !inputted || field === inputted;\n        });\n\n    } else {\n\n        fields.forEach((field) => {\n\n            field.setCustomValidity(\"\");\n            field.required = false;\n\n        });\n\n    }\n\n}\n\nconst form = lookupOne(\"#select-edition-form\");\nconst fileInput = lookupOne(\"#custom-script-upload\");\nconst fileInputRender = fileInput.nextElementSibling;\nconst urlInput = lookupOne(\"#custom-script-url\");\nconst pasteInput = lookupOne(\"#custom-script-paste\");\nconst uploader = lookupOne(\"#custom-script\");\nconst radios = lookup(\"[name=\\\"edition\\\"]\", form);\nconst customInputs = [fileInput, urlInput, pasteInput];\n\nradios.forEach((radio) => {\n\n    radio.addEventListener(\"input\", ({ target }) => {\n\n        const isCustom = target.value === \"custom\";\n\n        uploader.hidden = !isCustom;\n        setFieldsValidity(customInputs, isCustom);\n\n    });\n\n});\n\ncustomInputs.forEach((input) => {\n\n    input.addEventListener(\"input\", () => {\n\n        input.setCustomValidity(\"\");\n        setFieldsValidity(customInputs, true);\n\n    });\n\n});\n\nform.addEventListener(\"submit\", (e) => {\n\n    e.preventDefault();\n\n    if (form.dataset.isLoading === \"true\") {\n        return;\n    }\n\n    const radio = radios.find(({ checked }) => checked);\n    const edition = radio?.value;\n\n    if (!edition) {\n        return;\n    }\n\n    TokenStore.ready((tokenStore) => {\n\n        if (edition === \"custom\") {\n\n            if (urlInput.value) {\n\n                setFormLoadingState(form, true);\n\n                const myURL = supplant(window.decodeURIComponent(URLS.url), {\n                    url: window.encodeURIComponent(urlInput.value)\n                });\n\n                fetch(myURL)\n                    .catch((error) => {\n                        showInputError(urlInput, error.message);\n                        setFormLoadingState(form, false);\n                    })\n                    .then((response) => response.json())\n                    .catch(() => {\n                        showInputError(urlInput, I18N.invalidScript);\n                        setFormLoadingState(form, false);\n                        return null;\n                    })\n                    .then((json) => {\n\n                        if (json === null) {\n                            return;\n                        }\n\n                        if (!json.success) {\n                            showInputError(urlInput, json.message);\n                            setFormLoadingState(form, false);\n                            return;\n                        }\n\n                        processJSON({\n                            form,\n                            json: json.data,\n                            input: urlInput,\n                            store: tokenStore\n                        }).then(() => setFormLoadingState(form, false));\n\n                    });\n\n            } else if (fileInput.files.length) {\n\n                const reader = new FileReader();\n\n                reader.addEventListener(\"load\", ({ target }) => {\n\n                    let json = [];\n\n                    try {\n                        json = JSON.parse(target.result);\n                    } catch (error) {\n                        return showInputError(fileInput, I18N.invalidScript);\n                    }\n\n                    processJSON({\n                        form,\n                        json,\n                        input: fileInput,\n                        store: tokenStore\n                    })\n\n                });\n\n                reader.readAsText(fileInput.files[0]);\n\n            } else if (pasteInput.value) {\n\n                let json = [];\n\n                try {\n                    json = JSON.parse(pasteInput.value);\n                } catch (error) {\n                    return showInputError(pasteInput, I18N.invalidScript);\n                }\n\n                processJSON({\n                    form,\n                    json,\n                    input: pasteInput,\n                    store: tokenStore\n                })\n\n            }\n\n        } else {\n\n            announceScript(\n                getLabelText(radio),\n                tokenStore\n                    .getAllCharacters()\n                    .filter((character) => character.getEdition() === edition)\n            );\n\n        }\n\n    });\n\n});\n\nfileInput.addEventListener(\"input\", () => {\n\n    const {\n        value\n    } = fileInput;\n\n    fileInput.setCustomValidity(\"\");\n    fileInputRender.dataset.value = (\n        value\n        ? value.slice(value.lastIndexOf(\"\\\\\") + 1)\n        : fileInputRender.dataset.placeholder\n    );\n\n    if (value && urlInput.value) {\n\n        urlInput.value = \"\";\n        announceInput(urlInput);\n\n    }\n\n});\n\nurlInput.addEventListener(\"input\", () => {\n\n    urlInput.setCustomValidity(\"\");\n\n    if (urlInput.value && fileInput.value) {\n\n        fileInput.value = \"\";\n        announceInput(fileInput);\n\n    }\n\n});\n\nDialog.create(lookupOne(\"#edition-list\")).on(Dialog.HIDE, () => {\n\n    fileInput.value = \"\";\n    announceInput(fileInput);\n    urlInput.value = \"\";\n    announceInput(urlInput);\n\n});\n","/**\n * Creates an array that's a shuffled version of the given array. The original\n * array is not modified.\n * Schwartzian transform.\n *\n * @param  {Array} array\n *         Array to shuffle.\n * @return {Array}\n *         Shuffled array.\n */\nexport function shuffle(array) {\n\n    const numbers = window.crypto.getRandomValues(\n        new Uint16Array(array.length)\n    );\n\n    return Array.from(array, (value, i) => ({\n            value,\n            sort: numbers[i]\n        }))\n        .sort((a, b) => a.sort - b.sort)\n        .map(({ value }) => value);\n\n}\n\n/**\n * Groups the items in the given array based on the the getGroup function.\n *\n * @param  {Array} array\n *         Array whose items should be grouped up.\n * @param  {Function} getGroup\n *         A function that should create the name of the group. It's passed the\n *         item and the index.\n * @return {Object}\n *         An object with the groups as keys and all the matching items as\n *         values.\n */\nexport function groupBy(array, getGroup) {\n\n    return array.reduce((grouped, item, i) => {\n\n        const group = getGroup(item, i);\n\n        if (!grouped[group]) {\n            grouped[group] = [];\n        }\n\n        grouped[group].push(item);\n\n        return grouped;\n\n    }, Object.create(null));\n\n}\n","/**\n * Clamps the given value so that it will be between the given min and max\n * values.\n *\n * @param  {Number} min\n *         Minimum possible value.\n * @param  {Number} value\n *         Value to clamp.\n * @param  {Number} max\n *         Maximum possible value.\n * @return {Number}\n *         Clamped value.\n */\nexport function clamp(min, value, max) {\n    return Math.max(min, Math.min(value, max));\n}\n\n/**\n * Parses a version number, in semver, into an array of numbers.\n *\n * @param  {String} semver\n *         A version number in semver, such as \"1.2.3\" or \"4.5\".\n * @return {Array.<Number>}\n *         The version number as an array of numbers.\n */\nexport function parseVersion(semver) {\n    return Object.assign([0, 0, 0], semver.split(\".\").map(Number));\n}\n\n/**\n * Compares two semver versions. The function will return one of three numbers:\n * -1 if version1 is less than version2.\n * 0 if version1 and version2 are the same.\n * 1 if version1 is more than version2.\n * This is consistent with Array#sort()\n *\n * @param  {String} version1\n *         Version number 1.\n * @param  {String} version2\n *         Version number 2.\n * @return {Number}\n *         Comparison number.\n */\nexport function compareVersions(version1, version2) {\n\n    const parts1 = parseVersion(version1);\n    const parts2 = parseVersion(version2);\n\n    const number = parts1.reduce((number, part, i) => {\n\n        if (number === 0) {\n            number = part - parts2[i];\n        }\n\n        return number;\n\n    }, 0);\n\n    return clamp(-1, number, 1);\n\n}\n\n/**\n * Converts the given number to its positive integer.\n *\n * @param  {Number} number\n *         Number to convert.\n * @return {Number}\n *         Positive integer, or NaN if the number can't be parsed.\n */\nexport function toPosInt(number) {\n    return Math.floor(Math.abs(number));\n}\n\n/**\n * Executes a handler a set number of times. The number of times is converted\n * into a positive integer (ses {@link toPosInt}) and returned. The handler is\n * passed the current index and the maximum number of times that the handler\n * will be called.\n *\n * @param  {Number} number\n *         Number of times to execute the given handler.\n * @param  {Function} handler\n *         Handler to execute.\n * @param  {?} [context]\n *         Optional context for the handler.\n * @return {Number}\n *         The number of times that the handler was executed.\n */\nexport function times(number, handler, context) {\n\n    const max = toPosInt(number) || 0;\n    let index = 0;\n\n    while (index < max) {\n\n        handler.call(context, index, max);\n        index += 1;\n\n    }\n\n    return max;\n\n}\n\n/**\n * Converts the given degrees into radians\n *\n * @param  {Number} degrees\n *         Degrees to convert.\n * @return {Number}\n *         Equivalent radians.\n */\nexport function toRadians(degrees) {\n    return (Math.PI / 180) * degrees;\n}\n\n/**\n * Checks to see if the given value is numeric. This is not necessarily the same\n * as being a number because a numeric string would return true.\n *\n * @param  {?} value\n *         Value to check.\n * @return {Boolean}\n *         true if the given value is a number or numeric string, false\n *         otherwise.\n */\nexport function isNumeric(value) {\n\n    const parsed = window.parseFloat(value);\n\n    return !Number.isNaN(parsed) && Number.isFinite(parsed);\n\n}\n","import Observer from \"../../classes/Observer.js\";\nimport TokenStore from \"../../classes/TokenStore.js\";\nimport Dialog from \"../../classes/Dialog.js\";\nimport {\n    lookup,\n    lookupOne,\n    lookupCached,\n    lookupOneCached,\n    replaceContentsMany,\n    announceInput,\n    getIndex,\n} from \"../../utils/elements.js\";\nimport {\n    shuffle,\n    groupBy\n} from \"../../utils/arrays.js\";\nimport {\n    clamp,\n    times\n} from \"../../utils/numbers.js\";\nimport {\n    supplant\n} from \"../../utils/strings.js\";\n\nconst gameObserver = Observer.create(\"game\");\nconst tokenObserver = Observer.create(\"token\");\n\n/**\n * Sets the totals for each team based on the breakdown that's given.\n *\n * @param {Object} breakdown\n *        Breakdown of the numbers for the teams.\n */\nfunction setTotals(breakdown) {\n\n    Object.entries(breakdown).forEach(([team, count]) => {\n\n        lookupCached(`[data-team=\"${team}\"] .js--character-select--total`)\n            .forEach((element) => {\n                element.textContent = count;\n            });\n\n    });\n\n}\n\n/**\n * Highlights randomly selected entries in each of the teams.\n *\n * @param {String} team\n *        Name of the team that should have entries randomly highlighted.\n * @param {Number} count\n *        The number of randomly selected items that should be highlighted.\n */\nfunction highlightRandomInTeam(team, count) {\n\n    // Don't cache this since they will change if a different edition is chosen.\n    const inputs = lookup(`[data-team=\"${team}\"] [name=\"character\"]`);\n\n    if (!inputs.length) {\n        return;\n    }\n\n    const chosen = shuffle(inputs).slice(0, count);\n\n    inputs.forEach((input) => {\n\n        const isChecked = input.checked;\n        input.checked = chosen.includes(input);\n\n        if (isChecked) {\n            lookupOne(`input[name=\"count-${input.value}\"]`).value = 1;\n        }\n\n        if (input.checked !== isChecked) {\n            announceInput(input);\n        }\n\n    });\n\n}\n\ngameObserver.on(\"team-breakdown-loaded\", ({ detail }) => {\n\n    const playerCount = lookupOneCached(\"#player-count\");\n\n    playerCount.addEventListener(\"input\", () => {\n\n        gameObserver.trigger(\"player-count\", {\n            count: Number(playerCount.value)\n        });\n\n    });\n\n    function getBreakdown() {\n\n        const {\n            breakdown\n        } = detail;\n\n        return breakdown[clamp(0, playerCount.value - 5, breakdown.length - 1)];\n\n    }\n\n    playerCount.addEventListener(\"input\", () => setTotals(getBreakdown()));\n    setTotals(getBreakdown());\n\n    lookupOne(\"#player-select-random\").addEventListener(\"click\", () => {\n\n        let total = 0;\n\n        Object.entries(getBreakdown()).forEach(([team, count]) => {\n\n            highlightRandomInTeam(team, count);\n            total += count;\n\n        });\n\n        highlightRandomInTeam(\"traveller\", playerCount.value - total);\n\n    });\n\n});\n\ngameObserver.on(\"characters-selected\", ({ detail }) => {\n\n    const {\n        characters\n    } = detail;\n    const teams = groupBy(characters, (character) => character.getTeam());\n\n    lookupCached(\"[data-team]\").forEach((wrapper) => {\n\n        // Populate the team sections.\n        const team = wrapper.dataset.team;\n        const isTeamPopulated = Array.isArray(teams[team]);\n        wrapper.hidden = !isTeamPopulated;\n\n        replaceContentsMany(\n            lookupOneCached(\".js--character-select--list\", wrapper),\n            (teams[team] || []).map((character) => character.drawSelect())\n        );\n\n        // Deselect any checkboxes and set the counts to zero.\n        lookup(\".js--character-select--input\", wrapper).forEach((input) => {\n            input.checked = false;\n        });\n\n        lookupOneCached(\".js--character-select--count\", wrapper).textContent = 0;\n\n        // Store the \"count\" inputs.\n        // This allows us to quickly add all the values together to get the\n        // number of tokens selected in this group, regardless of whether tokens\n        // have been added, removed, or duplicated.\n        wrapper.countInputs = lookup(\"input[name^=\\\"count\\\"]\", wrapper);\n\n    });\n\n    // Make sure the Number of players can't exceed the number of characters.\n    let maxPlayers = 15;\n    maxPlayers += Math.min((teams.traveller || []).length, 5);\n    maxPlayers = Math.min(maxPlayers, characters.length);\n    const playerCount = lookupOneCached(\"#player-count\");\n\n    playerCount.max = maxPlayers;\n\n    if (playerCount.value >= maxPlayers) {\n\n        playerCount.value = maxPlayers;\n        announceInput(playerCount);\n\n    }\n\n    // Enable the \"Select Characters\" button.\n    lookupOneCached(\"#select-characters\").disabled = false;\n\n});\n\nlookupOne(\"#toggle-abilities\").addEventListener(\"input\", ({ target }) => {\n\n    lookupCached(\"[data-team]\").forEach((wrapper) => {\n        wrapper.classList.toggle(\"is-hide-abilities\", !target.checked);\n    });\n\n});\n\nlookupOne(\"#toggle-duplicates\").addEventListener(\"input\", ({ target }) => {\n\n    const {\n        checked\n    } = target;\n\n    lookupCached(\"[data-team]\").forEach((wrapper) => {\n\n        wrapper.classList.toggle(\"is-show-duplicates\", checked);\n\n        if (!checked) {\n\n            lookup(\"[name^=\\\"count-\\\"]\", wrapper).forEach((input) => {\n\n                const {\n                    value\n                } = input;\n\n                if (value > 1) {\n\n                    input.value = 1;\n                    announceInput(input);\n\n                }\n\n            });\n\n        }\n\n    });\n\n});\n\nlookupCached(\"[data-team]\").forEach((wrapper) => {\n\n    wrapper.addEventListener(\"change\", ({ target }) => {\n\n        if (!target.matches(\"input[name=\\\"character\\\"]\")) {\n            return;\n        }\n\n        gameObserver.trigger(\"character-toggle\", {\n            element: target,\n            id: target.value,\n            active: target.checked\n        });\n\n    });\n\n    wrapper.addEventListener(\"input\", ({ target }) => {\n\n        if (!target.matches(\"input[name^=\\\"count\\\"]\")) {\n            return;\n        }\n\n        gameObserver.trigger(\"character-count-change\", {\n            element: target,\n            id: target.dataset.for,\n            count: Number(target.value)\n        });\n\n    });\n\n    wrapper.addEventListener(\"click\", ({ target }) => {\n\n        const button = target.closest(\"[data-quantity-amount]\");\n\n        if (!button) {\n            return;\n        }\n\n        const input = button.input || lookupOne(\n            \".js--character-select--count\",\n            button.closest(\".js--character-select--duplicate-wrapper\")\n        );\n        button.input = input;\n\n        const value = Number(input.value) || 0;\n        const delta = Number(button.dataset.quantityAmount) || 0;\n        const amount = value + delta;\n\n        input.value = amount;\n\n        if (amount) {\n            announceInput(input);\n        } else {\n\n            const checkbox = lookupOne(\n                \".js--character-select--input\",\n                button.closest(\".js--character-select\")\n            );\n            checkbox.checked = false;\n            announceInput(checkbox);\n\n        }\n\n    });\n\n});\n\ngameObserver.on(\"character-toggle\", ({ detail }) => {\n\n    const {\n        id,\n        active,\n        element\n    } = detail;\n\n    const input = lookupOne(`input[name=\"count-${id}\"]`);\n    const value = Number(input.value);\n\n    element\n        .closest(\".js--character-select\")\n        .classList\n        .toggle(\"is-selected\", active);\n\n    if (active) {\n\n        if (value < 1) {\n            input.value = 1;\n        }\n\n    } else {\n        input.value = 0;\n    }\n\n    announceInput(input);\n\n});\n\nconst validationInput = lookupOne(\"#player-select-validation\");\n\ngameObserver.on(\"character-count-change\", ({ detail }) => {\n\n    const {\n        element\n    } = detail;\n    const wrapper = element.closest(\"[data-team]\");\n    const countElement = lookupOneCached(\n        \".js--character-select--count\",\n        wrapper\n    );\n\n    countElement.textContent = wrapper.countInputs.reduce((total, input) => {\n        return total + Number(input.value);\n    }, 0);\n\n    validationInput.setCustomValidity(\"\");\n\n});\n\nlookupOne(\"#player-select\").addEventListener(\"submit\", (e) => {\n\n    e.preventDefault();\n\n    const ids = lookup(\".js--character-select--input:checked\", e.target)\n        .map(({ value }) => value);\n\n    TokenStore.ready((tokenStore) => {\n\n        const filtered = tokenStore\n            .getAllCharacters()\n            .filter((character) => ids.includes(character.getId()))\n            .map((character) => {\n\n                // We use times() instead of Array#fill() here because fill()\n                // didn't seem to work correctly.\n\n                const duplicates = [];\n\n                times(\n                    lookupOne(`input[name=\"count-${character.getId()}\"]`).value,\n                    () => duplicates.push(character)\n                );\n\n                return duplicates;\n\n            })\n            .flat();\n\n        const bagDisabled = filtered.filter((character) => {\n            return character.hasSpecialData(\"selection\", \"bag-disabled\");\n        });\n\n        if (bagDisabled.length) {\n\n            validationInput.setCustomValidity(supplant(\n                window.I18N.bagDisabled,\n                [bagDisabled.map((character) => character.getName()).join(\", \")]\n            ));\n            validationInput.form.reportValidity();\n\n        } else {\n\n            validationInput.setCustomValidity(\"\");\n\n            const isShowAll = Boolean(e.submitter?.id === \"player-select-all\");\n\n            gameObserver.trigger(\"character-draw\", {\n                isShowAll,\n                characters: (\n                    isShowAll\n                    ? shuffle(filtered)\n                    : filtered\n                )\n            });\n\n            Dialog.create(lookupOneCached(\"#character-select\")).hide();\n\n        }\n\n    });\n\n});\n\ntokenObserver.on(\"toggle-jinx-active\", ({ detail }) => {\n\n    const {\n        jinx,\n        state\n    } = detail;\n    const input = lookupOne(\n        `.js--character-select--input[value=\"${jinx.getTarget()?.getId()}\"]`\n    );\n\n    if (input) {\n\n        input\n            .closest(\".js--character-select--label\")\n            ?.querySelector(\".js--character-select--name\")\n            ?.classList.toggle(\"is-jinx\", state);\n\n    }\n\n});\n\nconst breakdownTable = lookupOne(\"#breakdown-table\");\n\nfunction highlightBreakdown(number) {\n\n    if (number > 15) {\n        number = 15;\n    }\n\n    number = String(number);\n\n    const index = lookupCached(\"[data-count]\", breakdownTable)\n        .findIndex((cell) => cell.dataset.count === number);\n\n    lookup(\".is-count\", breakdownTable)\n        .forEach((cell) => cell.classList.remove(\"is-count\"));\n\n    lookupCached(\"tbody>tr\", breakdownTable).forEach((row) => {\n        lookupCached(\".js--breakdown--cell\", row)[index]?.classList.add(\"is-count\");\n    });\n\n}\n\nlookupOneCached(\"#player-count\").addEventListener(\"input\", ({ target }) => {\n    highlightBreakdown(target.value);\n});\nhighlightBreakdown(lookupOneCached(\"#player-count\").value);\n","import Observer from \"../../classes/Observer.js\";\nimport Dialog from \"../../classes/Dialog.js\";\nimport TokenStore from \"../../classes/TokenStore.js\";\nimport Template from \"../../classes/Template.js\";\nimport {\n    empty,\n    lookupOne,\n    lookupOneCached,\n    replaceContentsMany\n} from \"../../utils/elements.js\";\nimport {\n    shuffle\n} from \"../../utils/arrays.js\";\n\nconst gameObserver = Observer.create(\"game\");\nconst characterDecisionDialog = Dialog.create(lookupOne(\"#character-decision\"));\nconst playerName = lookupOne(\"#player-name\");\n\ngameObserver.on(\"character-draw\", ({ detail }) => {\n\n    if (detail.isShowAll) {\n        return;\n    }\n\n    const template = Template.create(\n        lookupOneCached(\"#character-choice-template\")\n    );\n\n    replaceContentsMany(\n        lookupOneCached(\"#character-choice-wrapper\"),\n        shuffle(detail.characters)\n            .map((character, i) => template.draw({\n                \"[data-id]\"(element) {\n                    element.dataset.id = character.getId();\n                },\n                \".js--character-choice--number\"(element) {\n                    element.textContent = i + 1;\n                }\n            }))\n    );\n\n    Dialog.create(lookupOneCached(\"#character-choice\")).show();\n\n});\n\ngameObserver.on(\"character-draw\", ({ detail }) => {\n\n    if (!detail.isShowAll) {\n        return;\n    }\n\n    lookupOneCached(\"#grimoire\").open = true;\n\n    TokenStore.ready((tokenStore) => {\n\n        detail.characters.forEach((character) => {\n\n            gameObserver.trigger(\"character-drawn\", {\n                character: character.clone(),\n                isAutoAdd: true\n            });\n\n        });\n\n    });\n\n});\n\nlookupOneCached(\"#character-choice\").addEventListener(\"click\", ({ target }) => {\n\n    const element = target.closest(\"[data-id]\");\n\n    if (!element || element.disabled) {\n        return;\n    }\n\n    TokenStore.ready((tokenStore) => {\n\n        // Add a clone of the character so that duplicated characters are still\n        // considered unique.\n\n        gameObserver.trigger(\"character-drawn\", {\n            element,\n            character: tokenStore.getCharacter(element.dataset.id).clone()\n        });\n\n    });\n\n});\n\ngameObserver.on(\"character-drawn\", ({ detail }) => {\n\n    const {\n        element\n    } = detail;\n\n    if (element) {\n        element.disabled = true;\n    }\n\n});\n\ngameObserver.on(\"character-drawn\", ({ detail }) => {\n\n    const {\n        isAutoAdd,\n        character\n    } = detail;\n\n    if (isAutoAdd) {\n        return;\n    }\n\n    empty(lookupOneCached(\"#character-decision-wrapper\")).append(\n        character.drawToken()\n    );\n    lookupOneCached(\"#character-decision-ability\").textContent = (\n        character.getAbility()\n    );\n    characterDecisionDialog.show();\n\n});\n\n// Allow a name to be set when the character is revealed.\n// We do this by checking to see if a name was entered when the \"remember your\n// character\" dialog is closed, using it if it was.\n\nlet character = null;\n\ngameObserver.on(\"character-drawn\", ({ detail }) => {\n    character = detail.character;\n});\n\ncharacterDecisionDialog.on(Dialog.SHOW, () => {\n    playerName.value = playerName.defaultValue;\n});\n\ncharacterDecisionDialog.on(Dialog.HIDE, () => {\n\n    const {\n        pad\n    } = lookupOneCached(\".js--pad\");\n    const {\n        value\n    } = playerName;\n    const trimmed = (value || \"\").trim();\n\n    if (pad && trimmed && character) {\n        pad.setPlayerName(character, trimmed);\n    }\n\n    character = null;\n\n});\n\nlookupOne(\"#character-decision-form\").addEventListener(\"submit\", (e) => {\n    e.preventDefault();\n    characterDecisionDialog.hide();\n});\n","import Observer from \"../../classes/Observer.js\";\nimport QRCode from \"../../lib/qrcode-svg.js\";\nimport {\n    empty,\n    lookupOneCached\n} from \"../../utils/elements.js\";\n\nconst gameObserver = Observer.create(\"game\");\nconst characterStore = Object.create(null);\n\n/**\n * Draws the QR code based on information on the QR code element.\n */\nfunction drawQRCode() {\n\n    const includeTravellers = lookupOneCached(\"#include-travellers\").checked;\n    const includeFabled = lookupOneCached(\"#include-fabled\").checked;\n    const qrCode = lookupOneCached(\"#qr-code\");\n    const anchor = lookupOneCached(\"#qr-code-link\");\n    const url = new URL(anchor.href);\n\n    const {\n        name,\n        game\n    } = qrCode.dataset;\n\n    if (name) {\n        url.searchParams.set(\"name\", name);\n    } else {\n        url.searchParams.delete(\"name\");\n    }\n\n    if (game) {\n\n        url.searchParams.set(\"game\", game);\n        url.searchParams.set(\"traveller\", Number(includeTravellers));\n        url.searchParams.set(\"fabled\", Number(includeFabled));\n        url.searchParams.delete(\"characters\");\n\n    } else {\n\n        const teams = [\n            \"townsfolk\",\n            \"outsider\",\n            \"minion\",\n            \"demon\"\n        ];\n\n        if (includeTravellers) {\n            teams.push(\"traveller\");\n        }\n\n        if (includeFabled) {\n            teams.push(\"fabled\");\n        }\n\n        const ids = characterStore[qrCode.dataset.characters]\n            .filter((character) => teams.includes(character.getTeam()))\n            .map((character) => character.getId());\n        url.searchParams.set(\"characters\", ids);\n        url.searchParams.delete(\"game\");\n        url.searchParams.delete(\"traveller\");\n        url.searchParams.delete(\"fabled\");\n\n    }\n\n    empty(qrCode).append(QRCode({\n        msg: url.toString(),\n        ecl: \"L\"\n    }));\n    lookupOneCached(\"#qr-code-button\").disabled = false;\n    anchor.href = url.toString();\n    lookupOneCached(\"#qr-code-link\").disabled = false;\n\n}\n\ngameObserver.on(\"characters-selected\", ({ detail }) => {\n\n    const {\n        name,\n        characters,\n        game\n    } = detail;\n\n    const qrCode = lookupOneCached(\"#qr-code\");\n\n    if (game) {\n\n        qrCode.dataset.game = game;\n        delete qrCode.dataset.characters;\n\n    } else {\n\n        const ids = JSON.stringify(\n            characters.map((character) => character.getId())\n        );\n\n        characterStore[ids] = characters;\n        qrCode.dataset.characters = ids;\n        delete qrCode.dataset.game;\n\n    }\n\n    if (name) {\n        qrCode.dataset.name = name;\n    } else {\n        delete qrCode.dataset.name;\n    }\n\n    drawQRCode();\n\n});\n\nlookupOneCached(\"#include-travellers\").addEventListener(\"change\", () => {\n    drawQRCode();\n});\n\nlookupOneCached(\"#include-fabled\").addEventListener(\"change\", () => {\n    drawQRCode();\n});\n","import Store from \"../../classes/Store.js\";\nimport Dialog from \"../../classes/Dialog.js\";\nimport {\n    lookupOne,\n    lookupCached,\n    lookupOneCached,\n    announceInput\n} from \"../../utils/elements.js\";\n\nconst store = Store.create(\"pocket-grimoire\");\nconst clears = lookupCached(\"input[name=\\\"clear\\\"]\");\n\nlookupOne(\"#clear-all\").addEventListener(\"change\", ({ target }) => {\n\n    lookupOneCached(\"#clear-individual\").hidden = target.checked;\n\n    if (target.checked) {\n\n        clears.forEach((input) => {\n\n            input.checked = true;\n            announceInput(input);\n\n        });\n\n    }\n\n});\n\nlookupOne(\"#clear-tokens\").addEventListener(\"change\", ({ target }) => {\n    lookupOneCached(\"#token-warning\").hidden = !target.checked;\n});\n\nlookupOne(\"#clear-infoTokens\").addEventListener(\"change\", ({ target }) => {\n    lookupOneCached(\"#info-token-warning\").hidden = !target.checked;\n});\n\nlookupOne(\"#cache-form\").addEventListener(\"submit\", (e) => {\n\n    e.preventDefault();\n\n    clears.forEach(({ value, checked }) => {\n\n        if (checked) {\n            store.delete(value);\n        }\n\n    });\n\n    if (lookupOneCached(\"#clear-refresh\").checked) {\n        window.location.reload();\n    }\n\n    Dialog.create(lookupOneCached(\"#clear-cache\")).hide();\n\n});\n","/**\n * A no-operation function. It takes no parameters and returns no value.\n */\nexport function noop() {\n    return;\n}\n\n/**\n * Throttles the given function using window.requestAnimationFrame()\n *\n * @param  {Function} func\n *         Function that should be throttled.\n * @return {Function}\n *         Throttled function.\n */\nexport function rafThrottle(func) {\n\n    let context = this;\n    let active = true;\n\n    return function (...args) {\n\n        if (!active) {\n            return;\n        }\n\n        active = false;\n        window.requestAnimationFrame(() => {\n\n            active = true;\n            func.apply(context, args);\n\n        });\n\n    };\n\n};\n","import Observer from \"./Observer.js\";\nimport {\n    clamp\n} from \"../utils/numbers.js\";\nimport {\n    noop,\n    rafThrottle\n} from \"../utils/functions.js\";\n\n/**\n * Handles the tokens being draggable.\n */\nexport default class Tokens {\n\n    /**\n     * @param {Element} pad\n     *        The pad that the tokens are dragged around within.\n     * @param {Observer} observer\n     *        An observer that triggers events at key times.\n     */\n    constructor(pad, observer) {\n\n        /**\n         * The pad that thte tokens are in.\n         * @type {Element}\n         */\n        this.pad = pad;\n\n        /**\n         * An observer that triggers events at key times.\n         * @type {Observer}\n         */\n        this.observer = observer;\n\n        this.reset();\n        this.updatePadDimensions();\n        this.addListeners();\n\n    }\n\n    /**\n     * Resets some key properties.\n     */\n    reset() {\n\n        /**\n         * The current z-index. By constantly increasing this, we can always put\n         * the most recently touched token on the top, allowing reminders to sit\n         * on top of characters, for example.\n         * @type {Number}\n         */\n        this.zIndex = 0;\n\n        /**\n         * The handler to be executed when dragging a token or reminder.\n         * @type {Function}\n         */\n        this.dragHandler = noop;\n\n        /**\n         * A flag for knowing whether the user intention is dragging or\n         * clicking. This only seems to be neeed for the desktop.\n         * @type {Boolean}\n         */\n        this.isDragging = false;\n\n        /**\n         * The horizontal offset for the token being dragged.\n         * @type {Number}\n         */\n        this.xOffset = 0;\n\n        /**\n         * The vertical offset for the token being dragged.\n         * @type {Number}\n         */\n        this.yOffset = 0;\n\n    }\n\n    /**\n     * Updates the record of the dimensions of {@link Tokens#pad}.\n     */\n    updatePadDimensions() {\n\n        const rect = this.pad.getBoundingClientRect();\n\n        /**\n         * The offset left of {@link Token#pad}.\n         * @type {Number}\n         */\n        this.padLeft = rect.left;\n\n        /**\n         * The offset top of {@link Token#pad}.\n         * @type {Number}\n         */\n        this.padTop = rect.top;\n\n        /**\n         * The width of {@link Token#pad}.\n         * @type {Number}\n         */\n        this.padWidth = rect.width;\n\n        /**\n         * The height of {@link Token#pad}.\n         * @type {Number}\n         */\n        this.padHeight = rect.height;\n\n    }\n\n    /**\n     * Adds event listeners to key elements.\n     */\n    addListeners() {\n\n        document.addEventListener(\"mousedown\", this);\n        document.addEventListener(\"touchstart\", this);\n        document.addEventListener(\"mouseup\", this);\n        document.addEventListener(\"touchend\", this);\n        document.addEventListener(\"click\", this);\n        document.addEventListener(\"contextmenu\", this);\n        window.addEventListener(\"resize\", this);\n        window.addEventListener(\"scroll\", this);\n\n        const styleObserver = new MutationObserver(() => {\n            this.updatePadDimensions();\n        });\n\n        styleObserver.observe(this.pad, {\n            attributes: true,\n            attributeFilter: [\"style\"]\n        });\n\n    }\n\n    /**\n     * Set the zIndex value.\n     *\n     * @param {Number} zindex\n     *        Z-index to set.\n     */\n    setZIndex(zIndex) {\n        this.zIndex = zIndex;\n    }\n\n    /**\n     * Exposes {@link Tokens#zIndex}.\n     *\n     * @return {Number}\n     *         The current value of {@link Tokens#zIndex}.\n     */\n    getZIndex() {\n        return this.zIndex;\n    }\n\n    /**\n     * Increases {@link Tokens#zIndex} before returning it.\n     *\n     * @return {Number}\n     *         The next value of {@link Tokens#zIndex}.\n     */\n    advanceZIndex() {\n\n        this.zIndex += 1;\n\n        return this.zIndex;\n\n    }\n\n    /**\n     * Works out the event being heard and executes the correct handler.\n     *\n     * @param {Event} e\n     *        The event that has been heard.\n     */\n    handleEvent(e) {\n\n        const target = e.target;\n        const token = (\n            typeof target.closest === \"function\"\n            ? target.closest(\".js--token--wrapper\")\n            : null\n        );\n        const scollHandler = rafThrottle((e) => this.onScroll(e));\n\n        switch (e.type) {\n\n        case \"mousedown\":\n        case \"touchstart\":\n            this.onMousedown(token, e);\n            break;\n\n        case \"mouseup\":\n        case \"touchend\":\n        case \"contextmenu\":\n            this.onMouseup(e);\n            break;\n\n        case \"click\":\n            this.onClick(token, e);\n            break;\n\n        case \"resize\":\n            this.onResize(e);\n            break;\n\n        case \"scroll\":\n            scollHandler(e);\n            break;\n\n        }\n\n    }\n\n    /**\n     * Handles a mouse down or touch start event.\n     *\n     * @param {Element} token\n     *        The token that has been touched.\n     * @param {Event} e\n     *        The event.\n     */\n    onMousedown(token, e) {\n\n        if (!token) {\n            return;\n        }\n\n        this.startDrag(token, e);\n\n        const zIndex = this.advanceZIndex();\n        token.style.setProperty(\"--z-index\", zIndex);\n\n        this.observer.trigger(\"zindex\", {\n            zIndex,\n            element: token\n        });\n\n    }\n\n    /**\n     * Handles a mouse up or touch end event.\n     *\n     * @param {Event} e\n     *        The event.\n     */\n    onMouseup(e) {\n        this.endDragging();\n    }\n\n    /**\n     * Handles a click event.\n     *\n     * @param {Element} token\n     *        The token that has been touched.\n     * @param {Event} e\n     *        The event.\n     */\n    onClick(token, e) {\n\n        if (!token || this.isDragging) {\n            return;\n        }\n\n        const type = token.closest(\"[data-token]\");\n        const tokenType = type.dataset.token;\n\n        // character-click or reminder-click event.\n        this.observer.trigger(`${tokenType}-click`, {\n            element: type\n        });\n\n    }\n\n    /**\n     * Handles a resize event.\n     *\n     * @param {Event} e\n     *        The event.\n     */\n    onResize(e) {\n        this.updatePadDimensions();\n    }\n\n    /**\n     * Handles a scroll event.\n     *\n     * @param {Event} e\n     *        The event.\n     */\n    onScroll(e) {\n        this.updatePadDimensions();\n    }\n\n    /**\n     * Handles the dragging being started.\n     *\n     * @param {Element} element\n     *        The token being dragged.\n     * @param {Event} event\n     *        The mouse down or touch start event.\n     */\n    startDrag(element, event) {\n\n        const {\n            type,\n            clientX,\n            clientY,\n            targetTouches\n        } = event;\n        const {\n            left,\n            top\n        } = element.getBoundingClientRect();\n\n        this.endDragging();\n        this.dragHandler = (event) => this.dragObject(element, event);\n\n        if (type === \"mousedown\") {\n\n            this.xOffset = clientX - left + this.padLeft;\n            this.yOffset = clientY - top + this.padTop;\n            window.addEventListener(\"mousemove\", this.dragHandler);\n\n        } else if (type === \"touchstart\" && targetTouches.length) {\n\n            this.xOffset = targetTouches[0].clientX - left + this.padLeft;\n            this.yOffset = targetTouches[0].clientY - top + this.padTop;\n            window.addEventListener(\"touchmove\", this.dragHandler, {\n                passive: false\n            });\n\n        }\n\n    }\n\n    /**\n     * Moves a token being dragged.\n     *\n     * @param {Element} element\n     *        The token being dragged.\n     * @param {Event} event\n     *        The mouse move or touch move event.\n     */\n    dragObject(element, event) {\n\n        event.preventDefault();\n\n        const {\n            type,\n            clientX,\n            clientY,\n            targetTouches\n        } = event;\n        const {\n            width,\n            height\n        } = element.getBoundingClientRect();\n        let leftValue = 0;\n        let topValue = 0;\n\n        if (type === \"mousemove\") {\n\n            leftValue = clientX - this.xOffset;\n            topValue = clientY - this.yOffset;\n            this.isDragging = true;\n\n        } else if (type === \"touchmove\" && targetTouches.length) {\n\n            leftValue = targetTouches[0].clientX - this.xOffset;\n            topValue = targetTouches[0].clientY - this.yOffset;\n\n        }\n\n        this.moveTo(\n            element,\n            clamp(0, leftValue, this.padWidth - width),\n            clamp(0, topValue, this.padHeight - height)\n        );\n\n    }\n\n    /**\n     * Moves the given token element to the co-ordinates given.\n     *\n     * @param {Element} element\n     *        Element to move.\n     * @param {Number} left\n     *        X co-ordinate.\n     * @param {Number} top\n     *        Y co-ordinate.\n     * @param {Number} [zIndex=this.zIndex]\n     *        Optional Z co-ordinate. If ommitted, it defaults to\n     *        {@link Tokens#zIndex}.\n     */\n    moveTo(element, left, top, zIndex) {\n\n        element.style.setProperty(\"--left\", left);\n        element.style.setProperty(\"--top\", top);\n\n        if (typeof zIndex !== \"number\" || Number.isNaN(zIndex)) {\n            zIndex = this.zIndex;\n        }\n\n        element.style.setProperty(\"--z-index\", zIndex);\n\n        this.observer.trigger(\"move\", {\n            element,\n            left,\n            top,\n            zIndex\n        });\n\n    }\n\n    /**\n     * Exposes the co-ordinates for the given element.\n     *\n     * @param  {Element} element\n     *         Element whose co-ordinates should be returned.\n     * @return {coord}\n     *         Co-ordinates for the element.\n     */\n    getPosition(element) {\n\n        /**\n         * @typedef  {Object} coord\n         * @property {Number} x\n         *           The left value in pixels.\n         * @property {Number} y\n         *           The top value in pixels.\n         * @property {Number} z\n         *           The z-index in pixels.\n         */\n        const coord = {\n            x: Number(element.style.getPropertyValue(\"--left\")) || 0,\n            y: Number(element.style.getPropertyValue(\"--top\")) || 0,\n            z: Number(element.style.getPropertyValue(\"--z-index\")) || 0\n        };\n\n        return coord;\n\n    }\n\n    /**\n     * Handles the token dragging finishing.\n     */\n    endDragging() {\n\n        if (this.dragHandler !== noop) {\n\n            window.removeEventListener(\"mousemove\", this.dragHandler);\n            window.removeEventListener(\"touchmove\", this.dragHandler, {\n                passive: false\n            });\n            this.dragHandler = noop;\n\n            // The order of events is mousedown -> mouseup -> click. This means\n            // that we need to delay the resetting of `this.isDragging` so that\n            // the handler attached to the click event listener doesn't trigger\n            // after dragging. This only seems to be an issue on desktop, mobile\n            // seems to be fine.\n            window.requestAnimationFrame(() => this.isDragging = false);\n\n        }\n\n    }\n\n}\n","import {\n    times\n} from \"../utils/numbers.js\";\n\nexport default class Positioner {\n\n    /**\n     * A collection of layout methods that work out the co-ordinates for tokens.\n     * @type {Object}\n     */\n    static layouts = {\n\n        // https://stackoverflow.com/a/6972434\n        ellipse(data) {\n\n            const {\n                width,\n                height,\n                tokenWidth,\n                tokenHeight,\n                total\n            } = data;\n            const coordinates = [];\n            const radiusX = (width - tokenWidth) / 2;\n            const radiusY = (height - tokenHeight) / 2;\n            \n            function dp(radians) {\n                return Math.sqrt( (radiusX * Math.sin(radians)) ** 2 + (radiusY * Math.cos(radians)) ** 2 );\n            }\n            var precision = 0.001;\n            var offset = Math.PI * -0.5;\n            var circ = 0;\n            for (var radians = 0 + offset; radians < (Math.PI * 2 + offset); radians += precision) {\n                circ += dp(radians);\n            }\n            var nextPoint = 0;\n            var run = 0;\n            for (var radians = 0 + offset; radians < (Math.PI * 2 + offset); radians += precision) {\n                if ((total * run / circ) >= nextPoint) {\n                    nextPoint++;\n                    var pointX = radiusX + (Math.cos(radians) * radiusX);\n                    var pointY = radiusY + (Math.sin(radians) * radiusY);\n                    coordinates.push([pointX, pointY]);\n                }\n                run += dp(radians);\n            }\n\n            return coordinates;\n\n        },\n\n        diagonal(data) {\n\n            const {\n                width,\n                height,\n                tokenWidth,\n                tokenHeight,\n                total\n            } = data;\n            const coordinates = [];\n            const xIncrement = (width - tokenWidth) / total;\n            const yIncrement = (height - tokenHeight) / total;\n\n            times(total, (index) => {\n                coordinates[index] = [xIncrement * index, yIncrement * index];\n            });\n\n            return coordinates;\n\n        },\n\n        horizontal(data) {\n            return Positioner.layouts.diagonal(data).map(([x, y]) => [x, 0]);\n        },\n\n        vertical(data) {\n            return Positioner.layouts.diagonal(data).map(([x, y]) => [0, y]);\n        }\n\n    };\n\n    constructor() {\n\n        this.setDefaults();\n\n    }\n\n    /**\n     * Sets the default values for various parts.\n     */\n    setDefaults() {\n\n        const topLeft = {\n            width: 0,\n            height: 0\n        };\n\n        this.setContainerSize(topLeft);\n        this.setTokenSize(topLeft);\n        this.setTotal(0);\n\n    }\n\n    /**\n     * Sets the container size.\n     *\n     * @param {Object} size\n     *        Container size.\n     * @param {Number|String} size.width\n     *        Width of the container, in pixels.\n     * @param {Number|String} size.height\n     *        Height of the container, in pixels.\n     */\n    setContainerSize({ width, height }) {\n\n        /**\n         * The width of the container, in pixels.\n         * @type {Number}\n         */\n        this.width = Number(width) || 0;\n\n        /**\n         * The height of the container, in pixels.\n         * @type {Number}\n         */\n        this.height = Number(height) || 0;\n\n    }\n\n    /**\n     * Sets the token size.\n     *\n     * @param {Object} size\n     *        Token size.\n     * @param {Number|String} size.width\n     *        Width of the token, in pixels.\n     * @param {Number|String} size.height\n     *        Height of the token, in pixels.\n     */\n    setTokenSize({ width, height }) {\n\n        /**\n         * The width of the tokens, in pixels.\n         * @type {Number}\n         */\n        this.tokenWidth = Number(width) || 0;\n\n        /**\n         * The height of the tokens, in pixels.\n         * @type {Number}\n         */\n        this.tokenHeight = Number(height) || 0;\n\n    }\n\n    /**\n     * Sets the total number of tokens.\n     *\n     * @param {Number|String}\n     *        The total number of expected tokens.\n     */\n    setTotal(total) {\n\n        /**\n         * The total number of expected tokens.\n         * @type {Number}\n         */\n        this.total = Number(total) || 0;\n\n    }\n\n    /**\n     * Sets the layout that will be used to work out the co-ordinates of the\n     * tokens.\n     *\n     * @param {String} layout\n     *        The layout that should be used.\n     */\n    setLayout(layout) {\n        this.layout = layout;\n    }\n\n    /**\n     * Gets the data needed to work out the co-ordinates for the tokens.\n     *\n     * @return {Object}\n     *         Data needed to work out the co-ordinates.\n     */\n    getData() {\n\n        return Object.freeze({\n            width: this.width,\n            height: this.height,\n            tokenWidth: this.tokenWidth,\n            tokenHeight: this.tokenHeight,\n            total: this.total\n        });\n\n    }\n\n    /**\n     * Generates the co-ordinates for the tokens.\n     *\n     * @return {Array.<Array>}\n     *         Co-ordinates for the tokens.\n     * @throws {ReferenceError}\n     *         {@link Positioner#layout} should be a key in\n     *         {@link Positioner.layouts}.\n     */\n    generateCoords() {\n\n        const {\n            constructor: {\n                layouts\n            },\n            layout\n        } = this;\n        const method = layouts[layout];\n\n        if (!method) {\n            throw new ReferenceError(`Unrecognised layout type \"${layout}\"`);\n        }\n\n        return method(this.getData());\n\n    }\n\n}\n","import Tokens from \"./Tokens.js\";\nimport Template from \"./Template.js\";\nimport Observer from \"./Observer.js\";\nimport CharacterToken from \"./CharacterToken.js\";\nimport ReminderToken from \"./ReminderToken.js\";\nimport Positioner from \"./Positioner.js\";\nimport TokenStore from \"./TokenStore.js\";\nimport {\n    lookupOne,\n    lookupOneCached\n} from \"../utils/elements.js\";\nimport {\n    isNumeric\n} from \"../utils/numbers.js\";\n\n/**\n * Handles tokens being added to the main pad section.\n */\nexport default class Pad {\n\n    /**\n     * Returns the actual character token from the given token button.\n     *\n     * @param  {Element} button\n     *         Button whose token should be returned.\n     * @return {Element}\n     *         Token that was found.\n     * @throws {ReferenceError}\n     *         The given button must contain a token.\n     */\n    static getToken(button) {\n\n        const token = lookupOneCached(\".js--character\", button);\n\n        if (!token) {\n            throw new ReferenceError(\"Unable to find character token\");\n        }\n\n        return token;\n\n    }\n\n    /**\n     * @param {Element} element\n     *        The main pad element.\n     * @param {Observer} observer\n     *        An observer that will trigger events at key times.\n     */\n    constructor(element, observer) {\n\n        /**\n         * The main pad element.\n         * @type {Element}\n         */\n        this.element = element;\n\n        /**\n         * An observer that can trigger events at key times.\n         * @type {Observer}\n         */\n        this.observer = observer;\n\n        /**\n         * The class that allows the tokens to be dragged around.\n         * @type {Tokens}\n         */\n        this.tokens = new Tokens(element, observer);\n\n        /**\n         * The template for adding a token to the pad.\n         * @type {Template}\n         */\n        this.template = Template.create(lookupOne(\"#token-template\"));\n        // NOTE: should this be passed to the class instead of being created\n        // here?\n\n        /**\n         * All characters that have been added.\n         * @type {Array.<Object>}\n         */\n        this.characters = [];\n\n        /**\n         * All reminders that have been added.\n         * @type {Array.<Object>}\n         */\n        this.reminders = [];\n\n        /**\n         * The positioner that will lay out the tokens automatically.\n         * @type {Positioner}\n         */\n        this.positioner = null;\n\n        /**\n         * The co-ordinates for each of the tokens.\n         * @type {Array.<Array>}\n         */\n        this.coords = [];\n\n        /**\n         * The TokenStore that wil be used for working out the dimensions of the\n         * tokens, so that co-ordinates can be correctly calculated.\n         * @type {TokenStore}\n         */\n        this.tokenStore = null;\n\n    }\n\n    /**\n     * Adds a character to the {@link Pad#element}. This method is for internal\n     * use only because it doesn't trigger any events - use\n     * {@link Pad#addCharacter} instead.\n     *\n     * @param  {CharacterToken} character\n     *         The character to add.\n     * @return {Object}\n     *         An object with the token and the character that was added.\n     */\n    drawCharacter(character) {\n\n        const {\n            element,\n            characters,\n            template\n        } = this;\n\n        element.append(\n            template.draw({\n                \".js--token--wrapper\"(element) {\n\n                    element.append(character.drawToken());\n                    element.dataset.token = \"character\";\n\n                }\n            })\n        );\n\n        const token = element.lastElementChild;\n        const info = Object.freeze({\n            character,\n            token\n        });\n\n        characters.push(info);\n\n        return info;\n\n    }\n\n    /**\n     * Adds a character to the {@link Pad#element}.\n     *\n     * @param  {CharacterToken} character\n     *         The character to add.\n     * @return {Object}\n     *         An object with the token and the character that was added.\n     */\n    addCharacter(character) {\n\n        const info = this.drawCharacter(character);\n        this.observer.trigger(\"character-add\", info);\n\n        return info;\n\n    }\n\n    /**\n     * Adds a new character to {@link Pad#element} (see\n     * {@link Pad#addCharacter}) and moves it to the correct location.\n     *\n     * @param  {CharacterToken} character\n     *         The character to add.\n     * @return {Object}\n     *         An object with the token and the character that was added.\n     */\n    addNewCharacter(character) {\n\n        const {\n            tokens,\n            characters,\n            coords,\n            constructor: {\n                OFFSET\n            }\n        } = this;\n\n        if (!coords) {\n            throw new Error(\"Co-ordinates have not been generated\");\n        }\n\n        const info = this.addCharacter(character);\n\n        const index = characters.length - 1;\n        const [\n            left,\n            top\n        ] = (coords?.[index] || [OFFSET * index, OFFSET, index]);\n\n        tokens.moveTo(\n            info.token,\n            left,\n            top,\n            tokens.advanceZIndex()\n        );\n\n        return info;\n\n    }\n\n    /**\n     * Exposes the ability to move a token to the correct place.\n     *\n     * @param {Element} token\n     *        Token to move.\n     * @param {Number} left\n     *        Left position, in pixels.\n     * @param {Number} top\n     *        Top position, in pixels.\n     * @param {Number} [zIndex]\n     *        Optional z-index.\n     */\n    moveToken(token, left, top, zIndex) {\n        this.tokens.moveTo(token, left, top, zIndex);\n    }\n\n    /**\n     * Exposes the given token's position. See {@link Tokens#getPosition}.\n     *\n     * @param  {Element} token\n     *         Token whose position should be returned.\n     * @return {Object}\n     *         Co-ordinates for the token.\n     */\n    getTokenPosition(token) {\n        return this.tokens.getPosition(token);\n    }\n\n    /**\n     * Removes a character from {@link Pad#element}. This method is for internal\n     * use only because it doesn't trigger the events - use\n     * {@link Pad#removeCharacter} instead.\n     *\n     * @param {CharacterToken} character\n     *        The character to remove.\n     */\n    undrawCharacter(character) {\n\n        const {\n            characters,\n            preserveReference\n        } = this;\n        const index = characters\n            .findIndex((info) => info.character === character);\n\n        if (index < 0) {\n            return;\n        }\n\n        const {\n            token\n        } = characters[index];\n\n        token.remove();\n\n        if (!preserveReference) {\n            characters.splice(index, 1);\n        }\n\n        return token;\n\n    }\n\n    /**\n     * Removes a character from {@link Pad#element}.\n     *\n     * @param {CharacterToken} character\n     *        The character to remove.\n     */\n    removeCharacter(character) {\n\n        const token = this.undrawCharacter(character);\n\n        if (token) {\n\n            this.observer.trigger(\"character-remove\", {\n                character,\n                token\n            });\n\n        }\n\n    }\n\n    /**\n     * Gets the {@link CharacterToken} instance associated with the given\n     * element. If an instance isn't found, undefined is returned.\n     *\n     * @param  {Element} token\n     *         The token element whose data should be returned.\n     * @return {CharacterToken|undefined}\n     *         The matching character data, or undefined if there is no match.\n     */\n    getCharacterByToken(token) {\n        return this.characters.find((info) => info.token === token)?.character;\n    }\n\n    /**\n     * A helper function for removing a character by the token rather than the\n     * {@link CharacterToken} instance.\n     *\n     * @param {Element} token\n     *        The token whose character should be removed.\n     */\n    removeCharacterByToken(token) {\n        this.removeCharacter(this.getCharacterByToken(token));\n    }\n\n    /**\n     * Gets the information about the character from the character itself.\n     *\n     * @param  {CharacterToken} character\n     *         The character whose information should be returned.\n     * @return {Object}\n     *         Information about the character.\n     */\n    getInfoByCharacter(character) {\n        return this.characters.find((info) => info.character === character);\n    }\n\n    /**\n     * Toggles the dead state for the character that's been given.\n     *\n     * @param {CharacterToken} character\n     *        The character whose dead state should be toggled.\n     * @param {Boolean} [deadState]\n     *        Optional dead state to set.\n     */\n    toggleDead(character, deadState) {\n\n        const {\n            token\n        } = this.getInfoByCharacter(character) || {};\n\n        if (!token) {\n            return;\n        }\n\n        const isDead = character.toggleDead(deadState);\n        this.constructor\n            .getToken(token)\n            .classList\n            .toggle(\"is-dead\", isDead);\n        this.observer.trigger(\"shroud-toggle\", {\n            isDead,\n            token,\n            character\n        });\n\n        // Revived players get their ghost vote back.\n        // https://discord.com/channels/569683781800296501/719898820942626817/1056935809263079535\n        if (!isDead) {\n            this.setGhostVote(character, true);\n        }\n\n    }\n\n    /**\n     * A helper function for toggling the dead state of a character by their\n     * element rather than the {@link CharacterToken} instance.\n     *\n     * @param {Element} token\n     *        Element whose associated character should have their dead state\n     *        toggled.\n     * @param {Boolean} [deadState]\n     *        Optional dead state to set.\n     */\n    toggleDeadByToken(token, deadState) {\n        this.toggleDead(this.getCharacterByToken(token), deadState);\n    }\n\n    /**\n     * Toggles the rotated state for the character that's been given.\n     *\n     * @param {CharacterToken} character\n     *        The character whose rotated state should be toggled.\n     * @param {Boolean} [rotateState]\n     *        Optional rotated state to set.\n     */\n    rotate(character, rotateState) {\n\n        const {\n            token\n        } = this.getInfoByCharacter(character) || {};\n\n        if (!token) {\n            return;\n        }\n\n        const isUpsideDown = character.rotate(rotateState);\n        this.constructor\n            .getToken(token)\n            .classList\n            .toggle(\"is-upside-down\", isUpsideDown);\n        this.observer.trigger(\"rotate-toggle\", {\n            isUpsideDown,\n            token,\n            character\n        });\n\n    }\n\n    /**\n     * A helper function for toggling the rotated state of a character by their\n     * element rather than the {@link CharacterToken} instance.\n     *\n     * @param {Element} token\n     *        Element whose associated character should have their rotated state\n     *        toggled.\n     * @param {Boolean} [rotateState]\n     *        Optional rotated state to set.\n     */\n    rotateByToken(token, rotateState) {\n        this.rotate(this.getCharacterByToken(token), rotateState);\n    }\n\n    /**\n     * Gets the player name for the character that's been given.\n     *\n     * @param  {CharacterToken} character\n     *         The character whose name should be returned.\n     * @return {String}\n     *         The name of the player, or an empty string if there is no name or\n     *         the character token can't be found.\n     */\n    getPlayerName(character) {\n\n        const info = this.characters.find((info) => info.character === character);\n\n        if (!info) {\n            return \"\";\n        }\n\n        const nameTag = lookupOneCached(\n            \".js--character--player-name\",\n            this.constructor.getToken(info.token)\n        );\n\n        return nameTag?.textContent || \"\";\n\n    }\n\n    /**\n     * A helper function for getting the name of the player by the element\n     * rather than the {@link CharacterToken} instance.\n     *\n     * @param  {Element} token\n     *         The token element.\n     * @return {String}\n     *         The player name or an empty string.\n     */\n    getPlayerNameForToken(token) {\n        return this.getPlayerName(this.getCharacterByToken(token));\n    }\n\n    /**\n     * Sets the player name for the character that's been given.\n     *\n     * @param {CharacterToken} character\n     *        The character to set the player name for.\n     * @param {String} name\n     *        The player name to display with the character token.\n     */\n    setPlayerName(character, name) {\n\n        const {\n            token\n        } = this.getInfoByCharacter(character) || {};\n\n        if (!token) {\n            return;\n        }\n\n        const nameTag = lookupOneCached(\n            \".js--character--player-name\",\n            this.constructor.getToken(token)\n        );\n\n        if (!nameTag) {\n            return;\n        }\n\n        name = (name || \"\").trim();\n        nameTag.textContent = name;\n        this.observer.trigger(\"set-player-name\", {\n            name,\n            token,\n            character\n        });\n\n    }\n\n    /**\n     * A helper function for setting the player name of a character by their\n     * element rather than the {@link CharacterToken} instance.\n     *\n     * @param {Element} token\n     *        The token element.\n     * @param {String} name\n     *        The player name to display with the character token.\n     */\n    setPlayerNameForToken(token, name) {\n        this.setPlayerName(this.getCharacterByToken(token), name);\n    }\n\n    /**\n     * Toggles the ghost vote state for the character that's been given.\n     *\n     * @param {CharacterToken} character\n     *        The character whose ghost vote state should be toggled.\n     * @param {Boolean} [ghostVoteState]\n     *        Optional ghost vote state to set.\n     */\n    setGhostVote(character, ghostVoteState) {\n\n        // Prevent the value in the store breaking the ghost vote visibility if\n        // the character token is not dead.\n        if (!ghostVoteState && !character.getIsDead()) {\n            return;\n        }\n\n        const {\n            token\n        } = this.getInfoByCharacter(character) || {};\n\n        if (!token) {\n            return;\n        }\n\n        const hasGhostVote = character.toggleGhostVote(ghostVoteState);\n        this.constructor\n            .getToken(token)\n            .classList\n            .toggle(\"is-voteless\", !hasGhostVote);\n        this.observer.trigger(\"ghost-vote-toggle\", {\n            hasGhostVote,\n            token,\n            character\n        });\n\n    }\n\n    /**\n     * A helper function for toggling the ghost vote state of a character by\n     * their element rather than the {@link CharacterToken} instance.\n     *\n     * @param {Element} token\n     *        Element whose associated character should have their ghost vote\n     *        state toggled.\n     * @param {Boolean} [ghostVoteState]\n     *        Optional ghost vote state to set.\n     */\n    setGhostVoteForToken(token, ghostVoteState) {\n        this.setGhostVote(this.getCharacterByToken(token), ghostVoteState);\n    }\n\n    /**\n     * Adds a reminder to {@link Pad#element}.\n     *\n     * @param  {ReminderToken} reminder\n     *         The reminder to add.\n     * @return {Object}\n     *         An object with the token and the reminder that was added.\n     */\n    addReminder(reminder) {\n\n        const {\n            element,\n            reminders,\n            observer,\n            template\n        } = this;\n\n        element.append(\n            template.draw({\n                \".js--token--wrapper\"(element) {\n\n                    element.append(reminder.drawToken());\n                    element.dataset.token = \"reminder\";\n                    element.dataset.reminder = reminder.getId();\n\n                }\n            })\n        );\n\n        const token = element.lastElementChild;\n        const info = Object.freeze({\n            reminder,\n            token\n        });\n\n        reminders.push(info);\n        observer.trigger(\"reminder-add\", info);\n\n        return info;\n\n    }\n\n    /**\n     * Removes the reminder from {@link Pad#element}.\n     *\n     * @param {ReminderToken} reminder\n     *        The reminder to remove.\n     */\n    removeReminder(reminder) {\n\n        const {\n            reminders,\n            observer\n        } = this;\n        const index = reminders.findIndex((info) => info.reminder === reminder);\n\n        if (index < 0) {\n            return;\n        }\n\n        const {\n            token\n        } = reminders[index];\n\n        token.remove();\n\n        if (!this.preserveReference) {\n            reminders.splice(index, 1);\n        }\n\n        observer.trigger(\"reminder-remove\", {\n            reminder,\n            token\n        });\n\n    }\n\n    /**\n     * Gets the {@link ReminderToken} that's associated with the given element.\n     * If no match can be found, undefined is returned.\n     *\n     * @param  {Element} token\n     *         The token element whose associated reminder data should be\n     *         returned.\n     * @return {ReminderToken|undefined}\n     *         The matching data or undefined if no match can be found.\n     */\n    getReminderByToken(token) {\n        return this.reminders.find((info) => info.token === token)?.reminder;\n    }\n\n    /**\n     * A helper function for removing a reminder by the token element rather\n     * than the {@link ReminderToken} instance.\n     *\n     * @param {Element} token\n     *        The reminder element.\n     */\n    removeReminderByToken(token) {\n        this.removeReminder(this.getReminderByToken(token));\n    }\n\n    /**\n     * Removes all characters and tokens from {@link Pad#element} and calls\n     * {@link Tokens#reset}.\n     */\n    reset() {\n\n        const {\n            characters,\n            reminders\n        } = this;\n\n        /**\n         * A flag that prevents the arrays {@link Pad#characters} and\n         * {@link Pad#reminders} being modified through\n         * {@link Pad#removeCharacter} and {@link Pad#removeReminder}.\n         * Preserving the reference allows the characters and reminders to be\n         * removed with a loop and without entries being skipped.\n         * @type {Boolean}\n         */\n        this.preserveReference = true;\n\n        characters.forEach(({ character }) => {\n            this.removeCharacter(character);\n        });\n        characters.length = 0;\n\n        reminders.forEach(({ reminder }) => {\n            this.removeReminder(reminder);\n        });\n        reminders.length = 0;\n\n        this.preserveReference = false;\n\n        this.tokens.reset();\n\n    }\n\n    /**\n     * Helper function for executing {@link Tokens#updatePadDimensions} on\n     * {@link Pad#tokens}.\n     */\n    updateDimensions() {\n        this.tokens.updatePadDimensions();\n    }\n\n    /**\n     * Helper function for executing {@link Tokens#zetZIndex} on\n     * {@link Pad#tokens}.\n     *\n     * @param {Number} zIndex\n     *        Z-index to set.\n     */\n    setZIndex(zIndex) {\n        this.tokens.setZIndex(zIndex);\n    }\n\n    /**\n     * Sets the positioner that will place the tokens correctly.\n     *\n     * @param {Positioner} positioner\n     *        Positioner that will correctly place the tokens.\n     */\n    setPositioner(positioner) {\n        this.positioner = positioner;\n    }\n\n    /**\n     * Generates the co-ordinates for each of the tokens and stores them in\n     * {@link Pad#coords}\n     */\n    generateCoords() {\n        this.coords = this.positioner.generateCoords();\n    }\n\n    /**\n     * Works out the dimensions of {@link Par#element} in pixels.\n     *\n     * @return {Object}\n     *         An object with width and height properties.\n     */\n    getPadDimensions() {\n\n        const {\n            width,\n            height\n        } = this.element.getBoundingClientRect();\n\n        return {\n            width,\n            height\n        };\n\n    }\n\n    /**\n     * Sets {@link Pad#tokenStore}.\n     *\n     * @param {TokenStore}\n     *        The token store.\n     */\n    setTokenStore(tokenStore) {\n        this.tokenStore = tokenStore;\n    }\n\n    /**\n     * Gets the dimensions of a token, including its drop shadow.\n     *\n     * @return {Object}\n     *         An object with width and height properties.\n     */\n    getTokenDimensions() {\n\n        const dimensions = {\n            width: 0,\n            height: 0\n        };\n\n        if (!this.tokenStore) {\n\n            console.warn(\"Cannot test dimensions because tokenStore is not set\");\n            return dimensions;\n\n        }\n\n        const noCharacter = this.tokenStore.getEmptyCharacter();\n        const {\n            token\n        } = this.drawCharacter(noCharacter);\n        const {\n            width: tokenWidth,\n            height: tokenHeight\n        } = token.getBoundingClientRect();\n\n        // Add the shadow.\n\n        const scale = Number(\n            window.getComputedStyle(token, null).getPropertyValue(\"--token-size\")\n            || 1\n        );\n        const tokenCharacter = token.querySelector(\".js--character\");\n        const styles = window.getComputedStyle(tokenCharacter, null);\n\n        const shadowOffset = styles.getPropertyValue(\"--shadow-offset\");\n        let shadowAmount = parseFloat(shadowOffset) * scale;\n\n        if (shadowOffset.trim().replace(/[\\d\\.]/g, \"\") === \"em\") {\n            shadowAmount *= parseFloat(styles.getPropertyValue(\"font-size\"));\n        }\n\n        dimensions.width = tokenWidth + shadowAmount;\n        dimensions.height = tokenHeight + shadowAmount;\n\n        this.undrawCharacter(noCharacter);\n\n        return dimensions;\n\n    }\n\n    /**\n     * Updates {@link Pad#positioner} with the details that have been passed in\n     * before re-generating the co-ordinates.\n     *\n     * @param  {Object} settings\n     *         Settings to use to update the positioner.\n     * @param  {Boolean} [settings.container]\n     *         true if the container size should be sent to the positioner.\n     * @param  {Boolean} [settings.tokens]\n     *         true if the token size should be sent to the positioner.\n     * @param  {Number|String} [settings.total]\n     *         The total number of tokens expected.\n     * @param  {String} [settings.layout]\n     *         The layout that should be used to position the tokens.\n     * @param  {Boolean} [settings.generate = true]\n     *         Whether or not to re-generate the co-ordinates.\n     * @throws {ReferenceError}\n     *         {@link Pad#positioner} must be set before this function is used.\n     */\n    updatePositioner({ container, tokens, total, layout, generate = true }) {\n\n        const {\n            positioner\n        } = this;\n\n        if (!positioner) {\n            throw new ReferenceError(\"The positioner has not been set\");\n        }\n\n        if (container) {\n            positioner.setContainerSize(this.getPadDimensions());\n        }\n\n        if (tokens) {\n            positioner.setTokenSize(this.getTokenDimensions());\n        }\n\n        if (layout) {\n            positioner.setLayout(layout);\n        }\n\n        if (total && isNumeric(total)) {\n            positioner.setTotal(total);\n        }\n\n        if (generate) {\n            this.generateCoords();\n        }\n\n    }\n\n}\n","import Pad from \"../../classes/Pad.js\";\nimport Positioner from \"../../classes/Positioner.js\";\nimport Observer from \"../../classes/Observer.js\";\nimport ReminderToken from \"../../classes/ReminderToken.js\";\nimport Dialog from \"../../classes/Dialog.js\";\nimport TokenStore from \"../../classes/TokenStore.js\";\nimport {\n    lookup,\n    lookupOne,\n    lookupOneCached,\n    replaceContentsMany\n} from \"../../utils/elements.js\";\n\nconst gameObserver = Observer.create(\"game\");\nconst tokenObserver = Observer.create(\"token\");\n\nconst padElement = lookupOneCached(\".js--pad\");\nconst pad = new Pad(padElement, tokenObserver);\npadElement.pad = pad;\n\nconst styleObserver = new MutationObserver((mutations) => {\n\n    gameObserver.trigger(\"pad-height-change\", {\n        height: mutations[0].target.style.height\n    });\n\n});\n\nstyleObserver.observe(padElement, {\n    attributes: true,\n    attributeFilter: [\"style\"]\n});\n\n// If the elements are within a closed <details> element then their height and\n// width will be 0. Listen for the pad becoming visible and update the class.\nlookup(\"details\").forEach((details) => {\n\n    details.addEventListener(\"toggle\", () => {\n        pad.updateDimensions();\n    });\n\n});\n\ngameObserver.on(\"characters-selected\", ({ detail }) => {\n\n    const characters = detail.characters.filter((character) => {\n        const team = character.getTeam();\n        return team !== \"fabled\" && team !== \"traveller\";\n    });\n\n    replaceContentsMany(\n        lookupOneCached(\"#character-list__list\"),\n        characters.map((character) => character.drawList())\n    );\n\n    const reminders = characters.reduce((reminders, character) => {\n        return reminders.concat(character.getReminders());\n    }, ReminderToken.getGlobal());\n\n    replaceContentsMany(\n        lookupOneCached(\"#reminder-list__list\"),\n        reminders.map((reminder) => reminder.drawList())\n    );\n\n    lookupOneCached(\"#add-token\").disabled = false;\n    lookupOneCached(\"#add-reminder\").disabled = false;\n    lookupOneCached(\"#show-tokens\").disabled = false;\n\n});\n\ngameObserver.on(\"character-drawn\", ({ detail }) => {\n    pad.addNewCharacter(detail.character);\n});\n\nlookupOne(\"#show-night-order\").addEventListener(\"change\", ({ target }) => {\n\n    padElement.style[\n        target.checked\n        ? \"removeProperty\"\n        : \"setProperty\"\n    ](\"--night-order-display\", \"none\");\n\n});\n\ngameObserver.on(\"clear\", () => pad.reset());\n\n// Character and Reminder token sizes.\n\nconst html = document.documentElement;\n\nlookupOne(\"#token-size\").addEventListener(\"input\", ({ target }) => {\n    html.style.setProperty(\"--token-size\", target.value);\n});\n\nlookupOne(\"#reminder-size\").addEventListener(\"input\", ({ target }) => {\n    html.style.setProperty(\"--reminder-size\", target.value);\n});\n\n// Token auto-placements.\n\npad.setPositioner(new Positioner());\n\nconst tokenLayout = lookupOne(\"#token-layout\");\n\npad.updatePositioner({\n    layout: tokenLayout.value,\n    // At this stage, most of the positioner probably hasn't been set up so we'd\n    // get a few issues if we try to generate the co-ordinates. Better to just\n    // give the positioner some data and generate the co-ordinates later.\n    generate: false\n});\n\ntokenLayout.addEventListener(\"change\", () => {\n    pad.updatePositioner({ layout: tokenLayout.value });\n});\n\ngameObserver.on(\"player-count\", ({ detail }) => {\n    pad.updatePositioner({ total: detail.count });\n});\n\ngameObserver.on(\"pad-height-change\", () => {\n    pad.updatePositioner({ container: true });\n});\n\nDialog.create(lookupOneCached(\"#character-select\")).on(Dialog.SHOW, () => {\n\n    const grimoireSection = lookupOneCached(\"#grimoire\");\n    const isOpen = grimoireSection.open;\n\n    if (!isOpen) {\n        grimoireSection.open = true;\n    }\n\n    pad.updatePositioner({\n        container: true,\n        tokens: true,\n        total: lookupOneCached(\"#player-count\").value\n    });\n\n    if (!isOpen) {\n        grimoireSection.open = false;\n    }\n\n});\n\nTokenStore.ready((tokenStore) => {\n    pad.setTokenStore(tokenStore);\n});\n","/**\n * A list of processes that can be executed.\n */\nexport default class ProcessList {\n\n    constructor() {\n\n        /**\n         * A list of all the processes in the list.\n         * @type {Array.<Object>}\n         */\n        this.list = [];\n\n    }\n\n    /**\n     * Adds an item to {@link ProcessList#list}.\n     *\n     * @param {Object} item\n     *        Item to add.\n     */\n    add(item) {\n        this.list.push(item);\n    }\n\n    /**\n     * Checks to see if the given item is already in {@link ProcessList#list}.\n     *\n     * @param  {Object} item\n     *         Object to look for.\n     * @return {Boolean}\n     *         true if the item is already in the list, false otherwise.\n     */\n    has(item) {\n        return this.list.includes(item);\n    }\n\n    /**\n     * Adds an item to {@link ProcessList#list} but only if it's not already\n     * there.\n     *\n     * @param {Object} item\n     *        Item to add.\n     */\n    addUnique(item) {\n\n        if (!this.has(item)) {\n            this.add(item);\n        }\n\n    }\n\n    /**\n     * Removes an item from {@link ProcessList#list}. If the item is not in the\n     * list then no action is taken.\n     *\n     * @param {Object} item\n     *        Item to remove.\n     */\n    remove(item) {\n\n        const index = this.list.indexOf(item);\n\n        if (index > -1) {\n            this.list.splice(index, 1);\n        }\n\n    }\n\n    /**\n     * Gets the last item from {@link ProcessList#list}. If there is nothing in\n     * the list then undefined is returned.\n     *\n     * @return {Object|undefined}\n     *         Either the last item in the list or undefined.\n     */\n    last() {\n        return this.list[this.list.length - 1];\n    }\n\n    /**\n     * Executes the given method on the given process. If the process doesn't\n     * exist or the given method name isn't a function then no action is taken.\n     *\n     * @param {Object} process\n     *        The process whose method should be executed.\n     * @param {String} method\n     *        The name of the method to execute.\n     * @param {...?} args\n     *        Arguments to pass to the method.\n     */\n    static execute(process, method, ...args) {\n\n        if (typeof process?.[method] === \"function\") {\n            process[method](...args);\n        }\n\n    }\n\n}\n","import Dialog from \"./Dialog.js\";\nimport ProcessList from \"./ProcessList.js\";\nimport {\n    lookupOneCached\n} from \"../utils/elements.js\";\n\n/**\n * A version of {@link Dialog} that handles the \"Select character\" dialog.\n */\nexport default class SelectDialog extends Dialog {\n\n    /**\n     * @inheritdoc\n     */\n    constructor(dialog) {\n\n        super(dialog);\n\n        /**\n         * A list of all the processes that this dialog might handle.\n         * @type {ProcessList}\n         */\n        this.processList = new ProcessList();\n\n    }\n\n    /**\n     * Adds a process to {@link SelectDialog#processList} - see\n     * {@link ProcessList#addUnique}.\n     *\n     * @param {Object} process\n     *        Process to add.\n     */\n    addProcess(process) {\n        this.processList.addUnique(process);\n    }\n\n    /**\n     * Remove a process from {@link SelectDialog#processList} - see\n     * {@link ProcessList#remove}.\n     *\n     * @param {Object} process\n     *        Process to remove.\n     */\n    removeProcess(process) {\n        this.processList.remove(process);\n    }\n\n    /**\n     * @inheritdoc\n     */\n    addListeners() {\n\n        super.addListeners();\n\n        this.dialog.addEventListener(\"click\", ({ target }) => {\n\n            const button = target.closest(\"[data-token-id]\");\n\n            if (!button) {\n                return;\n            }\n\n            ProcessList.execute(\n                this.processList.last(),\n                \"click\",\n                button.dataset.tokenId\n            );\n\n        });\n\n        this.on(this.constructor.HIDE, () => {\n            ProcessList.execute(this.processList.last(), \"hide\");\n        });\n\n    }\n\n    /**\n     * Gets a cached instance of {@link SelectDialog}, allowing it to act like a\n     * singleton.\n     *\n     * @return {SelectDialog}\n     *         An instance.\n     */\n    static get() {\n        return this.create(lookupOneCached(\"#character-list\"));\n    }\n\n}\n","/**\n * Manages a title that can be set.\n */\nexport default class SettableTitle {\n\n    /**\n     * @param  {HTMLElement} title\n     *         The title element that will display normally displayed.\n     * @param  {HTMLElement} input\n     *         The input element that will allow the title to be set.\n     * @throws {Error}\n     *         `title` and `input` must exist and `input` must have a `list`.\n     */\n    constructor(title, input) {\n\n        /**\n         * The title element that will display normally displayed.\n         * @type {HTMLElement}\n         */\n        this.title = title;\n\n        /**\n         * The input element that will allow the title to be set.\n         * @type {HTMLElement}\n         */\n        this.input = input;\n\n        /**\n         * The data list for {@link SettableTitle#input}.\n         * @type {HTMLElement}\n         */\n        this.list = input.list;\n\n        if (!this.title || !this.input || !this.list) {\n            throw new Error(\"Settable title not properly configured\");\n        }\n\n        /**\n         * The form that enwraps {@link SettableTitle#input}. This element might\n         * not exist.\n         * @type {HTMLElement|null}\n         */\n        this.form = input.form;\n\n        /**\n         * The option within {@link SettableTitle#list} that displays the\n         * original, starting value of the title.\n         * @type {HTMLElement}\n         */\n        this.start = this.list.querySelector(\".js--settable-title--start\");\n        this.start.value = title.textContent;\n\n        /**\n         * The option within {@link SettableTitle#list} that displays the\n         * value that the user most recently inputted.\n         * @type {HTMLElement}\n         */\n        this.previous = this.list.querySelector(\".js--settable-title--previous\");\n\n        this.addListeners();\n\n    }\n\n    /**\n     * Adds event listeners to key elements.\n     */\n    addListeners() {\n\n        const {\n            title,\n            input,\n            form\n        } = this;\n\n        title.addEventListener(\"click\", () => {\n\n            this.showInput();\n            input.focus();\n\n        });\n\n        input.addEventListener(\"focus\", () => {\n            input.value = \"\";\n        });\n\n        input.addEventListener(\"blur\", () => {\n\n            this.hideInput();\n            this.updatePrevious();\n\n        });\n\n        input.addEventListener(\"input\", () => {\n\n            this.setTitle(input.value);\n            this.announceUpdate();\n\n        });\n\n        form?.addEventListener(\"submit\", (e) => {\n\n            e.preventDefault();\n            e.stopPropagation();\n            input.blur();\n\n        });\n\n    }\n\n    /**\n     * Checks to see if {@link SettableTitle#input} is currently visible.\n     *\n     * @return {Boolean}\n     *         `true` if {@link SettableTitle#input} is currently visible,\n     *         `false` otherwise.\n     */\n    isShowingInput() {\n        return !this.input.hidden;\n    }\n\n    /**\n     * Toggles the visibility of {@link SettableTitle#input} (and, by extension,\n     * {@link SettableTitle#title}). Optionally, the visibility state can be\n     * forced by passing a boolean to this function. If this function attempts\n     * to set the visibility state to the same as the current state, no action\n     * is taken.\n     *\n     * @param {Boolean} [forceState]\n     *        Optional state to force. If ommitted, the visibility is simply\n     *        toggled.\n     */\n    toggleInput(forceState) {\n\n        if (forceState === undefined) {\n            forceState = !this.isShowingInput();\n        }\n\n        if (forceState === this.isShowingInput()) {\n            return;\n        }\n\n        const {\n            title,\n            input\n        } = this;\n\n        title.hidden = forceState;\n        input.hidden = !forceState;\n\n    }\n\n    /**\n     * A helper function that makes the input visible. See\n     * {@link SettableTitle#toggleInput}.\n     */\n    showInput() {\n        this.toggleInput(true);\n    }\n\n    /**\n     * A helper function that makes the input invisible. See\n     * {@link SettableTitle#toggleInput}.\n     */\n    hideInput() {\n        this.toggleInput(false);\n    }\n\n    /**\n     * Updates the value of {@link SettableTitle#previous} if it exists and the\n     * value is not empty.\n     */\n    updatePrevious() {\n\n        const {\n            input,\n            previous\n        } = this;\n\n        if (previous && input.value) {\n            previous.value = input.value;\n        }\n\n    }\n\n    /**\n     * Sets the text of {@link SettableTitle#title} to the given title. If the\n     * given title is empty, the value returned by\n     * {@link SettableTitle#getStartText} is used instead.\n     *\n     * @param {String} title\n     *        Title to set.\n     */\n    setTitle(title) {\n        this.title.textContent = title || this.getStartText();\n    }\n\n    /**\n     * Exposes the current text of {@link SettableTitle#title}.\n     *\n     * @return {String}\n     *         Current text of {@link SettableTitle#title}.\n     */\n    getTitle() {\n        return this.title.textContent;\n    }\n\n    /**\n     * Exposes {@link SettableTitle#form}.\n     *\n     * @return {HTMLElement|null}\n     *         Form element.\n     */\n    getForm() {\n        return this.form;\n    }\n\n    /**\n     * Sets the text of {@link SettableTitle#start}. If that element doesn't\n     * exist then no action is taken.\n     *\n     * @param {String} text\n     *        Starting text.\n     */\n    setStartText(text) {\n\n        const {\n            start\n        } = this;\n\n        if (start) {\n            start.value = text;\n        }\n\n    }\n\n    /**\n     * Gets the text of {@link SettableTitle#start}. If that text cannot be\n     * worked out, an empty string is returned.\n     *\n     * @return {String}\n     *         Starting text.\n     */\n    getStartText() {\n        return this.start?.value || \"\";\n    }\n\n    /**\n     * A function that's executed whenever the value of\n     * {@link SettableTitle#input} is updated.\n     */\n    announceUpdate() {\n        return;\n    }\n\n}\n","/**\n * A class that allows elements to be draggable.\n */\nexport default class Draggable {\n\n    /**\n     * Default settings for {@link Draggable#settings}.\n     * @type {Object}\n     */\n    static defaults = {\n        childClass: \"is-draggable\",\n        dragClass: \"is-dragging\",\n        dragSelector: \"[draggable]\"\n    };\n\n    /**\n     * @param {Element} container\n     *        The container in which all the draggable elements will be.\n     * @param {Object} [settings]\n     *        Optional settings for the class instance.\n     */\n    constructor(container, settings) {\n\n        /**\n         * Container in which all the draggable elements will be. Elements can\n         * only be dropped within this container.\n         * @type {Element}\n         */\n        this.container = container;\n\n        /**\n         * Settings for the instance.\n         * @type {Object}\n         */\n        this.settings = Object.assign({}, Draggable.defaults, settings || {});\n\n        /**\n         * A collection of all the draggable children within\n         * {@link Draggable#container}.\n         * @type {Set.<Element>}\n         */\n        this.children = new Set();\n\n        /**\n         * The child currently be dragged, if there is one.\n         * @type {Element|null}\n         */\n        this.dragged = null;\n\n        this.createHandlers();\n        this.addEventListeners();\n\n    }\n\n    /**\n     * Creates the {@link Draggable#onChildDragStart} and\n     * {@link Draggable#onChildDragEnd} methods.\n     */\n    createHandlers() {\n\n        const {\n            dragClass,\n            dragSelector\n        } = this.settings;\n\n        /**\n         * Handles the user starting to drag a child element. This is a\n         * generated method, rather than being part of the prototype, so that it\n         * can be added/removed by reference in {@link Draggable#addChild} and\n         * {@link Draggable#removeChild}.\n         *\n         * @param {Event} event\n         *        Either a \"dragstart\" or a \"touchstart\" event.\n         */\n        this.onChildDragStart = (event) => {\n\n            const {\n                target,\n                dataTransfer\n            } = event;\n\n            // When using touch events, the target can be a [draggable] child.\n            const child = target.closest(dragSelector);\n\n            child.classList.add(dragClass);\n\n            // dataTransfer property only exists with \"drop\" events.\n            if (dataTransfer) {\n\n                dataTransfer.effectAllowed = \"move\";\n                dataTransfer.setData(\"text/plain\", null); // Needed for Firefox.\n\n            }\n\n            this.dragged = child;\n\n        };\n\n        /**\n         * Handles the user no longer dragging a child element. This is a\n         * generated method, rather than being part of the prototype, so that it\n         * can be added/removed by reference in {@link Draggable#addChild} and\n         * {@link Draggable#removeChild}.\n         *\n         * @param {Event} event\n         *        Either a \"dragend\" or a \"touchend\" event.\n         */\n        this.onChildDragEnd = (event) => {\n            event.target.closest(dragSelector)?.classList.remove(dragClass);\n        };\n\n    }\n\n    /**\n     * Identifies the within the given collection of children that is closest to\n     * the given X and Y co-ordinates.\n     *\n     * @param  {Element[]} children\n     *         Collection of elements to check.\n     * @param  {Number} x\n     *         X co-ordinate.\n     * @param  {Number} y\n     *         Y co-ordinate.\n     * @return {Element|undefined}\n     *         Either the closest element, or undefined if the children\n     *         parameter is an empty list.\n     */\n    getClosestElement(children, x, y) {\n\n        return [...children].reduce((closest, child) => {\n\n            const box = child.getBoundingClientRect();\n            const xDistance = x - box.left - box.width / 2;\n            const yDistance = y - box.top - box.height / 2;\n            const offset = Math.sqrt(xDistance**2 + yDistance**2);\n\n            if (offset < closest.offset) {\n\n                return {\n                    offset,\n                    element: child\n                };\n\n            }\n\n            return closest;\n\n        }, { offset: Number.POSITIVE_INFINITY }).element;\n\n    }\n\n    /**\n     * Checks to see if the given target element is before or after the source\n     * element in the DOM list.\n     *\n     * @param  {Element} target\n     *         Target element to check.\n     * @param  {Element} source\n     *         Source element to check against.\n     * @return {Boolean}\n     *         true if the target is before the source, false otherwise.\n     * @see    https://stackoverflow.com/a/28962290/557019\n     */\n    isBefore(target, source) {\n\n        if (target.parentNode === source.parentNode) {\n\n            for (\n                let current = target.previousSibling;\n                current && current.nodeType !== Node.DOCUMENT_NODE;\n                current = current.previousSibling\n            ) {\n\n                if (current === source) {\n                    return true;\n                }\n\n            }\n\n        }\n\n        return false;\n\n    }\n\n    /**\n     * Handles the moving of the element currently stored in\n     * {@link Draggable#dragged} - if there is no element stored there then this\n     * function ends early.\n     *\n     * @param {Event} event\n     *        Either a \"dragover\" or a \"touchmove\" event.\n     */\n    move(event) {\n\n        const {\n            dataTransfer,\n            targetTouches\n        } = event;\n        const pointer = (\n            targetTouches\n            ? targetTouches[0]\n            : event\n        );\n        const {\n            dragged,\n            children,\n            container\n        } = this;\n\n        if (!pointer || !dragged) {\n            return;\n        }\n\n        event.preventDefault();\n\n        // dataTransfer is only a property with \"drop\" events.\n        if (dataTransfer) {\n            dataTransfer.dropEffect = \"move\";\n        }\n\n        const closest = this.getClosestElement(\n            children,\n            pointer.clientX,\n            pointer.clientY\n        );\n\n        if (!closest) {\n            return;\n        }\n\n        container.insertBefore(\n            dragged,\n            (\n                this.isBefore(dragged, closest)\n                ? closest\n                : closest.nextElementSibling\n            )\n        );\n\n    }\n\n    /**\n     * Adds event listeners to {@link Draggable#container}.\n     */\n    addEventListeners() {\n\n        const {\n            container\n        } = this;\n\n        container.addEventListener(\"dragover\", (e) => this.move(e));\n        container.addEventListener(\"touchmove\", (e) => this.move(e));\n        container.addEventListener(\"drop\", (e) => e.preventDefault());\n\n    }\n\n    /**\n     * Handles a child element being added to {@link Draggable#container}.\n     *\n     * @param {Element} child\n     *        The child element that has been added.\n     */\n    addChild(child) {\n\n        child.classList.add(this.settings.childClass);\n        child.setAttribute(\"draggable\", true);\n        child.addEventListener(\"dragstart\", this.onChildDragStart);\n        child.addEventListener(\"dragend\", this.onChildDragEnd);\n        child.addEventListener(\"touchstart\", this.onChildDragStart);\n        child.addEventListener(\"touchend\", this.onChildDragEnd);\n        this.children.add(child);\n\n    }\n\n    /**\n     * Handles a child element being removed from {@link Draggable#container}.\n     *\n     * @param {Element} child\n     *        The child element that has been removed.\n     */\n    removeChild(child) {\n\n        const {\n            children\n        } = this;\n\n        if (!children.has(child)) {\n            return;\n        }\n\n        child.classList.remove(this.settings.childClass);\n        child.removeAttribute(\"draggable\");\n        child.removeEventListener(\"dragstart\", this.onChildDragStart);\n        child.removeEventListener(\"dragend\", this.onChildDragEnd);\n        child.removeEventListener(\"touchstart\", this.onChildDragStart);\n        child.removeEventListener(\"touchend\", this.onChildDragEnd);\n        children.delete(child);\n\n    }\n\n    /**\n     * A helper function for children stored in {@link Draggable#children} from\n     * {@link Draggable#container}.\n     */\n    removeAllChildren() {\n        [...this.children].forEach((child) => this.removeChild(child));\n    }\n\n}\n","import Dialog from \"./Dialog.js\";\nimport TokenStore from \"./TokenStore.js\";\nimport Template from \"./Template.js\";\nimport CharacterToken from \"./CharacterToken.js\";\nimport SettableTitle from \"./SettableTitle.js\";\nimport Draggable from \"./Draggable.js\";\nimport {\n    getIndex,\n    lookupOne,\n    lookupOneCached,\n    replaceContentsMany\n} from \"../utils/elements.js\";\n\n/**\n * A version of {@link Dialog} that shows one or more tokens, probably to the\n * player.\n */\nexport default class TokenDialog extends Dialog {\n\n    /**\n     * Gets a cached instance of {@link TokenDialog}, allowing it to act like a\n     * singleton.\n     *\n     * @return {TokenDialog}\n     *         An instance.\n     */\n    static get() {\n        return this.create(lookupOneCached(\"#token\"));\n    }\n\n    /**\n     * @inheritdoc\n     */\n    constructor(dialog) {\n\n        super(dialog);\n\n        /**\n         * The token store that keeps information about the tokens.\n         * @type {TokenStore}\n         */\n        this.tokenStore = null;\n\n        /**\n         * The template for one token.\n         * @type {Template}\n         */\n        this.entryTemplate = null;\n\n    }\n\n    /**\n     * @inheritdoc\n     */\n    run() {\n\n        this.setIds([]);\n        this.discoverElements();\n        this.activateSettableTitle();\n        this.activateDraggable();\n        super.run();\n\n    }\n\n    /**\n     * @inheritdoc\n     */\n    addListeners() {\n\n        super.addListeners();\n\n        const {\n            constructor: {\n                SHOW,\n                HIDE\n            },\n            dialog\n        } = this;\n\n        this.on(SHOW, () => this.drawCharacters());\n        this.on(HIDE, () => this.setMultipleTitle(\"\"));\n\n        dialog.addEventListener(\"click\", ({ target }) => {\n\n            const removeButton = target.closest(\".js--token--remove\");\n            const removeItem = removeButton?.closest(\".js--token--item\");\n\n            if (removeItem) {\n\n                this.removeIdByIndex(getIndex(removeItem));\n                this.drawCharacters();\n\n            }\n\n        });\n\n    }\n\n    /**\n     * Discovered elements, storing them on the instance so they can be\n     * referenced by other methods without having to be found again.\n     */\n    discoverElements() {\n\n        const {\n            dialog\n        } = this;\n\n        /**\n         * The element that contains all the token renderings.\n         * @type {Element}\n         */\n        this.holder = lookupOne(\".js--token--holder\", dialog);\n\n    }\n\n    /**\n     * Activates the {@link SettableTitle} class so that the title of the dialog\n     * can be changed.\n     */\n    activateSettableTitle() {\n\n        const {\n            dialog\n        } = this;\n\n        /**\n         * A class that allows the title of the dialog to be set.\n         */\n        this.settableTitle = new SettableTitle(\n            dialog.querySelector(\".js--settable-title--title\"),\n            dialog.querySelector(\".js--settable-title--input\")\n        );\n\n    }\n\n    /**\n     * Activates the {@link Draggable} class so tokens within this dialog can be\n     * dragged and re-ordered.\n     */\n    activateDraggable() {\n\n        /**\n         * A class that enables the dragging and re-ordering of tokens.\n         * @type {Draggable}\n         */\n        this.draggable = new Draggable(this.holder);\n\n    }\n\n    /**\n     * Adds a token ID to {@link TokenDialog#ids}. The ID does not need to be\n     * unique.\n     *\n     * @param {String} id\n     *        ID to add.\n     */\n    addId(id) {\n        this.ids.push(id);\n    }\n\n    /**\n     * Removes all IDs from {@link TokenDialog#ids} that match the given ID.\n     *\n     * @param {String}\n     *        ID to remove.\n     */\n    removeId(id) {\n        this.ids = this.ids.filter((existingId) => existingId !== id);\n    }\n\n    /**\n     * Removes the ID from {@link TokenDialog#ids} that's at the given index.\n     *\n     * @param {Number} index\n     *        Index that should be removed from the IDs. If the index is less\n     *        than 0, no action is taken.\n     */\n    removeIdByIndex(index) {\n\n        if (index < 0) {\n            return;\n        }\n\n        this.ids.splice(index, 1);\n\n    }\n\n    /**\n     * Sets {@link TokenDialog#ids}.\n     *\n     * @param {Array.<String>} ids\n     *        IDs to set. This may be an empty array.\n     */\n    setIds(ids) {\n\n        /**\n         * A list of all the token IDs that will be displayed when the dialog\n         * shows.\n         * @type {Array.<String>}\n         */\n        this.ids = ids;\n\n    }\n\n    /**\n     * Gets a copy of {@link TokenDialog#ids}. Modifying the copy does not\n     * affect the original.\n     *\n     * @return {Array.<String>}\n     *         Copy of the IDs.\n     */\n    getIds() {\n        return [...this.ids];\n    }\n\n    /**\n     * Sets {@link TokenDialog#tokenStore}.\n     *\n     * @param {TokenStore} tokenStore\n     *        The token store.\n     */\n    setTokenStore(tokenStore) {\n        this.tokenStore = tokenStore;\n    }\n\n    /**\n     * Sets {@link TokenDialog#entryTemplate}.\n     *\n     * @param {Template} entryTemplate\n     *        The template.\n     */\n    setEntryTemplate(entryTemplate) {\n        this.entryTemplate = entryTemplate;\n    }\n\n    /**\n     * Gets a {@link CharacterToken} for each ID in {@link TokenDialog#ids}.\n     *\n     * @return {Array.<CharacterToken>}\n     *         Characters that this dialog should show.\n     */\n    getCharacters() {\n\n        const {\n            tokenStore\n        } = this;\n\n        if (!tokenStore) {\n            throw new Error(\"tokenStore has not been set\");\n        }\n\n        return this.ids.map((id) => tokenStore.getCharacter(id));\n\n    }\n\n    /**\n     * Gets the title text to display when there is more than one character\n     * being displayed.\n     *\n     * @return {String}\n     *         The title for multiple characters.\n     */\n    getMultipleTitle() {\n\n        return (\n            this.multipleTitle\n            || this.settableTitle.getForm()?.dataset.multiple\n            || \"\"\n        );\n\n    }\n\n    /**\n     * Sets {@link TokenDialog#multipleTitle}.\n     *\n     * @param {String} multipleTitle\n     *        The text to display when there are multiple characters to show.\n     */\n    setMultipleTitle(multipleTitle) {\n\n        /**\n         * The text to show when there are multiple characters being displayed.\n         * @type {String}\n         */\n        this.multipleTitle = multipleTitle;\n\n    }\n\n    /**\n     * Displays all the characters in the dialog.\n     *\n     * @throws {Error}\n     *         {@link TokenDialog#entryTemplate} must be set.\n     */\n    drawCharacters() {\n\n        const {\n            holder,\n            settableTitle,\n            draggable,\n            entryTemplate\n        } = this;\n\n        if (!entryTemplate) {\n            throw new Error(\"entryTemplate has not been set\");\n        }\n\n        const characters = this.getCharacters();\n        const isMultiple = characters.length > 1;\n\n        draggable.removeAllChildren();\n\n        replaceContentsMany(\n            holder,\n            characters.map((character) => entryTemplate.draw({\n                \".js--token--show\"(element) {\n                    element.append(character.drawToken());\n                },\n                \".js--token--ability\"(element) {\n                    element.textContent = character.getAbility();\n                    element.hidden = isMultiple;\n                }\n            }))\n        );\n\n        const titleText = (\n            isMultiple\n            ? this.getMultipleTitle()\n            : (characters[0]?.getName() || \"\")\n        );\n        settableTitle.setStartText(titleText);\n        settableTitle.setTitle(titleText);\n        holder.classList.toggle(\"is-multiple\", isMultiple);\n\n        if (isMultiple) {\n\n            holder.querySelectorAll(\".js--token--item\").forEach((child) => {\n                draggable.addChild(child);\n            });\n\n        }\n\n    }\n\n}\n","import Dialog from \"../../classes/Dialog.js\";\nimport SelectDialog from \"../../classes/SelectDialog.js\";\nimport Observer from \"../../classes/Observer.js\";\nimport Pad from \"../../classes/Pad.js\";\nimport Template from \"../../classes/Template.js\";\nimport TokenStore from \"../../classes/TokenStore.js\";\nimport TokenDialog from \"../../classes/TokenDialog.js\";\nimport Names from \"../../classes/Names.js\";\nimport {\n    identify,\n    lookup,\n    lookupOne,\n    lookupOneCached,\n    replaceContentsMany\n} from \"../../utils/elements.js\";\n\nconst gameObserver = Observer.create(\"game\");\nconst tokenObserver = Observer.create(\"token\");\nconst pad = lookupOneCached(\".js--pad\").pad;\nconst recentReminders = lookupOneCached(\"#character-show-reminders\");\nconst characterShowDialog = Dialog.create(lookupOneCached(\"#character-show\"));\nconst tokenDialog = TokenDialog.get();\ntokenDialog.setEntryTemplate(new Template(lookupOne(\"#token-entry-template\")));\n\n// Set up the token dialog when a character token is clicked.\ntokenObserver.on(\"character-click\", ({ detail }) => {\n\n    const {\n        element\n    } = detail;\n    const character = pad.getCharacterByToken(element);\n\n    characterShowDialog.getElement().dataset.token = `#${identify(element)}`;\n    lookupOneCached(\"#character-show-name\").textContent = character.getName();\n    lookupOneCached(\"#character-show-ability\").textContent = character.getAbility();\n    recentReminders.dataset.coords = JSON.stringify(pad.getTokenPosition(element));\n\n    characterShowDialog.show();\n\n});\n\n// Update the recently-added-reminders list as a reminder is added.\ntokenObserver.on(\"reminder-add\", ({ detail }) => {\n\n    const {\n        reminder\n    } = detail;\n    const id = reminder.getId();\n    const items = lookup(\".js--reminder-list--item\", recentReminders);\n\n    const existing = items.find(({ dataset }) => dataset.reminderId === id);\n\n    if (existing && existing === items[0]) {\n        return;\n    }\n\n    if (items.length > 2 || (existing && existing !== items[0])) {\n        (existing || items[items.length - 1]).remove();\n    }\n\n    recentReminders.prepend(reminder.drawList());\n\n});\n\nfunction getToken(target) {\n    return lookupOne(target.closest(\"[data-token]\").dataset.token);\n}\n\nfunction hideDialog(target) {\n    Dialog.create(target.closest(\".dialog\")).hide();\n}\n\nTokenStore.ready(() => {\n\n    // Show a token as it's clicked from the \"show tokens\" dialog.\n    lookupOne(\"#character-show-token\").addEventListener(\"click\", ({ target }) => {\n\n        tokenDialog.setIds([\n            pad.getCharacterByToken(getToken(target)).getId()\n        ]);\n        tokenDialog.show();\n\n        hideDialog(target);\n\n    });\n\n});\n\nlookupOne(\"#character-shroud-toggle\").addEventListener(\"click\", ({ target }) => {\n\n    pad.toggleDeadByToken(getToken(target));\n    hideDialog(target);\n\n});\n\nlookupOne(\"#character-rotate\").addEventListener(\"click\", ({ target }) => {\n\n    pad.rotateByToken(getToken(target));\n    hideDialog(target);\n\n});\n\nlookupOne(\"#character-reminder\").addEventListener(\"click\", ({ target }) => {\n\n    const reminder = lookupOneCached(\"#reminder-list\");\n    const token = getToken(target);\n\n    reminder.dataset.coords = JSON.stringify(pad.getTokenPosition(token));\n    Dialog.create(reminder).show();\n    hideDialog(target);\n\n});\n\nconst characterListDialog = SelectDialog.get();\ncharacterListDialog.addProcess({\n\n    // The generic process: add a token to the pad when the icon is clicked.\n\n    click(tokenId) {\n\n        TokenStore.ready((tokenStore) => {\n            pad.addCharacter(tokenStore.getCharacterClone(tokenId));\n        });\n        characterListDialog.hide();\n\n    }\n\n});\n\n// The process that will replace one token in the grimoire with another one.\nconst replaceOnPadProcess = {\n\n    data: null,\n\n    click(tokenId) {\n\n        TokenStore.ready((tokenStore) => {\n\n            const {\n                character,\n                token: newToken\n            } = pad.addCharacter(tokenStore.getCharacterClone(tokenId));\n            const {\n                data\n            } = this;\n\n            if (data) {\n\n                const {\n                    token,\n                    coords: {\n                        x,\n                        y,\n                        z\n                    }\n                } = data;\n\n                const oldCharacter = pad.getCharacterByToken(lookupOne(token));\n                pad.toggleDead(character, oldCharacter.getIsDead());\n                pad.rotate(character, oldCharacter.getIsUpsideDown());\n                pad.setPlayerName(character, pad.getPlayerName(oldCharacter));\n                pad.removeCharacter(oldCharacter);\n                pad.moveToken(newToken, x, y, z);\n\n            }\n\n        });\n\n        characterListDialog.hide();\n\n    },\n\n    hide() {\n        this.data = null;\n        characterListDialog.removeProcess(replaceOnPadProcess);\n    }\n\n};\n\nlookupOne(\"#character-replace\").addEventListener(\"click\", ({ target }) => {\n\n    const token = getToken(target);\n    replaceOnPadProcess.data = {\n        coords: pad.getTokenPosition(token),\n        token: `#${identify(token)}`\n    };\n    characterListDialog.addProcess(replaceOnPadProcess);\n    characterListDialog.show();\n    hideDialog(target);\n\n});\n\n// The process that will add another token to the token dialog.\nconst addToDialogProcess = {\n\n    click(tokenId) {\n        tokenDialog.addId(tokenId);\n        tokenDialog.show();\n        characterListDialog.hide();\n    },\n\n    hide() {\n        characterListDialog.removeProcess(addToDialogProcess);\n    }\n\n};\n\nlookupOne(\".js--token--add\").addEventListener(\"click\", () => {\n    characterListDialog.addProcess(addToDialogProcess);\n    characterListDialog.show();\n    tokenDialog.hide();\n});\n\nconst characterNameInput = lookupOne(\"#character-name-input\");\nlookupOne(\"#character-name\").addEventListener(\"click\", ({ target }) => {\n\n    const {\n        value\n    } = characterNameInput;\n    const name = (value || \"\").trim();\n\n    pad.setPlayerNameForToken(getToken(target), name);\n    hideDialog(target);\n\n});\n\nconst ghostVoteButton = lookupOneCached(\"#character-ghost-vote\");\n\nfunction setGhostButtonState(character) {\n\n    ghostVoteButton.disabled = (\n        ghostVoteButton,\n        !character.getIsDead() || !character.getHasGhostVote()\n    );\n\n}\n\nlookupOneCached(\"#character-show\").addEventListener(Dialog.SHOW, ({ target }) => {\n\n    const token = lookupOne(target.dataset.token);\n    const character = pad.getCharacterByToken(token);\n\n    setGhostButtonState(character);\n\n});\n\nghostVoteButton.addEventListener(\"click\", ({ target }) => {\n\n    const token = getToken(target);\n    pad.setGhostVoteForToken(token, false);\n\n    const character = pad.getCharacterByToken(token);\n    setGhostButtonState(character);\n\n    hideDialog(target);\n\n});\n\ncharacterShowDialog.on(Dialog.SHOW, () => {\n\n    const token = getToken(characterShowDialog.getElement());\n    characterNameInput.value = pad.getPlayerNameForToken(token);\n\n    lookupOneCached(\"#character-show-orphan\").hidden = (\n        !token.classList.contains(\"is-orphan\")\n    );\n\n});\n\ncharacterShowDialog.on(Dialog.HIDE, () => {\n    characterNameInput.value = characterNameInput.defaultValue;\n});\n\nlookupOne(\"#character-remove\").addEventListener(\"click\", ({ target }) => {\n\n    pad.removeCharacterByToken(getToken(target));\n    hideDialog(target);\n\n});\n\n// Update the night order on the tokens.\n// #72: Use objects rather than arrays to allow for decimals in night orders.\nconst nightOrder = {\n    first: Object.create(null),\n    other: Object.create(null)\n};\n\nfunction getSortedKeys(object) {\n    return Object.keys(object).sort((a, b) => Number(a) - Number(b));\n}\n\nfunction assignCounts(object, dataKey) {\n\n    let count = 0;\n\n    getSortedKeys(object).forEach((key) => {\n\n        const tokens = object[key];\n\n        count += 1;\n\n        tokens.forEach(({ token }) => {\n            Pad.getToken(token).dataset[dataKey] = count;\n        });\n\n    });\n\n}\n\nfunction updateTokens() {\n\n    assignCounts(nightOrder.first, \"firstNight\");\n    assignCounts(nightOrder.other, \"otherNight\");\n\n}\n\ntokenObserver.on(\"character-add\", ({ detail }) => {\n\n    const {\n        character,\n        token\n    } = detail;\n    const {\n        first,\n        other\n    } = nightOrder;\n\n    const firstNight = character.getFirstNight();\n\n    if (firstNight) {\n\n        if (!first[firstNight]) {\n            first[firstNight] = [];\n        }\n\n        first[firstNight].push({\n            character,\n            token\n        });\n\n    }\n\n    const otherNight = character.getOtherNight();\n\n    if (otherNight) {\n\n        if (!other[otherNight]) {\n            other[otherNight] = [];\n        }\n\n        other[otherNight].push({\n            character,\n            token\n        });\n\n    }\n\n    updateTokens();\n\n});\n\ntokenObserver.on(\"character-remove\", ({ detail }) => {\n\n    const {\n        character,\n        token\n    } = detail;\n    const {\n        first,\n        other\n    } = nightOrder;\n\n    const firstNight = character.getFirstNight();\n    const firstArray = first[firstNight];\n\n    if (firstArray) {\n\n        const index = firstArray.findIndex((info) => info.token === token);\n\n        if (index > -1) {\n            firstArray.splice(index, 1);\n        }\n\n        if (!firstArray.length) {\n            delete first[firstNight];\n        }\n\n    }\n\n    const otherNight = character.getOtherNight();\n    const otherArray = other[otherNight];\n\n    if (otherArray) {\n\n        const index = otherArray.findIndex((info) => info.token === token);\n\n        if (index > -1) {\n            otherArray.splice(index, 1);\n        }\n\n        if (!otherArray.length) {\n            delete other[otherNight];\n        }\n\n    }\n\n    updateTokens();\n\n});\n\n// List of tokens.\n// TODO: could we use character.drawList() here?\n\nconst tokenListTemplate = Template.create(lookupOne(\"#token-list-template\"));\nconst tokenList = lookupOne(\"#token-list__list\");\n\ngameObserver.on(\"characters-selected\", ({ detail }) => {\n\n    const characters = detail.characters.filter((character) => {\n        const team = character.getTeam();\n        return team !== \"traveller\";\n    });\n\n    replaceContentsMany(\n        tokenList,\n        characters.map((character) => tokenListTemplate.draw({\n            \".js--token-list--button\"(element) {\n                element.dataset.tokenId = character.getId();\n            },\n            \".js--token-list--token\"(element) {\n                element.append(character.drawToken());\n            }\n        }))\n    );\n\n});\n\n// #131 - highlight any orphan character and reminder tokens.\ngameObserver.on(\"characters-selected\", ({ detail }) => {\n\n    TokenStore.ready((store) => {\n\n        pad.characters.forEach(({ character, token }) => {\n\n            if ([\"traveller\", \"fabled\"].includes(character.getTeam())) {\n                return;\n            }\n\n            const index = detail.characters.findIndex((char) => {\n                return char.getId() === character.getId();\n            });\n\n            token.classList.toggle(\"is-orphan\", index < 0);\n\n        });\n\n        pad.reminders.forEach(({ reminder, token }) => {\n\n            const character = store.getCharacter(reminder.getCharacterId());\n\n            if ([\"traveller\", \"fabled\"].includes(character.getTeam())) {\n                return;\n            }\n\n            const index = detail.characters.findIndex((char) => {\n                return char.getId() === character.getId();\n            });\n\n            token.classList.toggle(\"is-orphan\", index < 0);\n\n        });\n\n    });\n\n});\n\nTokenStore.ready((tokenStore) => {\n\n    tokenDialog.setTokenStore(tokenStore);\n    const tokenListDialog = Dialog.create(lookupOne(\"#token-list\"));\n\n    tokenList.addEventListener(\"click\", ({ target }) => {\n\n        const button = target.closest(\"[data-token-id]\");\n\n        if (!button) {\n            return;\n        }\n\n        tokenDialog.setIds([button.dataset.tokenId]);\n        tokenDialog.show();\n        tokenListDialog.hide();\n\n    });\n\n});\n\n// Update the list of suggested names that can be set when a token is drawn.\n\nconst names = Names.create();\n\nnames.on(\"names-added\", () => {\n\n    replaceContentsMany(\n        lookupOneCached(\"#player-name-options\"),\n        names.drawList()\n    );\n    replaceContentsMany(\n        lookupOneCached(\"#character-name-input-options\"),\n        names.drawList()\n    );\n\n});\n\nnames.on(\"names-cleared\", () => {\n\n    empty(lookupOneCached(\"#player-name-options\"));\n    empty(lookupOneCached(\"#character-name-input-options\"));\n\n});\n","import Observer from \"../../classes/Observer.js\";\nimport Dialog from \"../../classes/Dialog.js\";\nimport TokenStore from \"../../classes/TokenStore.js\";\nimport {\n    empty,\n    identify,\n    lookup,\n    lookupOne,\n    lookupOneCached\n} from \"../../utils/elements.js\";\n\nconst tokenObserver = Observer.create(\"token\");\nconst pad = lookupOneCached(\".js--pad\").pad;\nconst reminderList = lookupOneCached(\"#reminder-list\");\nconst reminderListDialog = Dialog.create(reminderList);\n\nfunction getCoords(element) {\n    return JSON.parse(element.dataset.coords || \"null\");\n}\n\nfunction addReminderQuick(target, tokenStore, coords) {\n\n    const button = target?.closest(\"[data-reminder-id]\");\n\n    if (!button) {\n        return;\n    }\n\n    const clone = tokenStore.getReminderClone(button.dataset.reminderId);\n    const {\n        token\n    } = pad.addReminder(clone);\n\n    if (coords) {\n        pad.moveToken(token, coords.x, coords.y);\n    }\n\n    reminderListDialog.hide();\n\n}\n\nfunction toggleReminder(target) {\n\n    const button = target.closest(\"[data-reminder-id]\");\n    const checkbox = lookupOne(\n        `.js--reminder-list--checkbox[value=\"${button?.dataset.reminderId}\"]`\n    );\n\n    if (!button || !checkbox) {\n        return;\n    }\n\n    checkbox.checked = !checkbox.checked;\n\n}\n\nTokenStore.ready((tokenStore) => {\n\n    let isAddMultiple = false;\n\n    // Add a reminder to the page if it's clicked from the list.\n    lookupOneCached(\"#reminder-list__list\").addEventListener(\"click\", ({ target }) => {\n\n        if (isAddMultiple) {\n            toggleReminder(target);\n        } else {\n\n            addReminderQuick(target, tokenStore, getCoords(reminderList));\n            reminderListDialog.hide();\n\n        }\n\n    });\n\n    const multipleReminders = lookupOne(\"#multiple-reminders\");\n    const addAllReminders = lookupOne(\".js--reminder-list--multiple\");\n\n    multipleReminders.addEventListener(\"change\", () => {\n\n        const isNowAddMultiple = multipleReminders.checked;\n\n        isAddMultiple = isNowAddMultiple;\n        addAllReminders.hidden = !isNowAddMultiple;\n\n        if (!isNowAddMultiple) {\n\n            lookup(\".js--reminder-list--checkbox\").forEach((checkbox) => {\n                checkbox.checked = false;\n            });\n\n        }\n\n    });\n\n    addAllReminders.addEventListener(\"click\", () => {\n\n        const coords = getCoords(reminderList) || { x: 0, y: 0 };\n\n        lookup(\".js--reminder-list--checkbox:checked\").forEach((checkbox) => {\n\n            // TODO: replace this with a Positioner?\n            coords.x += 15;\n            coords.y += 15;\n            addReminderQuick(\n                lookupOne(`.js--reminder-list--button[data-reminder-id=\"${checkbox.value}\"]`),\n                tokenStore,\n                coords\n            );\n            checkbox.checked = false;\n\n        });\n\n        reminderListDialog.hide();\n\n    });\n\n    const recentReminders = lookupOneCached(\"#character-show-reminders\");\n\n    // Add a reminder token to the page if the recently-added-reminder is clicked.\n    recentReminders.addEventListener(\"click\", ({ target }) => {\n\n        addReminderQuick(target, tokenStore, getCoords(recentReminders));\n        Dialog.create(lookupOneCached(\"#character-show\")).hide();\n\n    });\n\n    const reminderDialog = Dialog.create(lookupOne(\"#reminder-show\"));\n    const reminderHolder = lookupOne(\"#reminder-show-token\");\n\n    // Populate the reminder dialog as a reminder is clicked.\n    tokenObserver.on(\"reminder-click\", ({ detail }) => {\n\n        const {\n            element\n        } = detail;\n        const reminder = tokenStore.getReminder(element.dataset.reminder);\n\n        empty(reminderHolder).append(reminder.drawToken());\n        reminderHolder.dataset.token = `#${identify(element)}`;\n        lookupOneCached(\"#reminder-show-orphan\").hidden = (\n            !element.classList.contains(\"is-orphan\")\n        );\n        reminderDialog.show();\n\n    });\n\n    // Remove a reminder when its \"remove\" button is clicked.\n    lookupOne(\"#reminder-remove\").addEventListener(\"click\", () => {\n\n        const token = lookupOne(reminderHolder.dataset.token);\n\n        if (!token) {\n            return;\n        }\n\n        pad.removeReminderByToken(token);\n        reminderDialog.hide();\n\n    });\n\n    const counts = Object.create(null);\n    const list = lookupOneCached(\"#reminder-list__list\");\n\n    // If a character is added to the grimoire, make sure that its reminders are\n    // visible in the list.\n    tokenObserver.on(\"character-add\", ({ detail }) => {\n\n        const {\n            character\n        } = detail;\n        const characterId = character.getId();\n\n        if (!counts[characterId]) {\n            counts[characterId] = 0;\n        }\n\n        counts[characterId] += 1;\n\n        character.getReminders().forEach((reminder) => {\n\n            lookupOne(\n                `[data-reminder-id=\"${reminder.getId()}\"]`,\n                list\n            )?.classList.add(\"is-in-play\");\n\n        });\n\n    });\n\n    // If a character is removed from the grimoire, and there are no other\n    // copies of that character in the grimoire, hide its reminders.\n    tokenObserver.on(\"character-remove\", ({ detail }) => {\n\n        const {\n            character\n        } = detail;\n        const characterId = character.getId();\n\n        if (counts[characterId]) {\n            counts[characterId] -= 1;\n        }\n\n        if (!counts[characterId]) {\n\n            character.getReminders().forEach((reminder) => {\n\n                lookupOne(\n                    `[data-reminder-id=\"${reminder.getId()}\"]`,\n                    list\n                )?.classList.remove(\"is-in-play\");\n\n            });\n\n        }\n\n    });\n\n    lookupOne(\"#show-all-reminders\").addEventListener(\"change\", ({ target }) => {\n        list.classList.toggle(\"is-show-all\", target.checked);\n    });\n\n});\n\nreminderListDialog.on(Dialog.HIDE, ({ target }) => {\n    target.removeAttribute(\"data-coords\");\n});\n","import Dialog from \"./Dialog.js\";\nimport CharacterToken from \"./CharacterToken.js\";\nimport {\n    lookupOneCached\n} from \"../utils/elements.js\";\n\n/**\n * A version of {@link Dialog} with extra abilities for displaying a token.\n */\nexport default class BluffDialog extends Dialog {\n\n    /**\n     * @inheritDoc\n     */\n    static createFromTrigger(trigger) {\n\n        trigger.dataset.dialog = trigger.dataset.bluffDialog;\n        super.createFromTrigger(trigger);\n\n    }\n\n    /**\n     * Displays the given character within {@link BluffDialog#dialog}.\n     *\n     * @param {CharacterToken} character\n     *        Character to display.\n     * @param {Boolean} isOrphan\n     *        true if the \"orphan\" note should be shown, false otherwise.\n     */\n    display(character, isOrphan = false) {\n\n        const {\n            dialog\n        } = this;\n        const showTokenButton = lookupOneCached(\"#bluff-show-token\", dialog);\n\n        lookupOneCached(\n            \"#bluff-show-name\",\n            dialog\n        ).textContent = character.getName();\n        lookupOneCached(\n            \"#bluff-show-ability\",\n            dialog\n        ).textContent = character.getAbility();\n        lookupOneCached(\n            \"#bluff-show-orphan\",\n            dialog\n        ).hidden = !isOrphan;\n        showTokenButton.disabled = character.isEmpty();\n        showTokenButton.dataset.characterId = character.getId();\n\n    }\n\n}\n","import CharacterToken from \"./CharacterToken\";\n\n/**\n * Manages the set of 3 demon bluffs, handling the tokens.\n */\nexport default class BluffSet {\n\n    /**\n     * Sets the {@link CharacterToken} for an empty character - this is used as\n     * the default character in the bluffs before one is set.\n     *\n     * @param {CharacterToken} emptyCharacter\n     */\n    static setEmptyCharacter(emptyCharacter) {\n\n        /**\n         * The empty character token.\n         * @type {CharacterToken}\n         */\n        this.emptyCharacter = emptyCharacter;\n\n    }\n\n    constructor() {\n\n        /**\n         * The characters in this set.\n         * @type {CharacterToken[]}\n         */\n        this.characters = [\n            this.getEmptyCharacter(),\n            this.getEmptyCharacter(),\n            this.getEmptyCharacter()\n        ];\n\n        /**\n         * The index of the current character being set or checked.\n         * @type {Number}\n         */\n        this.index = 0;\n\n    }\n\n    /**\n     * Gets the {@link CharacterToken} for the empty character.\n     *\n     * @return {CharacterToken}\n     *         A clone of the \"empty character\" token.\n     * @throws {Error}\n     *         {@link BluffSet.emptyCharacter} must be defined.\n     */\n    getEmptyCharacter() {\n\n        const {\n            emptyCharacter\n        } = this.constructor;\n\n        if (!emptyCharacter) {\n            throw new Error(\"The \\\"No character\\\" character needs to be set.\");\n        }\n\n        return emptyCharacter.clone();\n    }\n\n    /**\n     * Validates the given index so that we know it's a number between 0 and\n     * the number of characters in {@link BluffSet#characters}.\n     *\n     * @param  {Number} index\n     *         Index to validate.\n     * @return {Number}\n     *         Validated index.\n     * @throws {RangeError}\n     *         `index` must be between 0 and the length of\n     *         {@link BluffSet#characters}.\n     */\n    validateIndex(index) {\n\n        index = Number(index);\n\n        if (index < 0 || index >= this.characters.length) {\n            throw new RangeError(`BluffSet invalid index ${index}`)\n        }\n\n        return index;\n\n    }\n\n    /**\n     * Exposes {@link BluffsSet#characters}, but clones the array so that\n     * manipulating the response from this method doesn't affect the original\n     * data.\n     *\n     * @return {CharacterToken[]}\n     *         Copy of {@link BluffsSet#characters}.\n     */\n    getCharacters() {\n        return [...this.characters];\n    }\n\n    /**\n     * Gets the character at the requested index. If the index isn't given,\n     * {@link BluffsSet#index} is used instead. The index is validated using\n     * {@link BluffSet#validateIndex}.\n     *\n     * @param  {Number} [index]\n     *         Optional index. If ommitted, {@link BluffsSet#index} is used.\n     * @return {CharacterToken}\n     *         The character at the given index.\n     */\n    getCharacter(index = this.index) {\n        return this.characters[this.validateIndex(index)];\n    }\n\n    /**\n     * Sets the character at the given index. If the index is ommitted,\n     * {@link BluffsSet#index} is used instead. The index is validated using\n     * {@link BluffSet#validateIndex}.\n     *\n     * @param {CharacterToken} character\n     *        Character to set.\n     * @param {Number} [index]\n     *        Optional index. If ommitted, {@link BluffsSet#index} is used.\n     */\n    setCharacter(character, index = this.index) {\n\n        if (!character) {\n            character = this.getEmptyCharacter();\n        }\n\n        this.characters[this.validateIndex(index)] = character;\n\n    }\n\n    /**\n     * Unsets the character. This is done by looking up the index of the\n     * character form within {@link BluffSet#characters} and passing it to\n     * {@link BluffSet#unsetCharacterByIndex}.\n     *\n     * @param {CharacterToken} character\n     *        The character to unset.\n     */\n    unsetCharacter(character) {\n        this.unsetCharacterByIndex(this.characters.indexOf(character));\n    }\n\n    /**\n     * Unsets the character at the given index. This is done by setting the\n     * character in {@link BluffSet#character} at the given index to a clone of\n     * the \"empty\" character. The given index is validated using\n     * {@link BluffSet#validateIndex}.\n     *\n     * @param {Number} index\n     *        Index of the character to unset.\n     */\n    unsetCharacterByIndex(index) {\n        this.characters[this.validateIndex(index)] = this.getEmptyCharacter();\n    }\n\n    /**\n     * Sets {@link BluffSet#index}. The given index is validated using\n     * {@link BluffSet#validateIndex}.\n     *\n     * @param {Number} index\n     *        The index to set.\n     */\n    setIndex(index) {\n        this.index = this.validateIndex(index);\n    }\n\n    /**\n     * Exposes {@link BluffSet#index}.\n     *\n     * @return {Number}\n     *         The current index.\n     */\n    getIndex() {\n        return this.index;\n    }\n\n    /**\n     * Returns an array containing the IDs of the characters in\n     * {@link BluffSet#characters}.\n     *\n     * @return {String[]}\n     *         The IDs of the characters in this set.\n     */\n    serialise() {\n        return this.characters.map((character) => character.getId());\n    }\n\n}\n","import BluffSet from \"./BluffSet.js\";\nimport CharacterToken from \"./CharacterToken\";\nimport Template from \"./Template\";\nimport SettableTitle from \"./SettableTitle\";\nimport {\n    empty,\n    lookupOne\n} from \"../utils/elements.js\";\n\n/**\n * Manages the DOM elements that manage the group of 3 demon bluffs.\n */\nexport default class BluffsGroup {\n\n    /**\n     * The name of an event that's triggered when the group has been created.\n     */\n    static get READY() {\n        return \"bluff-group-ready\";\n    }\n\n    /**\n     * Sets the Template that will draw the Demon Bluff group.\n     *\n     * @param {Template} template\n     */\n    static setTemplate(template) {\n\n        /**\n         * The Template that will draw the Demon Bluff group.\n         * @type {Template}\n         */\n        this.template = template;\n\n    }\n\n    /**\n     * @param {BluffSet} bluffSet\n     *        The set of Demon Bluffs for this group.\n     */\n    constructor(bluffSet) {\n\n        /**\n         * The index of this group of Demon Bluffs - mainly controlled by the\n         * parent {@link BluffsGroups} class.\n         * @type {Number}\n         */\n        this.index = 0;\n\n        /**\n         * The set of Demon Bluffs for this group.\n         * @type {BluffSet}\n         */\n        this.bluffSet = bluffSet;\n\n    }\n\n    /**\n     * Sets the element that contains this group of Demon Bluffs.\n     *\n     * @param {HTMLElement} element\n     */\n    setElement(element) {\n\n        /**\n         * The element that contains this group of Demon Bluffs.\n         * @type {HTMLElement}\n         */\n        this.element = element;\n\n    }\n\n    /**\n     * Exposes {@link BluffsGroup#element}.\n     *\n     * @return {HTMLElement}\n     *         The element that contains this group of Demon Bluffs.\n     */\n    getElement() {\n        return this.element;\n    }\n\n    /**\n     * Sets {@link BluffsGroup#index}.\n     *\n     * @param {Number} index\n     *        Index to set.\n     */\n    setIndex(index) {\n\n        this.index = index;\n\n        if (this.element) {\n            this.element.dataset.groupId = this.index;\n        }\n\n    }\n\n    /**\n     * Returns an object that reflects the current state of this group of\n     * Demon Bluffs. It does this by calling {@link BluffSet#serialise} on\n     * {@link BluffsGroup#bluffSet} and {@link SettableTitle#getTitle} on\n     * {@link BluffsGroup#settableTitle}.\n     *\n     * @return {Object}\n     */\n    serialise() {\n\n        const {\n            bluffSet,\n            settableTitle\n        } = this;\n\n        return {\n            name: settableTitle?.getTitle() || \"\",\n            set: bluffSet.serialise()\n        };\n\n    }\n\n    /**\n     * Draws the HTML elements for this group of Demon Bluffs.\n     *\n     * @return {DocumentFragment}\n     *         The fragment of the drawn elements.\n     */\n    draw() {\n\n        return this.constructor.template.draw({\n            \".js--demon-bluffs--group\": (element) => {\n                element.dataset.groupId = this.index;\n            }\n        })\n\n    }\n\n    /**\n     * Gets a CSS selector that identifies {@link BluffsGroup#element}.\n     *\n     * @return {String}\n     *         CSS selector that identifies {@link BluffsGroup#element}.\n     */\n    getSelector() {\n        return `.js--demon-bluffs--group[data-group-id=\"${this.index}\"]`;\n    }\n\n    /**\n     * The set index is the current index in {@link BluffsGroup#bluffSet}. This\n     * function accesses it.\n     *\n     * @return {Number}\n     *         The set index.\n     */\n    getSetIndex() {\n        return this.bluffSet.getIndex();\n    }\n\n    /**\n     * The set index is the current index in {@link BluffsGroup#bluffSet}. This\n     * function sets it.\n     *\n     * @param {Number}\n     *        The set index to set.\n     */\n    setSetIndex(index) {\n        return this.bluffSet.setIndex(index);\n    }\n\n    /**\n     * Sets the character in {@link BluffsGroup#bluffSet}. Optionally, the index\n     * of the character can be defined, rather than using\n     * {@link BluffsGroup#setSetIndex} first.\n     *\n     * @param {CharacterToken} character\n     *        Character to set.\n     * @param {Number} [index]\n     *        Optional index for the character.\n     */\n    setCharacter(character, index) {\n        this.bluffSet.setCharacter(character, index);\n    }\n\n    /**\n     * Gets the character from {@link BluffsGroup#bluffSet}, either at the index\n     * requested or its own internal index if `index` is ommitted.\n     *\n     * @param  {Number} [index]\n     *         Optional index for the character to return.\n     * @return {CharacterToken}\n     *         The character token requested.\n     */\n    getCharacter(index) {\n        return this.bluffSet.getCharacter(index);\n    }\n\n    /**\n     * Makes {@link BluffsGroup#element} visible by scrolling it into view.\n     *\n     * @throws {Error}\n     *         {@link BluffsGroup#element} must be set.\n     */\n    display() {\n\n        const {\n            element\n        } = this;\n\n        if (!element) {\n            throw new Error(\"Cannot display group because there is no element\");\n        }\n\n        element.scrollIntoView({\n            block: \"nearest\"\n        });\n\n    }\n\n    /**\n     * Finishes the seting up of this group of Demon Bluffs and dispatches an\n     * event to announce that it's ready.\n     */\n    ready() {\n\n        const {\n            element,\n            bluffSet,\n            constructor: {\n                READY\n            }\n        } = this;\n\n        if (!element) {\n            return;\n        }\n\n        this.display();\n\n        bluffSet.getCharacters().forEach((character, index) => {\n\n            const button = lookupOne(\n                `.js--demon-bluffs--bluff[data-index=\"${index}\"]`,\n                element\n            );\n\n            empty(button).append(character.drawToken());\n\n        });\n\n        element.dispatchEvent(new CustomEvent(READY, {\n            bubbles: true,\n            cancelable: false,\n            detail: {\n                bluffGroup: this\n            }\n        }));\n\n    }\n\n    /**\n     * Removes {@link BluffsGroup#element} from the DOM, if it exists.\n     */\n    remove() {\n        this.element?.remove();\n    }\n\n    /**\n     * Redraws the button for the character that was most recently updated in\n     * {@link BluffsGroup#bluffSet}.\n     */\n    redrawButton() {\n\n        const {\n            element,\n            bluffSet\n        } = this;\n\n        const setIndex = bluffSet.getIndex();\n        const character = bluffSet.getCharacter(setIndex);\n\n        empty(lookupOne(\n            `.js--demon-bluffs--bluff[data-index=\"${setIndex}\"]`,\n            element\n        )).append(character.drawToken());\n\n    }\n\n    /**\n     * Sets the {@link SettableTitle} instance that will allow the name of this\n     * group of Demon Bluffs to be set. If there's a value in\n     * {@link BluffsGroup#settableTitleTitle} then it's passed to the instance\n     * before that property is deleted.\n     *\n     * @param {SettableTitle} settableTitle\n     *        SettableTitle instance for this group of Demon Bluffs.\n     */\n    setSettableTitle(settableTitle) {\n\n        this.settableTitle = settableTitle;\n\n        if (this.settableTitleTitle) {\n\n            settableTitle.setTitle(this.settableTitleTitle);\n            delete this.settableTitleTitle;\n\n        }\n\n    }\n\n    /**\n     * Sets the title of this group of Demon Bluffs. The title is passed to\n     * {@link BluffsGroup#settableTitle} if it's set, or stored in\n     * {@link BluffsGroup#settableTitleTitle} if it isn't.\n     *\n     * @param {String} title\n     *        Title to set.\n     */\n    setTitle(title) {\n\n        const {\n            settableTitle\n        } = this;\n\n        if (settableTitle) {\n            settableTitle.setTitle(title);\n        } else {\n\n            /**\n             * The title that should be set when\n             * {@link BluffsGroup#settableTitle} is created. This property only\n             * exists if {@link BluffsGroup#setTitle} is called before\n             * {@link BluffsGroup#settableTitle} is created and it's removed as\n             * soon as it can be.\n             * @type {String}\n             */\n            this.settableTitleTitle = title;\n\n        }\n\n    }\n\n}\n","import BluffsGroup from \"./BluffsGroup\";\nimport CharacterToken from \"./CharacterToken\";\nimport {\n    deepClone\n} from \"../utils/objects\";\n\n/**\n * The top-down controller for all groups of demon bluffs.\n */\nexport default class BluffsGroups {\n\n    /**\n     * The name of an event that's triggered on each group when they become\n     * visible. We use this to work out {@link BluffsGroups#visibleGroupIndex}.\n     * @type {String}\n     */\n    static get VISIBLE() {\n        return \"bluff-group-visible\";\n    }\n\n    /**\n     * Returns a copy of the empty data.\n     *\n     * @return {Object}\n     *         A copy of the empty data.\n     */\n    static getEmptyData() {\n        return deepClone({ index: 0, groups: [{ set: [] }] });\n    }\n\n    /**\n     * Exposes {@link BluffsGroups.instance}.\n     *\n     * @return {BluffsGroups}\n     *         The singleton instance.\n     */\n    static get() {\n        return this.instance;\n    }\n\n    /**\n     * Helper function for creating a new instance and storing it in\n     * {@link BluffsGroups.instance}.\n     *\n     * @param  {HTMLElement} container\n     *         The element that contains all Demon Bluffs groups.\n     * @return {BluffsGroups}\n     *         Instance.\n     */\n    static create(...args) {\n\n        let bluffs = this.instance;\n\n        if (!bluffs) {\n\n            bluffs = new this(...args);\n\n            /**\n             * An instance that was created using {@link BluffsGroups.create}\n             * and can be accessed using {@link BluffsGroups.get}.\n             * @type {BluffsGroups}\n             */\n            this.instance = bluffs;\n\n        }\n\n        return bluffs;\n\n    }\n\n    /**\n     * Sets up the class.\n     *\n     * @param {HTMLElement} container\n     *        The element that contains all Demon Bluffs groups.\n     */\n    constructor(container) {\n\n        /**\n         * A collection of all the groups of Demon Bluffs.\n         * @type {BluffsGroup[]}\n         */\n        this.groups = [];\n\n        /**\n         * The element that contains all Demon Bluffs elements.\n         * @type {HTMLElement}\n         */\n        this.container = container;\n\n        /**\n         * The index of the group within {@link BluffsGroups#groups} of the\n         * currently visible group.\n         * @type {Number}\n         */\n        this.visibleGroupIndex = 0;\n\n        /**\n         * A flag that allows updates to be announced - if this setting is\n         * `true` then updates are announced, if `false` then they're not.\n         * @type {Boolean}\n         */\n        this.announceUpdates = true;\n\n        /**\n         * An observer that checks to see when a group of Demon Bluffs becomes\n         * visible and triggers an event, which we can listen to in order to set\n         * {@link BluffsGroups#visibleGroupIndex}.\n         * @type {IntersectionObserver}\n         */\n        this.observer = new IntersectionObserver((entries) => {\n\n            entries.forEach(({ target, intersectionRatio }) => {\n\n                if (intersectionRatio >= 0.9) {\n\n                    target.dispatchEvent(\n                        new CustomEvent(this.constructor.VISIBLE, {\n                            bubbles: true,\n                            cancelable: false\n                        })\n                    );\n\n                }\n\n            });\n\n        }, {\n            root: container,\n            threshold: [0.9, 0.95, 1]\n        });\n\n    }\n\n    /**\n     * A function that creates an empty group. This starts as an empty function\n     * to keep the various classes loosely coupled.\n     */\n    createEmptyGroup() {\n        return;\n    }\n\n    /**\n     * Creates an empty group and passes it to {@link BluffsGroups#add}.\n     */\n    addEmpty() {\n        this.add(this.createEmptyGroup());\n    }\n\n    /**\n     * Adds a group to {@link BluffsGroups#groups} and sets it up correctly. If\n     * the group already exists, no action is taken. Since a change has taken\n     * place, the update is announced using\n     * {@link BluffsGroups#maybeAnnounceUpdate}.\n     *\n     * @param  {BluffsGroup} group\n     *         The group to add.\n     * @throws {Error}\n     *         `group` cannot be `null` or `undefined` (which it would be if\n     *         {@link BluffsGroups#createEmptyGroup} hasn't been replaced).\n     */\n    add(group) {\n\n        if (!group) {\n            throw new Error(\"Cannot add a non-existent group\");\n        }\n\n        if (this.has(group)) {\n            return;\n        }\n\n        group.setIndex(this.groups.push(group) - 1);\n        this.container.append(group.draw());\n        group.setElement(this.container.querySelector(group.getSelector()));\n        this.observer.observe(group.getElement());\n        group.ready();\n        this.maybeAnnounceUpdate();\n\n    }\n\n    /**\n     * Checks to see if the given group is within {@link BluffsGroups#groups}.\n     *\n     * @param  {BluffsGroup} group\n     *         Group to check for.\n     * @return {Boolean}\n     *         `true` if the group already exists, `false` otherwise.\n     */\n    has(group) {\n        return this.groups.includes(group);\n    }\n\n    /**\n     * Gets the index of the given group from within\n     * {@link BluffsGroups#groups}.\n     *\n     * @param  {BluffsGroup} group\n     *         Group whose index should be returned.\n     * @return {Number}\n     *         The index of the group or -1 if the group cannot be found.\n     */\n    getIndex(group) {\n        return this.groups.indexOf(group);\n    }\n\n    /**\n     * Removes the given group from {@link BluffsGroups#groups}. This function\n     * works by passing the results of {@link BluffsGroups#getIndex} to\n     * {@link BluffsGroups#removeByIndex}.\n     *\n     * @param {BluffGroup} group\n     *        Group to remove.\n     */\n    remove(group) {\n        this.removeByIndex(this.getIndex(group));\n    }\n\n    /**\n     * Removes the group from {@link BluffsGroups#groups} that's at the given\n     * index. Some validation is done to make sure that the given index is a\n     * number between 0 and the number of groups - no action is taken if the\n     * index fails these tests.\n     *\n     * @param {Number} index\n     *        Index of the group to remove.\n     */\n    removeByIndex(index) {\n\n        const {\n            groups\n        } = this;\n\n        index = Number(index);\n\n        if (index < 0 || index >= groups.length) {\n            return;\n        }\n\n        const group = groups[index];\n\n        this.observer.unobserve(group.getElement());\n        group.remove();\n        groups.splice(index, 1);\n        this.updateIndicies();\n        this.maybeAnnounceUpdate();\n\n    }\n\n    /**\n     * Loops over all the groups within {@link BluffsGroups#groups} and removes\n     * them all. It does this by passing each index to\n     * {@link BluffsGroups#removeByIndex}.\n     */\n    removeAll() {\n\n        const {\n            groups\n        } = this;\n        let {\n            length\n        } = groups;\n\n        while (length) {\n\n            length -= 1;\n            this.removeByIndex(length);\n\n        }\n\n    }\n\n    /**\n     * Updates all the indicies of the groups within {@link BluffsGroups#groups}\n     * so that they match the array itself.\n     */\n    updateIndicies() {\n        this.groups.forEach((group, index) => group.setIndex(index));\n    }\n\n    /**\n     * Exposes {@link BluffsGroups#visibleGroupIndex}.\n     *\n     * @returns {Number}\n     */\n    getVisibleGroupIndex() {\n        return this.visibleGroupIndex;\n    }\n\n    /**\n     * Sets {@link BluffsGroups#visibleGroupIndex}. Some validation is done to\n     * make sure that the given index is a number between 0 and the number of\n     * groups - an error is thrown if this isn't the case. Because this has\n     * updated the data, the update is announced using\n     * {@link BluffsGroups#maybeAnnounceUpdate}.\n     *\n     * @param  {Number} index\n     *         Index of the visible group.\n     * @throws {RangeError}\n     *         `index` must be a number between 0 and the number of groups.\n     */\n    setVisibleGroupIndex(index) {\n\n        index = Number(index);\n\n        if (index < 0 || index > this.groups.length) {\n            throw new RangeError(`Visible index ${index} is out of range`);\n        }\n\n        this.visibleGroupIndex = index;\n        this.maybeAnnounceUpdate();\n\n    }\n\n    /**\n     * Gets the visible group - it does this by getting the item in\n     * {@link BluffsGroups#groups} at {@link BluffsGroups#visibleGroupIndex}. If\n     * a group can't be found at that location, an error is thrown.\n     *\n     * @return {BluffsGroup}\n     *         The currently visible group of Demon Bluffs.\n     * @throws {Error}\n     *         A visible group must exist.\n     */\n    getVisibleGroup() {\n\n        const group = this.groups[this.visibleGroupIndex];\n\n        if (!group) {\n            throw new Error(`Cannot find group at index ${this.visibleGroupIndex}`);\n        }\n\n        return group;\n\n    }\n\n    /**\n     * The inner index is the index of the Demon Bluff within the currently\n     * visible group of Demon Bluffs. This function sets it.\n     *\n     * @param {Number} index\n     *        Inner index to set.\n     */\n    setInnerIndex(index) {\n        this.getVisibleGroup().setSetIndex(index);\n    }\n\n    /**\n     * The inner index is the index of the Demon Bluff within the currently\n     * visible group of Demon Bluffs. This function gets it.\n     *\n     * @return {Number}\n     *         Inner index.\n     */\n    getInnerIndex() {\n        return this.getVisibleGroup().getSetIndex();\n    }\n\n    /**\n     * Sets the character for the Demon Bluff of the currently visible group of\n     * bluffs. Because a change will have happened, the update is announced\n     * using {@link BluffsGroups#maybeAnnounceUpdate}.\n     *\n     * @param {CharacterToken} character\n     *        The character to set.\n     */\n    setCharacter(character) {\n\n        this.getVisibleGroup().setCharacter(character);\n        this.maybeAnnounceUpdate();\n\n    }\n\n    /**\n     * Redraws the currently visible group of demon bluffs, updating the buttons\n     * to reflect the current state.\n     */\n    redraw() {\n        this.getVisibleGroup().redrawButton();\n    }\n\n    /**\n     * Gets an object reflecting the current state of the demon bluffs. It does\n     * this by calling {@link BluffsGroup#serialise} on all groups within\n     * {@link BluffsGroups#groups}.\n     *\n     * @returns {Object}\n     *          Serialised state of the Demon Bluffs.\n     */\n    serialise() {\n\n        return {\n            index: this.visibleGroupIndex,\n            groups: this.groups.map((group) => group.serialise())\n        };\n\n    }\n\n    /**\n     * Disables the update announcements.\n     */\n    disableAnnouncements() {\n        this.announceUpdates = false;\n    }\n\n    /**\n     * Enables the update announcements.\n     */\n    enableAnnouncements() {\n        this.announceUpdates = true;\n    }\n\n    /**\n     * Checks {@link BluffsGroups.announceUpdates} to see if updates should be\n     * announced, doing nothing if they shouldn't.\n     */\n    maybeAnnounceUpdate() {\n\n        if (!this.announceUpdates) {\n            return;\n        }\n\n        this.announceUpdate();\n\n    }\n\n    /**\n     * A function that executes when an update should be announced. This is done\n     * to keep the classes loosely coupled.\n     */\n    announceUpdate() {\n        return;\n    }\n\n    /**\n     * Takes the character ID and converts it into a {@link CharacterToken}.\n     * This function starts as an empty function so that it can be replaced and\n     * still keep the classes loosely coupled.\n     *\n     * @param  {String} id\n     *         The ID of the character whose token should be returned.\n     * @return {CharacterToken}\n     *         The character token instance for the given ID.\n     */\n    convertId(id) {\n        return;\n    }\n\n    /**\n     * A function that executes when the class is ready, creating the groups\n     * defined in {@link BluffsGroups.readyData}.\n     */\n    ready({ index, groups }) {\n\n        this.removeAll();\n\n        groups.forEach(({ name, set }) => {\n\n            const group = this.createEmptyGroup();\n\n            if (!group) {\n                throw new Error(\"Cannot create an empty group\");\n            }\n\n            group.setTitle(name);\n            set.forEach((id, index) => {\n                group.setCharacter(this.convertId(id), index);\n            });\n\n            this.add(group);\n\n        });\n\n        this.setVisibleGroupIndex(index);\n        this.getVisibleGroup().display();\n\n    }\n\n}\n","import Template from \"../../classes/Template.js\";\nimport TokenStore from \"../../classes/TokenStore.js\";\nimport Observer from \"../../classes/Observer.js\";\nimport Dialog from \"../../classes/Dialog.js\";\nimport BluffDialog from \"../../classes/BluffDialog.js\";\nimport TokenDialog from \"../../classes/TokenDialog.js\";\nimport BluffsGroups from \"../../classes/BluffsGroups.js\";\nimport BluffsGroup from \"../../classes/BluffsGroup.js\";\nimport BluffSet from \"../../classes/BluffSet.js\";\nimport SettableTitle from \"../../classes/SettableTitle.js\";\nimport {\n    lookup,\n    lookupOne,\n    lookupOneCached,\n    replaceContentsMany\n} from \"../../utils/elements.js\";\n\nconst gameObserver = Observer.create(\"game\");\nconst tokenObserver = Observer.create(\"token\");\nconst tokenDialog = TokenDialog.get();\nconst bluffDialog = BluffDialog.create(lookupOne(\"#bluff-show\"));\n\nBluffsGroup.setTemplate(Template.create(lookupOne(\"#demon-bluffs-template\")));\n\nTokenStore.ready((tokenStore) => {\n\n    BluffSet.setEmptyCharacter(tokenStore.getEmptyCharacter());\n\n    const bluffGroupsContainer = lookupOne(\"#demon-bluffs-group\");\n    const bluffGroups = BluffsGroups.create(bluffGroupsContainer);\n    bluffGroups.createEmptyGroup = () => new BluffsGroup(new BluffSet());\n    bluffGroups.convertId = (id) => tokenStore.getCharacter(id);\n    bluffGroups.announceUpdate = () => {\n\n        tokenObserver.trigger(\"bluff\", {\n            data: bluffGroups.serialise()\n        });\n\n    };\n\n    bluffGroupsContainer.addEventListener(\"click\", ({ target }) => {\n\n        const button = target.closest(\".js--demon-bluffs--remove\");\n        const group = button?.closest(\".js--demon-bluffs--group\");\n\n        if (!button || !group) {\n            return;\n        }\n\n        bluffGroups.removeByIndex(group.dataset.groupId);\n\n    });\n\n    bluffGroupsContainer.addEventListener(\"click\", ({ target }) => {\n\n        const button = target.closest(\".js--demon-bluffs--bluff[data-index]\");\n\n        if (!button) {\n            return;\n        }\n\n        bluffGroups.setInnerIndex(button.dataset.index);\n        bluffDialog.display(\n            bluffGroups.getVisibleGroup().getCharacter(),\n            button.classList.contains(\"is-orphan\")\n        );\n\n    });\n\n    bluffGroupsContainer.addEventListener(BluffsGroups.VISIBLE, ({ target }) => {\n        bluffGroups.setVisibleGroupIndex(target.dataset.groupId);\n    });\n\n    bluffGroupsContainer.addEventListener(BluffsGroup.READY, ({ detail }) => {\n\n        const {\n            bluffGroup\n        } = detail;\n        const element = bluffGroup.getElement();\n\n        lookup(\"[data-bluff-dialog]\", element).forEach((trigger) => {\n            trigger.dialog = BluffDialog.createFromTrigger(trigger);\n        });\n\n        const settableTitle = new SettableTitle(\n            element.querySelector(\".js--settable-title--title\"),\n            element.querySelector(\".js--settable-title--input\")\n        );\n        settableTitle.announceUpdate = () => bluffGroups.announceUpdate();\n        bluffGroup.setSettableTitle(settableTitle);\n\n    });\n\n    bluffGroups.disableAnnouncements();\n    bluffGroups.ready(BluffsGroups.getEmptyData());\n    bluffGroups.enableAnnouncements();\n\n    lookupOne(\"#add-bluffs\").addEventListener(\"click\", () => {\n        bluffGroups.addEmpty();\n    });\n\n    gameObserver.on(\"characters-selected\", ({ detail }) => {\n\n        const characterTemplate = Template.create(\n            lookupOneCached(\"#character-list-template\")\n        );\n        const characters = [\n            tokenStore.characters[TokenStore.EMPTY],\n            ...detail.characters\n        ];\n\n        replaceContentsMany(\n            lookupOneCached(\"#character-list__bluffs\"),\n            characters.map((character) => characterTemplate.draw({\n                \".js--character-list--item\"(element) {\n\n                    element.dataset.characterId = character.getId();\n                    element.dataset.team = character.getTeam();\n\n                },\n                \".js--character-list--button\"(element) {\n                    element.dataset.tokenId = character.getId();\n                },\n                \".js--character-list--token\"(element) {\n                    element.append(character.drawToken());\n                }\n            }))\n        );\n\n    });\n\n    // Show all possible bluffs dialog.\n\n    function toggleBluffListClass(className, state) {\n\n        lookupOneCached(\"#character-list__bluffs\")\n            .classList\n            .toggle(className, state);\n\n    }\n\n    lookupOne(\"#show-existing\").addEventListener(\"change\", ({ target }) => {\n        toggleBluffListClass(\"is-show-existing\", target.checked);\n    });\n\n    lookupOne(\"#show-travellers\").addEventListener(\"change\", ({ target }) => {\n        toggleBluffListClass(\"is-show-travellers\", target.checked);\n    });\n\n    lookupOne(\"#show-evil\").addEventListener(\"change\", ({ target }) => {\n        toggleBluffListClass(\"is-show-evil\", target.checked);\n    });\n\n    const rolesInPlay = Object.create(null);\n\n    tokenObserver.on(\"character-add\", ({ detail }) => {\n\n        const id = detail.character.getId();\n\n        if (!rolesInPlay[id]) {\n            rolesInPlay[id] = 0;\n        }\n\n        rolesInPlay[id] += 1;\n\n    });\n\n    tokenObserver.on(\"character-remove\", ({ detail }) => {\n\n        const id = detail.character.getId();\n\n        if (rolesInPlay[id]) {\n            rolesInPlay[id] -= 1;\n        }\n\n        if (!rolesInPlay[id] || rolesInPlay[id] < 0) {\n            delete rolesInPlay[id];\n        }\n\n    });\n\n    const bluffListDialog = Dialog.create(lookupOne(\"#bluff-list\"));\n\n    bluffListDialog.on(Dialog.SHOW, () => {\n\n        Object\n            .keys(rolesInPlay)\n            .concat(bluffGroups.getVisibleGroup().serialise().set)\n            .filter(Boolean) // remove any empty IDs\n            .forEach((id) => {\n\n                const token = lookupOne(\n                    `#character-list__bluffs [data-character-id=\"${id}\"]`\n                );\n                token?.classList.add(\"is-in-play\");\n\n            });\n\n    });\n\n    bluffListDialog.on(Dialog.HIDE, () => {\n\n        lookup(\"#character-list__bluffs .is-in-play\").forEach((token) => {\n            token.classList.remove(\"is-in-play\");\n        });\n\n    });\n\n    lookupOne(\"#character-list__bluffs\").addEventListener(\"click\", ({ target }) => {\n\n        const button = target.closest(\"[data-token-id]\")\n\n        if (!button) {\n            return;\n        }\n\n        // assign the chosen character to the correct set\n        const character = tokenStore.getCharacter(button.dataset.tokenId);\n        bluffGroups.setCharacter(character);\n        bluffGroups.redraw();\n        // close the dialog\n        bluffListDialog.hide();\n        bluffDialog.hide();\n\n    });\n\n    // Bluff token dialog.\n\n    lookupOneCached(\n        \"#bluff-show-token\",\n        bluffDialog.getElement()\n    ).addEventListener(\"click\", ({ target }) => {\n\n        const id = target.closest(\"[data-character-id]\")?.dataset.characterId;\n\n        if (!id) {\n            return;\n        }\n\n        tokenDialog.setIds([id]);\n        tokenDialog.show();\n        bluffDialog.hide();\n\n    });\n\n    lookupOneCached(\"#show-all-bluffs\").addEventListener(\"click\", ({ target }) => {\n\n        tokenDialog.setIds(bluffGroups.getVisibleGroup().serialise().set);\n        tokenDialog.setMultipleTitle(target.dataset.title);\n        tokenDialog.show();\n\n    });\n\n    gameObserver.on(\"clear\", () => {\n\n        bluffGroups.removeAll();\n        bluffGroups.addEmpty();\n\n    });\n\n    // #131 - highlight any orphan characters.\n    gameObserver.on(\"characters-selected\", ({ detail }) => {\n\n        TokenStore.ready(() => {\n\n            const group = bluffGroups.getVisibleGroup();\n\n            group\n                .element\n                .querySelectorAll(\".js--demon-bluffs--bluff\")\n                .forEach((button) => {\n\n                    const index = button.dataset.index;\n                    const character = group.bluffSet.characters[index];\n\n                    if (character.getId() === BluffSet.emptyCharacter.getId()) {\n                        return;\n                    }\n\n                    const charIndex = detail.characters.findIndex((char) => {\n                        return char.getId() === character.getId();\n                    });\n                    button.classList.toggle(\"is-orphan\", charIndex < 0);\n\n                });\n\n        });\n\n    });\n\n});\n","import Observer from \"../../classes/Observer.js\";\nimport {\n    lookupOne,\n    lookupOneCached\n} from \"../../utils/elements.js\";\n\nconst gameObserver = Observer.create(\"game\");\n\nlookupOne(\"#reset-height\").addEventListener(\"click\", () => {\n    lookupOneCached(\".js--pad\").style.height = \"\";\n});\n\nlookupOne(\"#clear-grimoire\").addEventListener(\"click\", ({ target }) => {\n\n    if (window.confirm(target.dataset.confirm)) {\n        gameObserver.trigger(\"clear\");\n    }\n\n});\n","import Observer from \"../../classes/Observer.js\";\nimport Template from \"../../classes/Template.js\";\nimport Dialog from \"../../classes/Dialog.js\";\nimport TokenStore from \"../../classes/TokenStore.js\";\nimport {\n    lookup,\n    lookupOne,\n    lookupOneCached,\n    replaceContentsMany\n} from \"../../utils/elements.js\";\nimport {\n    empty\n} from \"../../utils/objects.js\";\n\nconst gameObserver = Observer.create(\"game\");\nconst tokenObserver = Observer.create(\"token\");\n\n// Include all the Travellers in the traveller list.\n\nconst officialTravellers = Object.create(null);\nconst homebrewTravellers = Object.create(null);\nlet characterTemplate = null;\n\nfunction populateTravellers() {\n\n    const travellers = Object.values({\n        ...officialTravellers,\n        ...homebrewTravellers\n    });\n\n    if (!characterTemplate) {\n\n        characterTemplate = Template.create(\n            lookupOneCached(\"#character-list-template\")\n        );\n\n    }\n\n    replaceContentsMany(\n        lookupOneCached(\"#traveller-list__list\"),\n        travellers.map((traveller) => characterTemplate.draw({\n            \".js--character-list--item,.js--character-list--button\"(element) {\n                element.dataset.tokenId = traveller.getId();\n            },\n            \".js--character-list--token\"(element) {\n                element.append(traveller.drawToken());\n            }\n        }))\n    );\n\n    lookupOneCached(\"#add-traveller\").disabled = false;\n\n}\n\nTokenStore.ready((tokenStore) => {\n\n    empty(officialTravellers);\n\n    tokenStore\n        .getAllCharacters()\n        .filter((character) => character.getTeam() === \"traveller\")\n        .forEach((traveller) => officialTravellers[traveller.getId()] = traveller);\n\n    populateTravellers();\n\n});\n\ngameObserver.on(\"characters-selected\", ({ detail }) => {\n\n    // Add any homebrew characters to the list.\n\n    empty(homebrewTravellers);\n\n    detail.characters\n        .filter((character) => character.getTeam() === \"traveller\")\n        .forEach((traveller) => homebrewTravellers[traveller.getId()] = traveller);\n\n    populateTravellers();\n\n    // Flag Travellers in the script as being included. For example, the main 3\n    // editions have Travellers that complement the script. Homebrew scripts\n    // maight have their own Travellers as well.\n\n    const travellerIDs = detail.characters\n        .filter((character) => character.getTeam() === \"traveller\")\n        .map((character) => character.getId());\n\n    lookup(\n        \".js--character-list--item[data-token-id]\",\n        lookupOneCached(\"#traveller-list__list\")\n    ).forEach((item) => item.classList.toggle(\n        \"is-included\",\n        travellerIDs.includes(item.dataset.tokenId)\n    ));\n\n});\n\n// Add to the grimoire when clicked.\n\nconst pad = lookupOneCached(\".js--pad\").pad;\n\nlookupOneCached(\"#traveller-list__list\").addEventListener(\"click\", ({ target }) => {\n\n    const button = target.closest(\"[data-token-id]\");\n\n    if (!button) {\n        return;\n    }\n\n    TokenStore.ready((tokenStore) => {\n\n        pad.addCharacter(tokenStore.getCharacter(button.dataset.tokenId));\n        Dialog.create(lookupOneCached(\"#traveller-list\")).hide();\n\n    });\n\n});\n\n// Night Order.\n// #155 - Let the NightOrder class manage the night order.\n\nconst travellerCount = Object.create(null);\n\ntokenObserver.on(\"character-add\", ({ detail }) => {\n\n    const character = detail.character;\n\n    if (character.getTeam() !== \"traveller\") {\n        return;\n    }\n\n    const id = character.getId();\n\n    if (!travellerCount[id]) {\n        travellerCount[id] = 0;\n    }\n\n    travellerCount[id] += 1;\n\n});\n\ntokenObserver.on(\"character-remove\", ({ detail }) => {\n\n    const character = detail.character;\n\n    if (character.getTeam() !== \"traveller\") {\n        return;\n    }\n\n    const id = character.getId();\n\n    if (travellerCount[id]) {\n        travellerCount[id] -= 1;\n    }\n\n});\n\n// Reminder tokens.\n\ntokenObserver.on(\"character-add\", ({ detail }) => {\n\n    const character = detail.character;\n\n    if (character.getTeam() !== \"traveller\") {\n        return;\n    }\n\n    character.getReminders().forEach((reminder) => {\n        lookupOneCached(\"#reminder-list__list\").append(reminder.drawList());\n    });\n\n});\n\ntokenObserver.on(\"character-remove\", ({ detail }) => {\n\n    const character = detail.character;\n    const count = travellerCount[character.getId()];\n\n    if (character.getTeam() !== \"traveller\" || count) {\n        return;\n    }\n\n    character.getReminders().forEach((reminder) => {\n\n        lookupOne(\n            `[data-reminder-id=\"${reminder.getId()}\"]`,\n            lookupOneCached(\"#reminder-list__list\")\n        )?.remove();\n\n    });\n\n});\n","import Observer from \"../../classes/Observer.js\";\nimport TokenStore from \"../../classes/TokenStore.js\";\nimport Dialog from \"../../classes/Dialog.js\";\nimport Template from \"../../classes/Template.js\";\nimport {\n    lookup,\n    lookupOne,\n    lookupOneCached,\n    replaceContentsMany\n} from \"../../utils/elements.js\";\nimport {\n    empty\n} from \"../../utils/objects.js\";\n\nconst gameObserver = Observer.create(\"game\");\nconst tokenObserver = Observer.create(\"token\");\n\n\n// Include all the Fabled in the fabled list.\n\nconst homebrewFabled = Object.create(null);\nconst officialFabled = Object.create(null);\nlet characterTemplate = null;\n\nfunction populateFabled() {\n\n    const fabled = Object.values({...officialFabled, ...homebrewFabled});\n\n    if (!characterTemplate) {\n\n        characterTemplate = Template.create(\n            lookupOneCached(\"#character-list-template\")\n        );\n\n    }\n\n    replaceContentsMany(\n        lookupOneCached(\"#fabled-list__list\"),\n        fabled.map((fable) => characterTemplate.draw({\n            \".js--character-list--item,.js--character-list--button\"(element) {\n                element.dataset.tokenId = fable.getId();\n            },\n            \".js--character-list--token\"(element) {\n                element.append(fable.drawToken());\n            }\n        }))\n    );\n\n    lookupOneCached(\"#add-fabled\").disabled = false;\n\n}\n\ngameObserver.on(\"characters-selected\", ({ detail }) => {\n\n    empty(homebrewFabled);\n\n    detail.characters\n        .filter((character) => character.getTeam() === \"fabled\")\n        .forEach((character) => homebrewFabled[character.getId()] = character);\n\n    populateFabled();\n\n});\n\nTokenStore.ready((tokenStore) => {\n\n    empty(officialFabled);\n\n    tokenStore\n        .getAllCharacters()\n        .filter((character) => character.getTeam() === \"fabled\")\n        .forEach((character) => officialFabled[character.getId()] = character);\n\n    populateFabled();\n\n});\n\n// Add to the grimoire when clicked.\n\nconst pad = lookupOneCached(\".js--pad\").pad;\n\nlookupOneCached(\"#fabled-list__list\").addEventListener(\"click\", ({ target }) => {\n\n    const button = target.closest(\"[data-token-id]\");\n\n    if (!button) {\n        return;\n    }\n\n    TokenStore.ready((tokenStore) => {\n\n        pad.addCharacter(tokenStore.getCharacter(button.dataset.tokenId));\n        Dialog.create(lookupOneCached(\"#fabled-list\")).hide();\n\n    });\n\n});\n\n// Night Order.\n// #155 - Let the NightOrder class manage the night order.\n\nconst fabledCount = Object.create(null);\n\ntokenObserver.on(\"character-add\", ({ detail }) => {\n\n    const character = detail.character;\n\n    if (character.getTeam() !== \"fabled\") {\n        return;\n    }\n\n    const id = character.getId();\n\n    if (!fabledCount[id]) {\n        fabledCount[id] = 0;\n    }\n\n    fabledCount[id] += 1;\n\n});\n\ntokenObserver.on(\"character-remove\", ({ detail }) => {\n\n    const character = detail.character;\n\n    if (character.getTeam() !== \"fabled\") {\n        return;\n    }\n\n    const id = character.getId();\n\n    if (fabledCount[id]) {\n        fabledCount[id] -= 1;\n    }\n\n});\n\n// Reminder tokens.\n\ntokenObserver.on(\"character-add\", ({ detail }) => {\n\n    const character = detail.character;\n\n    if (character.getTeam() !== \"fabled\") {\n        return;\n    }\n\n    character.getReminders().forEach((reminder) => {\n        lookupOneCached(\"#reminder-list__list\").append(reminder.drawList());\n    });\n\n});\n\ntokenObserver.on(\"character-remove\", ({ detail }) => {\n\n    const character = detail.character;\n    const count = fabledCount[character.getId()];\n\n    if (character.getTeam() !== \"fabled\" || count) {\n        return;\n    }\n\n    character.getReminders().forEach((reminder) => {\n\n        lookupOne(\n            `[data-reminder-id=\"${reminder.getId()}\"]`,\n            lookupOneCached(\"#reminder-list__list\")\n        )?.remove();\n\n    });\n\n});\n","import Store from \"../../classes/Store.js\";\nimport Dialog from \"../../classes/Dialog.js\";\nimport {\n    lookupOne,\n} from \"../../utils/elements.js\";\nimport {\n    empty,\n} from \"../../utils/objects.js\";\n\nconst gameData = Object.create(null);\n\nStore.create(\"pocket-grimoire\").addListener(({ detail }) => {\n\n    empty(gameData);\n    Object.assign(gameData, {\n        script: detail.characters.name,\n        date: (new Date()).toISOString(),\n        day: 1,\n        players: detail.tokens.map((token) => {\n\n            return {\n                tokens: [],\n                name: token.playerName,\n                me: false,\n                dead: token.isDead,\n                id: window.crypto.randomUUID(),\n                suspectedRole: {\n                    id: token.id\n                }\n            };\n\n        })\n    });\n\n});\n\nconst trigger = lookupOne(\"#export-trigger\");\nconst holder = lookupOne(\"#export-holder\");\nconst image = lookupOne(\"#export-image\");\n\ntrigger.addEventListener(\"click\", () => {\n\n    trigger.classList.add(\"is-loading\");\n\n    fetch(\"https://qr-thing.netlify.app/.netlify/functions/qr\", {\n            method: \"POST\",\n            headers: {\n                \"Content-Type\": \"application/json\",\n            },\n            body: JSON.stringify(gameData),\n        })\n        .then((response) => response.json())\n        .then((json) => {\n\n            image.src = json.qr;\n            trigger.classList.remove(\"is-loading\");\n            holder.hidden = false;\n\n        });\n\n});\n\nconst dialog = Dialog.create(lookupOne(\"#game-export\"));\n\ndialog.on(Dialog.HIDE, () => {\n    holder.hidden = true;\n    trigger.classList.remove(\"is-loading\");\n});\n","import Observer from \"../classes/Observer.js\";\nimport TokenStore from \"../classes/TokenStore.js\";\nimport Template from \"../classes/Template.js\";\nimport Jinx from \"../classes/Jinx.js\";\nimport {\n    lookupOne,\n    replaceContentsMany\n} from \"../utils/elements.js\";\n\nconst gameObserver = Observer.create(\"game\");\nconst tokenObserver = Observer.create(\"token\");\n\nTokenStore.ready((tokenStore) => {\n\n    const trickToTarget = Object.create(null);\n    const jinxTemplate = Template.create(lookupOne(\"#jinx-table-template\"));\n\n    /**\n     * Registers a jinx in the {@link trickToTarget} map.\n     *\n     * @param {Jinx} jinx\n     *        Jinx to register.\n     */\n    function registerJinx(jinx) {\n\n        const trickId = jinx.getTrick()?.getId();\n\n        if (!trickId) {\n            return;\n        }\n\n        if (!trickToTarget[trickId]) {\n            trickToTarget[trickId] = [];\n        }\n\n        trickToTarget[trickId].push(jinx.getTarget().getId());\n\n    }\n\n    /**\n     * Removes a jinx from the {@link trickToTarget} map, keeping it tidy and\n     * preventing old data from creating false positives.\n     *\n     * @param {Jinx} jinx\n     *        Jinx to unregister.\n     */\n    function unregisterJinx(jinx) {\n\n        const trickId = jinx.getTrick()?.getId();\n\n        if (!trickId || !trickToTarget[trickId]) {\n            return;\n        }\n\n        const index = trickToTarget[trickId].indexOf(jinx.getTarget().getId());\n\n        if (index < 0) {\n            return;\n        }\n\n        trickToTarget[trickId].splice(index, 1);\n\n        if (!trickToTarget[trickId].length) {\n            delete trickToTarget[trickId];\n        }\n\n    }\n\n    /**\n     * Activates the given Jinx, setting the observer and template, and\n     * registering it.\n     *\n     * @param {Jinx} jinx\n     *        Jinx to activate.\n     */\n    function activateJinx(jinx) {\n\n        jinx.setObserver(tokenObserver);\n        jinx.setTemplate(jinxTemplate);\n        registerJinx(jinx);\n\n    }\n\n    tokenStore.getAllJinxes().forEach(activateJinx);\n\n    // Unready any old jinxes and ready any jinxes on the current script.\n    gameObserver.on(\"characters-selected\", ({ detail }) => {\n\n        tokenStore.getAllJinxes().forEach((jinx) => jinx.toggleReady(false));\n        tokenStore.getAllHomebrewJinxes().forEach(unregisterJinx);\n        tokenStore.removeAllHomebrewJinxes();\n\n        const {\n            characters\n        } = detail;\n\n        characters.forEach((character) => {\n\n            // A character will only have \"jinxes\" data if it's a homebrew role\n            // that includes jinxes. When that happens - create Jinx instances\n            // for them, add them to the character, and register them in the\n            // store so that they can interact with the system.\n            if (character.hasData(\"jinxes\")) {\n\n                character.getData(\"jinxes\").forEach(({ id, reason }) => {\n\n                    // Get the trick from the token store or the characters\n                    // that have been passed in - this allows one homebrew\n                    // character to be jinxed with another.\n                    const trick = (\n                        tokenStore.getCharacter(id)\n                        || characters.find((character) => {\n                            return character.getId() === id;\n                        })\n                    );\n                    const jinx = new Jinx(trick, reason);\n                    jinx.setIsHomebrew(true);\n                    character.addJinx(jinx);\n                    activateJinx(jinx);\n                    tokenStore.addJinx(jinx);\n\n                });\n\n            }\n\n            character.readyAllJinxes(characters);\n\n        });\n\n        const allJinxes = tokenStore.getAllJinxes();\n\n        gameObserver.trigger(\"jinxes-ready\", {\n            jinxes: allJinxes.filter((jinx) => jinx.isReady())\n        });\n\n    });\n\n    // Toggle jinx states based on characters being selected or unselected.\n    gameObserver.on(\"character-toggle\", ({ detail }) => {\n\n        const {\n            id,\n            active\n        } = detail;\n\n        const character = tokenStore.getCharacter(id);\n\n        character.toggleJinxTarget(active);\n\n        trickToTarget[id]?.forEach((targetId) => {\n\n            tokenStore\n                .getCharacter(targetId)\n                .toggleJinxTrick(character, active);\n\n        });\n\n    });\n\n    // Draw all ready jinxes.\n    const jinxSection = lookupOne(\"#jinxes\");\n    const jinxTable = lookupOne(\"#jinx-table\");\n\n    gameObserver.on(\"jinxes-ready\", ({ detail }) => {\n\n        const {\n            jinxes\n        } = detail;\n\n        jinxSection.hidden = jinxes.length === 0;\n\n        replaceContentsMany(\n            jinxTable,\n            jinxes.map((jinx) => jinx.draw())\n        );\n\n    });\n\n    tokenObserver.on(\"toggle-jinx-active\", ({ detail }) => {\n\n        const {\n            jinx,\n            active\n        } = detail;\n\n        lookupOne(`#${jinx.getId()}`)?.classList.toggle(\"is-active\", active);\n\n    });\n\n    // Activate and deactivate the jinxes as characters are added to the\n    // grimoire pad.\n    const characters = [];\n\n    function addCharacter(character) {\n\n        const jinxes = Object.create(null);\n\n        character.getJinxes().forEach((jinx) => {\n\n            jinx.toggleTarget(true);\n            jinxes[jinx.getTrick().getId()] = jinx;\n\n        });\n        characters.forEach((char) => {\n\n            char.toggleJinxTrick(character, true);\n            jinxes[char.getId()]?.toggleTrick(true);\n\n        });\n        characters.push(character);\n\n    }\n\n    function removeCharacter(character) {\n\n        const id = character.getId();\n\n        characters.splice(characters.indexOf(character), 1);\n\n        if (!characters.find((char) => char.getId() === id)) {\n\n            character.getJinxes().forEach((jinx) => jinx.toggleTarget(false));\n            characters.forEach((char) => char.toggleJinxTrick(character, false));\n\n        }\n\n    }\n\n    tokenObserver.on(\"character-add\", ({ detail }) => {\n        addCharacter(detail.character);\n    });\n\n    tokenObserver.on(\"character-remove\", ({ detail }) => {\n        removeCharacter(detail.character);\n    });\n\n    // #128 - some reminders stand in place of the actual token.\n    tokenObserver.on(\"reminder-add\", ({ detail }) => {\n\n        const {\n            reminder\n        } = detail;\n        const character = tokenStore.getCharacter(reminder.getCharacterId());\n\n        if (\n            reminder.getIsGlobal()\n            && reminder.getId().endsWith(\":0\")\n            && character.hasSpecialData(\"reveal\", \"replace-character\")\n        ) {\n            addCharacter(character);\n        }\n\n    });\n\n    // #128 - some reminders stand in place of the actual token.\n    tokenObserver.on(\"reminder-remove\", ({ detail }) => {\n\n        const {\n            reminder\n        } = detail;\n        const character = tokenStore.getCharacter(reminder.getCharacterId());\n\n        if (\n            reminder.getIsGlobal()\n            && reminder.getId().endsWith(\":0\")\n            && character.hasSpecialData(\"reveal\", \"replace-character\")\n        ) {\n            removeCharacter(character);\n        }\n\n    });\n\n    // Allow all Jinxes to be shown based on user preference.\n    lookupOne(\"#show-all-jinxes\").addEventListener(\"change\", ({ target }) => {\n        jinxTable.classList.toggle(\"is-show-all\", target.checked);\n    });\n\n});\n","import CharacterToken from \"./CharacterToken\";\nimport {\n    empty\n} from \"../utils/elements.js\";\n\n/**\n * A class that manages the night order lists.\n */\nexport default class NightOrder {\n\n    constructor() {\n\n        /**\n         * Whether or not to show the dead characters.\n         * @type {Boolean}\n         */\n        this.showDead = false;\n\n        /**\n         * Whether or not to show the characters that are current not in play.\n         * @type {Boolean}\n         */\n        this.showNotInPlay = false;\n\n        /**\n         * The data that will display the night order lists.\n         * @type {Array.<Object>}\n         */\n        this.data = [];\n\n        /**\n         * Holders for the night order elements.\n         */\n        this.holders = {\n            first: null,\n            other: null,\n        }\n\n    }\n\n    /**\n     * Sets the holders.\n     * @param {Object} holders\n     */\n    setHolders(holders) {\n        this.holders = holders;\n    }\n\n    /**\n     * Resets the lists so that the elements have been removed and the data\n     * cleared.\n     */\n    reset() {\n\n        const {\n            data,\n        } = this;\n\n        data.forEach(({ first, other }) => {\n\n            if (first) {\n\n                first.placeholder.remove();\n                first.element.remove();\n\n            }\n\n            if (other) {\n\n                other.placeholder.remove();\n                other.element.remove();\n\n            }\n\n        });\n\n        data.length = 0;\n\n    }\n\n    /**\n     * Updates {@link NightOrder#showDead}.\n     *\n     * @param {Boolean} showDead\n     *        true to show the dead characters, false to hide them.\n     */\n    setShowDead(showDead) {\n\n        this.showDead = showDead;\n        this.drawAllCharacters();\n\n    }\n\n    /**\n     * Updates {@link NightOrder#showNotInPlay}.\n     *\n     * @param {Boolean} showNotInPlay\n     *        true to show the not-in-play characters, false to hide them.\n     */\n    setShowNotInPlay(showNotInPlay) {\n\n        this.showNotInPlay = showNotInPlay;\n        this.drawAllCharacters();\n\n    }\n\n    /**\n     * Sets the characters that are in the lists.\n     *\n     * @param {Array.<CharacterToken>} characters\n     *        All characters to set.\n     */\n    setCharacters(characters) {\n        characters.forEach((character) => this.setCharacter(character));\n    }\n\n    /**\n     * Sets an individual character, adding it to the list.\n     *\n     * @param {CharacterToken} character\n     *        The character to set.\n     */\n    setCharacter(character) {\n\n        const data = {\n            character,\n            alive: 0,\n            inPlay: 0,\n        };\n        const firstNight = character.getFirstNight();\n        const otherNight = character.getOtherNight();\n        const id = character.getId();\n\n        if (firstNight) {\n\n            data.first = {\n                order: firstNight,\n                placeholder: document.createComment(id),\n                element: character.drawNightOrder(true).firstElementChild,\n            };\n\n        }\n\n        if (otherNight) {\n\n            data.other = {\n                order: otherNight,\n                placeholder: document.createComment(id),\n                element: character.drawNightOrder(false).firstElementChild,\n            };\n\n        }\n\n        this.data.push(data);\n\n    }\n\n    /**\n     * Place the characters element/placeholder in the correct place in the\n     * appropriate night order list.\n     * This is only needed after adding a character using\n     * {@link NightOrder#setCharacter} manually - the order for all regular\n     * characters in the script should be correctly set in\n     * {@link NightOrder#drawNightOrder}.\n     *\n     * @param {CharacterToken} character\n     *        The character to correctly place.\n     */\n    placeInOrder(character) {\n\n        const index = this.getDataIndex(character);\n\n        if (index < 0) {\n            return;\n        }\n\n        [\n            [\"first\", \"getFirstNight\"],\n            [\"other\", \"getOtherNight\"]\n        ].forEach(([property, method]) => {\n\n            const data = this.data[index][property];\n\n            if (!data) {\n                return;\n            }\n\n            const next = this.data\n                .filter((datum) => datum[property])\n                .sort((a, b) => a[property].order - b[property].order)\n                .find(({ order }) => order > character[method]());\n            const insertable = (\n                this.shouldShow(data)\n                ? data.element\n                : data.placeholder\n            );\n\n            if (next) {\n\n                this.holders[property].insertBefore(\n                    insertable,\n                    (\n                        next.element.parentElement\n                        ? next.element\n                        : next.placeholder\n                    )\n                );\n\n            } else {\n                this.holders[property].append(insertable);\n            }\n\n        });\n\n    }\n\n    /**\n     * Removes the given character from the data and removes all its elements\n     * from the night order lists.\n     *\n     * @param {CharacterToken} character\n     *        The character to remove.\n     */\n    unsetCharacter(character) {\n\n        const index = this.getDataIndex(character);\n\n        if (index < 0) {\n            return;\n        }\n\n        [\"first\", \"other\"].forEach((property) => {\n\n            const data = this.data[index][property];\n\n            if (!data) {\n                return;\n            }\n\n            data.placeholder.remove();\n            data.element.remove();\n\n        });\n\n        this.data.splice(index, 1);\n\n    }\n\n    /**\n     * Draws the night order list for either the first night or the other\n     * nights.\n     *\n     * @param  {Boolean} isFirstNight\n     *         true to draw the first night, false to draw the other nights.\n     * @return {DocumentFragment}\n     *         A document fragment with the night order list.\n     */\n    drawNightOrder(isFirstNight) {\n\n        const {\n            data,\n        } = this;\n        const property = (\n            isFirstNight\n            ? \"first\"\n            : \"other\"\n        );\n\n        return data\n            .filter((datum) => datum[property])\n            .sort((a, b) => a[property].order - b[property].order)\n            .reduce((fragment, data) => {\n\n                const {\n                    element,\n                    placeholder,\n                } = data[property];\n\n                fragment.append(\n                    this.shouldShow(data)\n                    ? element\n                    : placeholder\n                );\n\n                return fragment;\n\n            }, document.createDocumentFragment());\n\n\n    }\n\n    /**\n     * Draws all night order elements.\n     */\n    drawAllNightOrders() {\n\n        Object.entries(this.holders).forEach(([name, element]) => {\n\n            if (!element) {\n                return;\n            }\n\n            empty(element).append(this.drawNightOrder(name === \"first\"));\n\n        });\n\n    }\n\n    /**\n     * Helper function for drawing or updating a character's entry in the night\n     * order lists based on the character itself.\n     *\n     * @param {CharacterToken} character\n     *        Character whose entry should be drawn or updated.\n     */\n    drawCharacter(character) {\n        this.drawCharacterByData(this.getData(character));\n    }\n\n    /**\n     * Draws or updates the entry in the night order lists for the character\n     * with the given data.\n     *\n     * @param {Object} data\n     *        Data whose character should have their night order lists updated.\n     */\n    drawCharacterByData(data) {\n\n        const shouldShow = this.shouldShow(data);\n\n        [\"first\", \"other\"].forEach((property) => {\n\n            if (!data[property]) {\n                return;\n            }\n\n            const {\n                placeholder,\n                element,\n            } = data[property];\n\n            element.classList.toggle(\"is-in-play\", this.isInPlay(data));\n            element.classList.toggle(\"is-dead\", this.isDead(data));\n\n            if (shouldShow && placeholder.parentElement) {\n                placeholder.replaceWith(element);\n            } else if (!shouldShow && element.parentElement) {\n                element.replaceWith(placeholder);\n            }\n\n        });\n\n    }\n\n    /**\n     * A helper function for drawing or updating all entries in the night order\n     * lists.\n     */\n    drawAllCharacters() {\n        this.data.forEach((data) => this.drawCharacterByData(data));\n    }\n\n    /**\n     * Checks to see if the given data represents a character that's fully dead\n     * (i.e. there are no character tokens for this character that are still\n     * alive).\n     *\n     * @param  {Object} data\n     *         Data to check.\n     * @return {Boolean}\n     *         true if the character is fully dead, false otherwise.\n     */\n    isDead(data) {\n        return data.inPlay > 0 && data.alive === 0;\n    }\n\n    /**\n     * Checks to see if the given data has any characters in play.\n     *\n     * @param  {Object} data\n     *         Data to check.\n     * @return {Boolean}\n     *         true if any characters are in play, false otherwise.\n     */\n    isInPlay(data) {\n        return data.inPlay > 0;\n    }\n\n    /**\n     * Checks to see if the given data suggests that the character's entry in\n     * the night order lists should be showing.\n     *\n     * @param  {Object} data\n     *         Data to check.\n     * @return {Boolean}\n     *         true if the entries should be showing, false otherwise.\n     */\n    shouldShow(data) {\n\n        const {\n            showDead,\n            showNotInPlay,\n        } = this;\n        const isDead = this.isDead(data);\n        const isInPlay = this.isInPlay(data);\n\n        return (\n            (isInPlay && !isDead)\n            || (!isInPlay && showNotInPlay)\n            || (isDead && showDead)\n        );\n\n    }\n\n    /**\n     * Gets the index in {@link NightOrder#data} for the data that represents\n     * the given character.\n     *\n     * @param  {CharacterToken} character\n     *         Character whose data's index should be returned.\n     * @return {Number}\n     *         Index of the character within the data.\n     */\n    getDataIndex(character) {\n\n        const id = character.getId();\n\n        return this.data.findIndex((data) => {\n            return data.character.getId() === id;\n        });\n\n    }\n\n    /**\n     * Helper function for getting the item within {@link NightOrder#data} that\n     * represents the given character. If the character cannot be found an error\n     * is thrown.\n     *\n     * @param  {CharacterToken} character\n     *         Character whose data should be returned.\n     * @return {Object}\n     *         Data for the given character.\n     * @throws {ReferenceError}\n     *         The character must exist within the data.\n     */\n    getData(character) {\n\n        const index = this.getDataIndex(character);\n\n        if (index < 0) {\n\n            throw new ReferenceError(\n                `Cannot find character \"${character.getId()}\"`\n            );\n\n        }\n\n        return this.data[index];\n\n    }\n\n    /**\n     * Checks to see if the given character exists within the data.\n     *\n     * @param  {CharacterToken} character\n     *         Character to check for.\n     * @return {Boolean}\n     *         true if the character exists, false otherwise.\n     */\n    hasCharacter(character) {\n        return this.getDataIndex(character) > -1;\n    }\n\n    /**\n     * Updates {@link NightOrder#data} for the given character to register that\n     * it has been added in play.\n     *\n     * @param {CharacterToken} character\n     *        Character whose data should be updated.\n     */\n    addCharacter(character) {\n\n        const data = this.getData(character);\n\n        this.adjustInPlay(data, 1);\n\n        if (!character.getIsDead()) {\n            this.adjustAlive(data, 1);\n        }\n\n        this.drawCharacterByData(data);\n\n    }\n\n    /**\n     * Updates {@link NightOrder#data} for the given character to register that\n     * it has been removed from play.\n     *\n     * @param {CharacterToken} character\n     *        Character whose data should be updated.\n     */\n    removeCharacter(character) {\n\n        const data = this.getData(character);\n\n        if (!character.getIsDead()) {\n            this.adjustAlive(data, -1);\n        }\n\n        this.adjustInPlay(data, -1);\n        this.drawCharacterByData(data);\n\n    }\n\n    /**\n     * Updates {@link NightOrder#data} for the given character to register that\n     * the character has either died or been revived.\n     *\n     * @param {CharacterToken} character\n     *        Character whose data should be updated.\n     * @param {Boolean} isDead\n     *        true if the character is dead, false otherwise.\n     */\n    toggleDead(character, isDead) {\n\n        const data = this.getData(character);\n\n        this.adjustAlive(data, (\n            isDead\n            ? -1\n            : 1\n        ));\n        this.drawCharacterByData(data);\n\n    }\n\n    /**\n     * Adjusts the data's \"alive\" value based on the quantity given. The final\n     * result is limited so that it cannot exceed the \"inPlay\" value and cannot\n     * drop below 0.\n     *\n     * @param {Object} data\n     *        Data to update.\n     * @param {Number} quantity\n     *        Amount to update the data by. If this value is negative then the\n     *        value will be reduced.\n     */\n    adjustAlive(data, quantity) {\n        data.alive = Math.min(data.inPlay, Math.max(data.alive + quantity, 0));\n    }\n\n    /**\n     * Adjusts the data's \"inPlay\" value based on the quantity given. The final\n     * result is limited so that it cannot drop below 0.\n     *\n     * @param {Object} data\n     *        Data to update.\n     * @param {Number} quantity\n     *        Amount to update the data by. If this value is negative then the\n     *        value will be reduced.\n     */\n    adjustInPlay(data, quantity) {\n        data.inPlay = Math.max(0, data.inPlay + quantity);\n    }\n\n}\n","import Observer from \"../classes/Observer.js\";\nimport NightOrder from \"../classes/NightOrder.js\";\nimport {\n    lookupOne,\n    lookupOneCached,\n    announceInput,\n} from \"../utils/elements.js\";\n\nconst gameObserver = Observer.create(\"game\");\nconst tokenObserver = Observer.create(\"token\");\nconst nightOrder = new NightOrder();\n\nnightOrder.setHolders({\n    first: lookupOneCached(\"#first-night\"),\n    other: lookupOneCached(\"#other-nights\")\n});\n\ngameObserver.on(\"characters-selected\", ({ detail }) => {\n\n    nightOrder.reset();\n    nightOrder.setCharacters(\n        detail.characters\n            .filter((character) => ![\"fabled\", \"traveller\"].includes(character.getTeam()))\n    );\n    nightOrder.drawAllNightOrders();\n\n});\n\n// #145 - Show the \"First Night\" order after clearing the grimoire.\ngameObserver.on(\"clear\", () => {\n    lookupOneCached(\".js--night-order--carousel\").scrollLeft = 0;\n});\n\n// TODO: Travellers and Fabled should be unique, it should only be possible to\n// add 1 of each. Add that limitation so we don't need to count them anymore.\nconst specialRoles = {\n    fabled: Object.create(null),\n    traveller: Object.create(null)\n}\n\ntokenObserver.on(\"character-add\", ({ detail }) => {\n\n    const {\n        character\n    } = detail;\n    const team = character.getTeam();\n\n    // #155 - If we have a traveller or a fabled, add it to the night order.\n    if (specialRoles[team]) {\n\n        const id = character.getId();\n\n        if (!specialRoles[team][id]) {\n            specialRoles[team][id] = 0;\n        }\n\n        specialRoles[team][id] += 1;\n\n        nightOrder.setCharacter(character);\n        nightOrder.placeInOrder(character);\n\n    }\n\n    // #131 - check the character isn't from the previous script.\n    if (!nightOrder.hasCharacter(character)) {\n        return;\n    }\n\n    nightOrder.addCharacter(character);\n\n});\n\ntokenObserver.on(\"character-remove\", ({ detail }) => {\n\n    const {\n        character\n    } = detail;\n    const team = character.getTeam();\n\n    // #155 - If we're removing a fabled or traveller, remove them if necessary.\n    if (specialRoles[team]) {\n\n        const id = character.getId();\n\n        if (specialRoles[team][id]) {\n\n            specialRoles[team][id] -= 1;\n\n            if (specialRoles[team][id] <= 0) {\n\n                nightOrder.unsetCharacter(character);\n                delete specialRoles[team][id];\n\n            }\n\n        }\n\n    }\n\n    // #131 - check the character isn't from the previous script.\n    if (!nightOrder.hasCharacter(character)) {\n        return;\n    }\n\n    nightOrder.removeCharacter(character);\n\n});\n\ntokenObserver.on(\"shroud-toggle\", ({ detail }) => {\n\n    // #131 - check the character isn't from the previous script.\n    if (!nightOrder.hasCharacter(detail.character)) {\n        return;\n    }\n\n    nightOrder.toggleDead(detail.character, detail.isDead);\n\n});\n\nconst showDead = lookupOne(\"#show-dead\");\n\nshowDead.addEventListener(\"change\", ({ target }) => {\n\n    const showDead = target.checked;\n\n    nightOrder.setShowDead(showDead);\n    gameObserver.trigger(\"night-order-show-dead\", {\n        showDead\n    });\n\n});\n\nlookupOne(\"#show-all\").addEventListener(\"change\", ({ target }) => {\n\n    const showAll = target.checked;\n\n    nightOrder.setShowNotInPlay(showAll);\n    gameObserver.trigger(\"night-order-show-all\", {\n        showAll\n    });\n\n    // Showing all characters not in play but hiding the dead can seem\n    // confusing. This forces \"show dead\" to be true when showing all, although\n    // the user can hide the dead seperately.\n    if (showAll && !showDead.checked) {\n\n        showDead.checked = true;\n        announceInput(showDead);\n\n    }\n\n});\n","import Template from \"../classes/Template.js\";\nimport InfoToken from \"../classes/InfoToken.js\";\nimport Observer from \"../classes/Observer.js\";\nimport Dialog from \"../classes/Dialog.js\";\nimport {\n    lookupOne\n} from \"../utils/elements.js\";\n\nconst buttonHolder = lookupOne(\"#info-token-button-holder\");\nconst dialogHolder = lookupOne(\"#info-token-dialog-holder\");\n\nInfoToken.setTemplates({\n    button: Template.create(lookupOne(\"#info-token-button-template\")),\n    dialog: Template.create(lookupOne(\"#info-token-dialog-template\"))\n});\nInfoToken.setHolders({\n    button: buttonHolder,\n    custom: lookupOne(\"#info-token-custom-holder\"),\n    dialog: dialogHolder\n});\n\nJSON.parse(buttonHolder.dataset.infoTokens).forEach((data) => {\n\n    const token = new InfoToken(data);\n    token.draw();\n\n});\n\nconst observer = Observer.create(\"info-token\");\n\nlookupOne(\"#add-info-token\").addEventListener(\"click\", () => {\n\n    const text = window.prompt(window.I18N.customInfoToken);\n\n    if (!text) {\n        return;\n    }\n\n    const token = new InfoToken({\n        raw: text,\n        custom: true\n    });\n    token.draw();\n\n    observer.trigger(\"info-token-added\", {\n        token\n    });\n\n});\n\nconst dialog2token = new WeakMap();\n\nobserver.on(\"info-token-added\", ({ detail }) => {\n\n    const {\n        token\n    } = detail;\n\n    dialog2token.set(token.getDialog(), token);\n\n});\n\nfunction editToken(token, raw) {\n\n    token.updateRaw(raw);\n    observer.trigger(\"info-token-updated\", {\n        token\n    });\n\n}\n\nfunction deleteToken(token) {\n\n    Dialog.create(token.getDialog()).hide();\n    token.remove();\n    observer.trigger(\"info-token-deleted\", {\n        token\n    });\n\n}\n\ndialogHolder.addEventListener(\"click\", ({ target }) => {\n\n    const button = target.closest(\"button[data-action]\");\n\n    if (!button) {\n        return;\n    }\n\n    const token = dialog2token.get(button.closest(\".js--info-token--dialog\"));\n\n    if (!token) {\n        return;\n    }\n\n    switch (button.dataset.action) {\n\n    case \"edit\":\n\n        const data = token.getData();\n        const text = window.prompt(window.I18N.customInfoToken, data.raw);\n\n        if (text) {\n            editToken(token, text);\n        } else {\n            deleteToken(token);\n        }\n\n        break;\n\n    case \"delete\":\n\n        deleteToken(token);\n        break;\n\n    }\n\n});\n","import {\n    lookupOne,\n    announceInput\n} from \"../utils/elements.js\";\n\nconst button = lookupOne(\"#clear-st-notes\");\nconst field = lookupOne(\"#st-notes\");\n\nbutton.addEventListener(\"click\", () => {\n\n    if (window.confirm(button.dataset.warning)) {\n\n        field.value = \"\";\n        announceInput(field);\n\n    }\n\n});\n","/**\n * The current version, in semver.\n * @type {String}\n */\nexport const VERSION = \"0.9.44\";\n","import {\n    VERSION\n} from \"../constants/version.js\";\nimport {\n    lookupOne\n} from \"../utils/elements.js\";\n\n// Populate the version number.\nlookupOne(\"#version\").textContent = VERSION;\n","import Store from \"../classes/Store.js\";\nimport Observer from \"../classes/Observer.js\";\nimport TokenStore from \"../classes/TokenStore.js\";\n// import Bluffs from \"../classes/Bluffs.js\";\nimport BluffsGroups from \"../classes/BluffsGroups.js\";\nimport Dialog from \"../classes/Dialog.js\";\nimport InfoToken from \"../classes/InfoToken.js\";\nimport Names from \"../classes/Names.js\";\nimport {\n    lookup,\n    lookupOne,\n    lookupOneCached,\n    announceInput\n} from \"../utils/elements.js\";\nimport {\n    VERSION\n} from \"../constants/version.js\";\nimport {\n    compareVersions\n} from \"../utils/numbers.js\";\n\nconst store = Store.create(\"pocket-grimoire\");\nconst gameObserver = Observer.create(\"game\");\nconst tokenObserver = Observer.create(\"token\");\nconst infoTokenObserver = Observer.create(\"info-token\");\n\nconst padElement = lookupOneCached(\".js--pad\");\nconst pad = padElement.pad;\nconst names = Names.create();\n\ngameObserver.on(\"characters-selected\", ({ detail }) => {\n\n    store.setCharacters(\n        detail.name,\n        detail.characters.map((character) => (\n            character.isCustom()\n            ? character.getAllData()\n            : character.getId()\n        )),\n        detail.game\n    );\n    store.removeStaleInputs();\n\n});\n\ngameObserver.on(\"pad-height-change\", ({ detail }) => {\n    store.setHeight(detail.height);\n});\n\ntokenObserver.on(\"character-add\", ({ detail }) => {\n    store.addToken(detail.character);\n});\n\ntokenObserver.on(\"character-remove\", ({ detail }) => {\n    store.removeToken(detail.character);\n});\n\ntokenObserver.on(\"reminder-add\", ({ detail }) => {\n    store.addToken(detail.reminder);\n});\n\ntokenObserver.on(\"reminder-remove\", ({ detail }) => {\n    store.removeToken(detail.reminder);\n});\n\ntokenObserver.on(\"move\", ({ detail }) => {\n\n    const {\n        element,\n        left,\n        top,\n        zIndex\n    } = detail;\n    const token = (\n        pad.getCharacterByToken(element)\n        || pad.getReminderByToken(element)\n    );\n\n    if (token) {\n        store.moveToken(token, left, top, zIndex);\n    }\n\n});\n\ntokenObserver.on(\"zindex\", ({ detail }) => {\n\n    const {\n        element,\n        zIndex\n    } = detail;\n    const token = (\n        pad.getCharacterByToken(element)\n        || pad.getReminderByToken(element)\n    );\n\n    if (token) {\n        store.alignToken(token, zIndex);\n    }\n\n});\n\ntokenObserver.on(\"shroud-toggle\", ({ detail }) => {\n    store.toggleDead(pad.getCharacterByToken(detail.token), detail.isDead);\n});\n\ntokenObserver.on(\"rotate-toggle\", ({ detail }) => {\n    store.rotate(pad.getCharacterByToken(detail.token), detail.isUpsideDown);\n});\n\ntokenObserver.on(\"set-player-name\", ({ detail }) => {\n\n    store.setPlayerName(pad.getCharacterByToken(detail.token), detail.name);\n    names.add(detail.name);\n\n});\n\ntokenObserver.on(\"ghost-vote-toggle\", ({ detail }) => {\n\n    store.setGhostVote(\n        pad.getCharacterByToken(detail.token),\n        detail.hasGhostVote\n    );\n\n});\n\ntokenObserver.on(\"bluff\", ({ detail }) => {\n    store.setBluffs(detail.data);\n});\n\ninfoTokenObserver.on(\"info-token-added\", ({ detail }) => {\n    store.saveInfoToken(detail.token, detail.index);\n});\n\ninfoTokenObserver.on(\"info-token-updated\", ({ detail }) => {\n    store.updateInfoToken(detail.token);\n});\n\ninfoTokenObserver.on(\"info-token-deleted\", ({ detail }) => {\n    store.removeInfoToken(detail.token);\n});\n\nconst savedVersion = store.getVersion();\n\nif (!savedVersion || compareVersions(savedVersion, VERSION) === -1) {\n\n    if (\n        savedVersion\n        && window.confirm(I18N.versionChange)\n    ) {\n        Dialog.create(lookupOneCached(\"#clear-cache\")).show();\n    }\n\n    store.setVersion(VERSION);\n\n}\n\nconst {\n    body\n} = document;\n\nbody.addEventListener(\"input\", ({ target }) => {\n\n    const input = target.closest(\"input,select,textarea\");\n\n    if (!input.hasAttribute(\"data-no-store\")) {\n        store.saveInput(input);\n    }\n\n});\n\nbody.addEventListener(\"toggle\", ({ target }) => {\n    store.saveDetails(target.closest(\"details\"));\n}, {\n    capture: true\n});\n\nconst storeData = store.read();\n\nTokenStore.ready((tokenStore) => {\n\n    // Re-select the characters.\n\n    const info = storeData.characters;\n\n    if (info && info.characters && info.characters.length) {\n\n        gameObserver.trigger(\"characters-selected\", {\n            name: info.name,\n            characters: info.characters\n                .map((item) => (\n                    tokenStore.getCharacter(\n                        typeof item === \"string\"\n                        ? item\n                        : item.id\n                    )\n                    || tokenStore.createCustomCharacter(item)\n                ))\n                .filter(Boolean),\n            game: info.game\n        });\n\n    }\n\n    // Re-place the tokens.\n\n    let finalZIndex = 0;\n\n    storeData.tokens.forEach(({\n        id,\n        left,\n        top,\n        zIndex,\n        isDead,\n        isUpsideDown,\n        playerName,\n        ghostVote\n    }) => {\n\n        const isCharacter = TokenStore.isCharacterId(id);\n        const info = (\n            isCharacter\n            ? pad.addCharacter(tokenStore.getCharacterClone(id))\n            : pad.addReminder(tokenStore.getReminderClone(id))\n        );\n        const {\n            token,\n            character\n        } = info;\n\n        pad.moveToken(token, left, top, zIndex);\n\n        if (isCharacter) {\n\n            pad.toggleDead(character, Boolean(isDead));\n            pad.rotate(character, Boolean(isUpsideDown));\n            pad.setPlayerName(character, playerName);\n            pad.setGhostVote(character, Boolean(ghostVote));\n\n        }\n\n        if (zIndex > finalZIndex) {\n            finalZIndex = zIndex;\n        }\n\n    });\n\n    pad.setZIndex(finalZIndex);\n\n    // Re-set the bluffs.\n    // Convert the previous bluffs format into the new one.\n\n    let {\n        bluffs\n    } = storeData;\n\n    if (!Object.keys(bluffs).length) {\n        bluffs = BluffsGroups.getEmptyData();\n    }\n\n    if (typeof bluffs[\"#bluff-1\"] === \"string\") {\n\n        const empty = BluffsGroups.getEmptyData();\n        empty.groups[0].set = Object.values(bluffs);\n        bluffs = empty;\n\n    }\n\n    BluffsGroups.get().ready(bluffs);\n\n    // Re-populate the inputs.\n\n    Object.entries(storeData.inputs).forEach(([selector, value]) => {\n\n        const inputs = lookup(selector);\n\n        const type = inputs[0]?.type;\n        const isRadio = type === \"radio\";\n        const input = (\n            isRadio\n            ? inputs.find((input) => input.value === value)\n            : inputs[0]\n        );\n\n        if (!input) {\n            return;\n        }\n\n        if (isRadio) {\n            input.checked = true;\n        } else if (type === \"checkbox\") {\n            input.checked = value;\n        } else {\n            input.value = value;\n        }\n\n        announceInput(input);\n\n    });\n\n    gameObserver.trigger(\"inputs-repopulated\");\n\n    // Re-open or re-close the details.\n\n    Object.entries(storeData.details).forEach(([selector, isOpen]) => {\n\n        const details = lookupOne(selector);\n\n        if (!details) {\n            return;\n        }\n\n        const isOpenNow = details.hasAttribute(\"open\");\n        details.open = isOpen;\n\n        if (isOpenNow !== isOpen) {\n\n            details.dispatchEvent(new Event(\"toggle\", {\n                bubbles: false\n            }));\n\n        }\n\n    });\n\n    // Re-set the height of the pad.\n    // CSS `resize` works by changing the `height` style on the element itself\n    // which is why we're setting it like this instead of setting a CSS custom\n    // property and referring to it in the style sheet.\n\n    if (storeData.height) {\n        padElement.style.height = storeData.height;\n    }\n\n    // Re-add any custom info tokens.\n\n    storeData.infoTokens.forEach((raw, i) => {\n\n        const token = new InfoToken({\n            raw,\n            custom: true\n        });\n        token.draw();\n\n        infoTokenObserver.trigger(\"info-token-added\", {\n            token,\n            index: i\n        });\n\n    });\n\n});\n"],"names":["Token","data","_classCallCheck","this","processData","setup","constructor","Proxy","get","target","property","startsWith","getData","convertProperty","key","value","clipped","replace","charAt","toLowerCase","slice","Object","prototype","hasOwnProperty","call","hasData","ReferenceError","concat","JSON","parse","stringify","Template","template","cache","identify","populates","clone","content","cloneNode","entries","forEach","_ref","_ref2","_slicedToArray","selector","populate","lookup","element","create","Observer","_createClass","dummy","document","createElement","eventName","handler","addEventListener","removeEventListener","detail","CustomEvent","bubbles","cancelable","event","dispatchEvent","name","observers","_defineProperty","Jinx","trick","reason","state","ready","active","observer","forceState","_this$observer","undefined","trigger","jinx","toggleState","toggleReady","activate","Boolean","character","matches","isHomebrew","_this$trick","getId","_this","drawImg","draw","id","textContent","getName","src","getImage","alt","title","ReminderToken","_Token","_callSuper","arguments","_inherits","_objectSpread","text","image","characterId","characterName","isGlobal","_this$data","templates","token","_this$data2","list","dataset","reminderId","classList","toggle","append","drawToken","reminder","global","push","emptyProperty","Symbol","customProperty","CharacterToken","edition","team","firstNight","firstNightReminder","otherNight","otherNightReminder","reminders","ability","special","isDead","isUpsideDown","hasGhostVote","jinxes","_superPropGet","getReminders","addReminder","getJinxes","addJinx","toggleGhostVote","getIsDead","getIsUpsideDown","getHasGhostVote","setTarget","characters","toggleJinxReady","toggleTrick","toggleTarget","filter","isReady","isActive","type","isArray","Array","length","find","getSpecialData","_this$data$reminders","_this$data$remindersG","remindersGlobal","top","_this2","tokenId","select","closest","htmlFor","isFirst","_this$data3","nightOrder","order","striptags","string","String","markdown2html","supplant","replacements","whole","index","InfoToken","interpret","drawTrigger","drawDialog","colour","custom","_this$constructor","holders","holder","button","style","setProperty","dialog","lastElementChild","markup","_this$constructor2","innerHTML","hidden","raw","lookupOne","remove","lower","ID_PREFIX","makeId","prefix","deepClone","object","deepFreeze","_typeof","values","item","freeze","empty","keys","Store","read","tokens","infoTokens","listener","on","window","localStorage","setItem","defaults","getItem","bluffs","write","url","results","game","indexOf","splice","left","zIndex","addToken","assign","setGhostVote","playerName","names","includes","ghostVote","input","form","checked","nodeName","isCheckbox","hasAttribute","formId","inputs","fromEntries","details","_ref4","open","infoToken","getRaw","height","version","user","res","rej","promise","TokenStore","createCharacter","addGlobal","createReminder","getCharacter","trickCharacter","newJinx","_data$reminders","_data$remindersGlobal","normaliseId","isCustom","getCharacterClone","EMPTY","getReminder","getIsHomebrew","resolve","isReminderId","test","then","Promise","reject","LANGUAGE","documentElement","lang","Names","alphabetise","_toConsumableArray","sort","a","b","localeCompare","Error","map","instance","fetchFromStore","store","getLookup","fetch","response","json","setLookup","gameObserver","setTrackWidth","min","max","URLS","breakdown","setTemplates","setTemplate","setObserver","all","_ref3","I18N","emptyCharacterAbility","goodTeam","evilTeam","body","_ref6","Dialog","createFromTrigger","show","_ref7","lookupOneCached","filterList","e","preventDefault","location","href","_ref8","requestSubmit","rangeObserver","MutationObserver","_ref9","announceScript","hide","showInputError","error","setCustomValidity","reportValidity","output","observe","attributes","attributeFilter","normalMap","extractMetaEntry","metaIndex","findIndex","_ref5","setFormLoadingState","isLoading","submit","progress","setAttribute","getAttribute","convertCharacterId","processJSON","every","isScriptJson","invalidScript","some","containsHomebrew","normalised","entry","normaliseHomebrew","homebrew","method","mode","credentials","headers","redirect","referrerPolicy","success","message","reasons","getOfficialCharacter","createCustomCharacter","join","noCharacters","setFieldsValidity","fields","isVisible","inputted","field","required","fileInput","fileInputRender","nextElementSibling","urlInput","pasteInput","uploader","radios","customInputs","shuffle","array","numbers","crypto","getRandomValues","Uint16Array","from","i","clamp","Math","parseVersion","semver","split","Number","times","number","context","floor","abs","toPosInt","radio","tokenStore","myURL","decodeURIComponent","encodeURIComponent","files","reader","FileReader","_ref0","result","readAsText","getLabelText","getAllCharacters","getEdition","lastIndexOf","placeholder","announceInput","HIDE","tokenObserver","setTotals","count","lookupCached","highlightRandomInTeam","chosen","isChecked","playerCount","getBreakdown","total","getGroup","teams","getTeam","reduce","grouped","group","wrapper","isTeamPopulated","replaceContentsMany","drawSelect","countInputs","maxPlayers","traveller","disabled","_ref1","amount","quantityAmount","checkbox","_ref10","validationInput","_ref11","ids","_ref12","filtered","duplicates","flat","bagDisabled","hasSpecialData","_e$submitter","isShowAll","submitter","_ref13","_jinx$getTarget","_input$closest","getTarget","querySelector","breakdownTable","highlightBreakdown","cell","row","_lookupCached$index","add","_ref14","characterDecisionDialog","isAutoAdd","getAbility","SHOW","defaultValue","pad","trimmed","trim","setPlayerName","characterStore","drawQRCode","includeTravellers","includeFabled","qrCode","anchor","URL","_qrCode$dataset","searchParams","set","QRCode","msg","toString","ecl","clears","noop","reload","Tokens","reset","updatePadDimensions","addListeners","dragHandler","isDragging","xOffset","yOffset","rect","getBoundingClientRect","padLeft","padTop","padWidth","width","padHeight","scollHandler","func","_len","args","_key","requestAnimationFrame","apply","rafThrottle","onScroll","onMousedown","onMouseup","onClick","onResize","startDrag","advanceZIndex","endDragging","tokenType","_this3","clientX","clientY","targetTouches","_element$getBoundingC","dragObject","passive","_element$getBoundingC2","leftValue","topValue","moveTo","isNaN","x","getPropertyValue","y","z","_this4","Positioner","setDefaults","topLeft","setContainerSize","setTokenSize","setTotal","tokenWidth","tokenHeight","layout","layouts","_Positioner","ellipse","coordinates","radiusX","radiusY","dp","radians","sqrt","pow","sin","cos","offset","PI","circ","nextPoint","run","pointX","pointY","diagonal","xIncrement","yIncrement","horizontal","vertical","Pad","positioner","coords","info","drawCharacter","OFFSET","addCharacter","getPosition","preserveReference","undrawCharacter","_this$characters$find","removeCharacter","getCharacterByToken","deadState","getInfoByCharacter","toggleDead","getToken","rotateState","rotate","nameTag","getPlayerName","ghostVoteState","_this$reminders$find","removeReminder","getReminderByToken","setZIndex","generateCoords","_this$element$getBoun","dimensions","console","warn","noCharacter","getEmptyCharacter","_token$getBoundingCli","scale","getComputedStyle","tokenCharacter","styles","shadowOffset","shadowAmount","parseFloat","parsed","container","_ref9$generate","generate","getPadDimensions","getTokenDimensions","setLayout","isFinite","padElement","mutations","updateDimensions","drawList","getGlobal","addNewCharacter","html","setPositioner","tokenLayout","updatePositioner","grimoireSection","isOpen","setTokenStore","ProcessList","has","process","SelectDialog","_Dialog","processList","addUnique","execute","last","SettableTitle","start","previous","showInput","focus","hideInput","updatePrevious","setTitle","announceUpdate","stopPropagation","blur","isShowingInput","toggleInput","getStartText","_this$start","Draggable","settings","children","Set","dragged","createHandlers","addEventListeners","_this$settings","dragClass","dragSelector","onChildDragStart","dataTransfer","child","effectAllowed","setData","onChildDragEnd","_event$target$closest","box","xDistance","yDistance","POSITIVE_INFINITY","source","parentNode","current","previousSibling","nodeType","Node","DOCUMENT_NODE","pointer","dropEffect","getClosestElement","insertBefore","isBefore","move","childClass","removeAttribute","removeChild","TokenDialog","entryTemplate","setIds","discoverElements","activateSettableTitle","activateDraggable","drawCharacters","setMultipleTitle","removeButton","removeItem","removeIdByIndex","getIndex","settableTitle","draggable","existingId","_this$settableTitle$g","multipleTitle","getForm","multiple","_characters$","getCharacters","isMultiple","removeAllChildren","titleText","getMultipleTitle","setStartText","querySelectorAll","addChild","recentReminders","characterShowDialog","tokenDialog","hideDialog","setEntryTemplate","getElement","getTokenPosition","items","existing","prepend","toggleDeadByToken","rotateByToken","characterListDialog","addProcess","click","replaceOnPadProcess","_pad$addCharacter","newToken","_data$coords","oldCharacter","moveToken","removeProcess","addToDialogProcess","addId","characterNameInput","setPlayerNameForToken","ghostVoteButton","setGhostButtonState","setGhostVoteForToken","getPlayerNameForToken","contains","removeCharacterByToken","first","other","assignCounts","dataKey","getSortedKeys","updateTokens","getFirstNight","getOtherNight","firstArray","otherArray","tokenListTemplate","tokenList","_ref15","_ref16","char","_ref17","getCharacterId","tokenListDialog","_ref18","reminderList","reminderListDialog","getCoords","addReminderQuick","getReminderClone","isAddMultiple","toggleReminder","multipleReminders","addAllReminders","isNowAddMultiple","reminderDialog","reminderHolder","removeReminderByToken","counts","_lookupOne","_lookupOne2","BluffDialog","isOrphan","showTokenButton","isEmpty","bluffDialog","BluffSet","emptyCharacter","RangeError","validateIndex","unsetCharacterByIndex","BluffsGroup","bluffSet","groupId","getTitle","serialise","setIndex","setCharacter","scrollIntoView","block","READY","display","bluffGroup","_this$element","settableTitleTitle","BluffsGroups","groups","visibleGroupIndex","announceUpdates","IntersectionObserver","intersectionRatio","VISIBLE","root","threshold","createEmptyGroup","setElement","getSelector","maybeAnnounceUpdate","removeByIndex","unobserve","updateIndicies","getVisibleGroup","setSetIndex","getSetIndex","redrawButton","removeAll","convertId","setVisibleGroupIndex","_construct","setEmptyCharacter","bluffGroupsContainer","bluffGroups","toggleBluffListClass","className","setInnerIndex","setSettableTitle","disableAnnouncements","getEmptyData","enableAnnouncements","addEmpty","characterTemplate","rolesInPlay","bluffListDialog","redraw","_target$closest","charIndex","confirm","officialTravellers","homebrewTravellers","populateTravellers","travellers","travellerIDs","travellerCount","homebrewFabled","officialFabled","populateFabled","fabled","fable","fabledCount","gameData","addListener","script","date","Date","toISOString","day","players","me","dead","randomUUID","suspectedRole","qr","trickToTarget","jinxTemplate","unregisterJinx","_jinx$getTrick2","trickId","getTrick","activateJinx","_jinx$getTrick","registerJinx","getAllJinxes","getAllHomebrewJinxes","removeAllHomebrewJinxes","setIsHomebrew","readyAllJinxes","allJinxes","_trickToTarget$id","toggleJinxTarget","targetId","toggleJinxTrick","jinxSection","jinxTable","_jinxes$_char$getId","getIsGlobal","endsWith","NightOrder","showDead","showNotInPlay","drawAllCharacters","alive","inPlay","createComment","drawNightOrder","firstElementChild","getDataIndex","next","datum","insertable","shouldShow","parentElement","isFirstNight","fragment","_data$property","createDocumentFragment","_this5","drawCharacterByData","_this6","_data$property2","isInPlay","replaceWith","_this7","adjustInPlay","adjustAlive","quantity","setHolders","setCharacters","drawAllNightOrders","scrollLeft","specialRoles","placeInOrder","hasCharacter","unsetCharacter","setShowDead","showAll","setShowNotInPlay","buttonHolder","dialogHolder","prompt","customInfoToken","dialog2token","WeakMap","deleteToken","getDialog","action","updateRaw","editToken","warning","VERSION","infoTokenObserver","getAllData","removeStaleInputs","setHeight","removeToken","alignToken","setBluffs","saveInfoToken","updateInfoToken","removeInfoToken","version2","parts1","parts2","savedVersion","getVersion","part","versionChange","setVersion","saveInput","saveDetails","capture","storeData","finalZIndex","isCharacter","isCharacterId","_inputs$","_ref19","isRadio","_ref20","_ref21","isOpenNow","Event"],"sourceRoot":""}